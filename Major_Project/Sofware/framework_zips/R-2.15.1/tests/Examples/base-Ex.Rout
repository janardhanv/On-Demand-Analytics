
R version 2.15.1 (2012-06-22) -- "Roasted Marshmallows"
Copyright (C) 2012 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: i686-pc-linux-gnu (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "base"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> assign(".oldSearch", search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Arithmetic")
> ### * Arithmetic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Arithmetic
> ### Title: Arithmetic Operators
> ### Aliases: + - * ** / ^ %% %/% Arithmetic
> ### Keywords: arith
> 
> ### ** Examples
> 
> x <- -1:12
> x + 1
 [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13
> 2 * x + 3
 [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27
> x %% 2 #-- is periodic
 [1] 1 0 1 0 1 0 1 0 1 0 1 0 1 0
> x %/% 5
 [1] -1  0  0  0  0  0  1  1  1  1  1  2  2  2
> 
> 
> 
> cleanEx()
> nameEx("Bessel")
> ### * Bessel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Bessel
> ### Title: Bessel Functions
> ### Aliases: bessel Bessel besselI besselJ besselK besselY
> ### Keywords: math
> 
> ### ** Examples
> 
> require(graphics)
> 
> nus <- c(0:5, 10, 20)
> 
> x <- seq(0, 4, length.out = 501)
> plot(x, x, ylim = c(0, 6), ylab = "", type = "n",
+      main = "Bessel Functions  I_nu(x)")
> for(nu in nus) lines(x, besselI(x, nu=nu), col = nu+2)
> legend(0, 6, legend = paste("nu=", nus), col = nus+2, lwd = 1)
> 
> x <- seq(0, 40, length.out = 801); yl <- c(-.8, .8)
> plot(x, x, ylim = yl, ylab = "", type = "n",
+      main = "Bessel Functions  J_nu(x)")
> for(nu in nus) lines(x, besselJ(x, nu=nu), col = nu+2)
> legend(32,-.18, legend = paste("nu=", nus), col = nus+2, lwd = 1)
> 
> ## Negative nu's :
> xx <- 2:7
> nu <- seq(-10, 9, length.out = 2001)
> op <- par(lab = c(16, 5, 7))
> matplot(nu, t(outer(xx, nu, besselI)), type = "l", ylim = c(-50, 200),
+         main = expression(paste("Bessel ", I[nu](x), " for fixed ", x,
+                                 ",  as ", f(nu))),
+         xlab = expression(nu))
> abline(v=0, col = "light gray", lty = 3)
> legend(5, 200, legend = paste("x=", xx), col=seq(xx), lty=seq(xx))
> par(op)
> 
> x0 <- 2^(-20:10)
> plot(x0, x0^-8, log="xy", ylab="",type="n",
+      main = "Bessel Functions  J_nu(x)  near 0\n log - log  scale")
> for(nu in sort(c(nus, nus+.5)))
+     lines(x0, besselJ(x0, nu=nu), col = nu+2)
> legend(3, 1e50, legend = paste("nu=", paste(nus, nus+.5, sep=",")),
+        col = nus + 2, lwd = 1)
> 
> plot(x0, x0^-8, log="xy", ylab="", type="n",
+      main = "Bessel Functions  K_nu(x)  near 0\n log - log  scale")
> for(nu in sort(c(nus, nus+.5)))
+     lines(x0, besselK(x0, nu=nu), col = nu+2)
> legend(3, 1e50, legend = paste("nu=", paste(nus, nus+.5, sep=",")),
+        col = nus + 2, lwd = 1)
> 
> x <- x[x > 0]
> plot(x, x, ylim=c(1e-18, 1e11), log = "y", ylab = "", type = "n",
+      main = "Bessel Functions  K_nu(x)")
> for(nu in nus) lines(x, besselK(x, nu=nu), col = nu+2)
> legend(0, 1e-5, legend=paste("nu=", nus), col = nus+2, lwd = 1)
> 
> yl <- c(-1.6, .6)
> plot(x, x, ylim = yl, ylab = "", type = "n",
+      main = "Bessel Functions  Y_nu(x)")
> for(nu in nus){
+     xx <- x[x > .6*nu]
+     lines(xx, besselY(xx, nu=nu), col = nu+2)
+ }
> legend(25, -.5, legend = paste("nu=", nus), col = nus+2, lwd = 1)
> 
> ## negative nu in bessel_Y -- was bogus for a long time
> curve(besselY(x, -0.1), 0, 10, ylim = c(-3,1), ylab = '')
> for(nu in c(seq(-0.2, -2, by = -0.1)))
+   curve(besselY(x, nu), add = TRUE)
> title(expression(besselY(x, nu) * "   " *
+                  {nu == list(-0.1, -0.2, ..., -2)}))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("Colon")
> ### * Colon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Colon
> ### Title: Colon Operator
> ### Aliases: : colon
> ### Keywords: manip
> 
> ### ** Examples
> 
> 1:4
[1] 1 2 3 4
> pi:6 # real
[1] 3.141593 4.141593 5.141593
> 6:pi # integer
[1] 6 5 4
> 
> f1 <- gl(2,3); f1
[1] 1 1 1 2 2 2
Levels: 1 2
> f2 <- gl(3,2); f2
[1] 1 1 2 2 3 3
Levels: 1 2 3
> f1:f2 # a factor, the "cross"  f1 x f2
[1] 1:1 1:1 1:2 2:2 2:3 2:3
Levels: 1:1 1:2 1:3 2:1 2:2 2:3
> 
> 
> 
> cleanEx()
> nameEx("Comparison")
> ### * Comparison
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Comparison
> ### Title: Relational Operators
> ### Aliases: < <= == != >= > Comparison collation
> ### Keywords: logic
> 
> ### ** Examples
> 
> x <- stats::rnorm(20)
> x < 1
 [1]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE
[13]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
> x[x > 0]
 [1] 0.1836433 1.5952808 0.3295078 0.4874291 0.7383247 0.5757814 1.5117812
 [8] 0.3898432 1.1249309 0.9438362 0.8212212 0.5939013
> 
> x1 <- 0.5 - 0.3
> x2 <- 0.3 - 0.1
> x1 == x2                           # FALSE on most machines
[1] FALSE
> identical(all.equal(x1, x2), TRUE) # TRUE everywhere
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("Constants")
> ### * Constants
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Constants
> ### Title: Built-in Constants
> ### Aliases: Constants LETTERS letters month.abb month.name pi
> ### Keywords: sysdata
> 
> ### ** Examples
> 
> ## John Machin (ca 1706) computed pi to over 100 decimal places
> ## using the Taylor series expansion of the second term of
> pi - 4*(4*atan(1/5) - atan(1/239))
[1] -4.440892e-16
> 
> ## months in English
> month.name
 [1] "January"   "February"  "March"     "April"     "May"       "June"     
 [7] "July"      "August"    "September" "October"   "November"  "December" 
> ## months in your current locale
> format(ISOdate(2000, 1:12, 1), "%B")
 [1] "January"   "February"  "March"     "April"     "May"       "June"     
 [7] "July"      "August"    "September" "October"   "November"  "December" 
> format(ISOdate(2000, 1:12, 1), "%b")
 [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"
> 
> 
> 
> cleanEx()
> nameEx("Control")
> ### * Control
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Control
> ### Title: Control Flow
> ### Aliases: Control if else for in while repeat break next
> ### Keywords: programming iteration logic
> 
> ### ** Examples
> 
> for(i in 1:5) print(1:i)
[1] 1
[1] 1 2
[1] 1 2 3
[1] 1 2 3 4
[1] 1 2 3 4 5
> for(n in c(2,5,10,20,50)) {
+    x <- stats::rnorm(n)
+    cat(n,":", sum(x^2),"\n")
+ }
2 : 0.4261692 
5 : 4.262527 
10 : 9.965956 
20 : 14.54905 
50 : 41.44845 
> f = factor(sample(letters[1:5], 10, replace=TRUE))
> for( i in unique(f) ) print(i)
[1] "b"
[1] "e"
[1] "d"
[1] "a"
[1] "c"
> 
> 
> 
> cleanEx()
> nameEx("Cstack_info")
> ### * Cstack_info
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Cstack_info
> ### Title: Report Information on C Stack Size and Usage
> ### Aliases: Cstack_info
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("DateTimeClasses")
> ### * DateTimeClasses
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: DateTimeClasses
> ### Title: Date-Time Classes
> ### Aliases: DateTimeClasses POSIXct POSIXlt POSIXt print.POSIXct
> ###   print.POSIXlt summary.POSIXct summary.POSIXlt +.POSIXt -.POSIXt
> ###   Ops.POSIXt Math.POSIXt Summary.POSIXct Math.POSIXlt Summary.POSIXlt
> ###   [.POSIXct [<-.POSIXct [[.POSIXct [.POSIXlt [<-.POSIXlt
> ###   as.data.frame.POSIXct as.data.frame.POSIXlt as.list.POSIXct
> ###   .leap.seconds is.na.POSIXlt all.equal.POSIXct c.POSIXct c.POSIXlt
> ###   as.matrix.POSIXlt length.POSIXlt mean.POSIXct mean.POSIXlt str.POSIXt
> ###   check_tzones duplicated.POSIXlt unique.POSIXlt split.POSIXct
> ###   names.POSIXlt names<-.POSIXlt date-time
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Dates")
> ### * Dates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Dates
> ### Title: Date Class
> ### Aliases: Date Dates print.Date summary.Date Math.Date Summary.Date
> ###   [.Date [<-.Date [[.Date as.data.frame.Date as.list.Date c.Date
> ###   mean.Date split.Date
> ### Keywords: utilities chron
> 
> ### ** Examples
> ## Not run: 
> ##D (today <- Sys.Date())
> ##D format(today, "%d %b %Y")  # with month as a word
> ##D (tenweeks <- seq(today, length.out=10, by="1 week")) # next ten weeks
> ##D weekdays(today)
> ##D months(tenweeks)
> ##D as.Date(.leap.seconds)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Encoding")
> ### * Encoding
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Encoding
> ### Title: Read or Set the Declared Encodings for a Character Vector
> ### Aliases: Encoding Encoding<- enc2native enc2utf8
> ### Keywords: utilities character
> 
> ### ** Examples
> 
> ## x is intended to be in latin1
> x <- "fa\xE7ile"
> Encoding(x)
[1] "unknown"
> Encoding(x) <- "latin1"
> x
[1] "façile"   
> xx <- iconv(x, "latin1", "UTF-8")
> Encoding(c(x, xx))
[1] "latin1" "UTF-8" 
> c(x, xx)
[1] "façile"    "façile"   
> Encoding(xx) <- "bytes"
> xx # will be encoded in hex
[1] "fa\\xc3\\xa7ile"
> cat("xx = ", xx, "\n", sep = "")
xx = fa\xc3\xa7ile
> 
> 
> 
> cleanEx()
> nameEx("Extract")
> ### * Extract
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract
> ### Title: Extract or Replace Parts of an Object
> ### Aliases: Extract Subscript [ [.listof [.simple.list [[ $ getElement [<-
> ###   [[<- $<-
> ### Keywords: array list
> 
> ### ** Examples
> 
> x <- 1:12
> m <- matrix(1:6, nrow=2, dimnames=list(c("a", "b"), LETTERS[1:3]))
> li <- list(pi=pi, e = exp(1))
> x[10]                 # the tenth element of x
[1] 10
> x <- x[-1]            # delete the 1st element of x
> m[1,]                 # the first row of matrix m
A B C 
1 3 5 
> m[1, , drop = FALSE]  # is a 1-row matrix
  A B C
a 1 3 5
> m[,c(TRUE,FALSE,TRUE)]# logical indexing
  A C
a 1 5
b 2 6
> m[cbind(c(1,2,1),3:1)]# matrix numeric index
[1] 5 4 1
> ci <- cbind(c("a", "b", "a"), c("A", "C", "B"))
> m[ci]                 # matrix character index
[1] 1 6 3
> m <- m[,-1]           # delete the first column of m
> li[[1]]               # the first element of list li
[1] 3.141593
> y <- list(1,2,a=4,5)
> y[c(3,4)]             # a list containing elements 3 and 4 of y
$a
[1] 4

[[2]]
[1] 5

> y$a                   # the element of y named a
[1] 4
> 
> ## non-integer indices are truncated:
> (i <- 3.999999999) # "4" is printed
[1] 4
> (1:5)[i]  # 3
[1] 3
> 
> ## named atomic vectors, compare "[" and "[[" :
> nx <- c(Abc = 123, pi = pi)
> nx[1] ; nx["pi"] # keeps names, whereas "[[" does not:
Abc 
123 
      pi 
3.141593 
> nx[[1]] ; nx[["pi"]]
[1] 123
[1] 3.141593
> ## Don't show: 
> stopifnot(identical(names(nx[1]), "Abc"),
+         identical(names(nx["pi"]), "pi"),
+         is.null(names(nx[["Abc"]])), is.null(names(nx[[2]])))
> ## End Don't show
> ## recursive indexing into lists
> z <- list( a=list( b=9, c='hello'), d=1:5)
> unlist(z)
    a.b     a.c      d1      d2      d3      d4      d5 
    "9" "hello"     "1"     "2"     "3"     "4"     "5" 
> z[[c(1, 2)]]
[1] "hello"
> z[[c(1, 2, 1)]]  # both "hello"
[1] "hello"
> z[[c("a", "b")]] <- "new"
> unlist(z)
    a.b     a.c      d1      d2      d3      d4      d5 
  "new" "hello"     "1"     "2"     "3"     "4"     "5" 
> 
> ## check $ and [[ for environments
> e1 <- new.env()
> e1$a <- 10
> e1[["a"]]
[1] 10
> e1[["b"]] <- 20
> e1$b
[1] 20
> ls(e1)
[1] "a" "b"
> 
> 
> 
> cleanEx()
> nameEx("Extract.data.frame")
> ### * Extract.data.frame
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.data.frame
> ### Title: Extract or Replace Parts of a Data Frame
> ### Aliases: [.data.frame [[.data.frame [<-.data.frame [[<-.data.frame
> ###   $<-.data.frame
> ### Keywords: array
> 
> ### ** Examples
> 
> sw <- swiss[1:5, 1:4]  # select a manageable subset
> 
> sw[1:3]      # select columns
             Fertility Agriculture Examination
Courtelary        80.2        17.0          15
Delemont          83.1        45.1           6
Franches-Mnt      92.5        39.7           5
Moutier           85.8        36.5          12
Neuveville        76.9        43.5          17
> sw[, 1:3]    # same
             Fertility Agriculture Examination
Courtelary        80.2        17.0          15
Delemont          83.1        45.1           6
Franches-Mnt      92.5        39.7           5
Moutier           85.8        36.5          12
Neuveville        76.9        43.5          17
> sw[4:5, 1:3] # select rows and columns
           Fertility Agriculture Examination
Moutier         85.8        36.5          12
Neuveville      76.9        43.5          17
> sw[1]        # a one-column data frame
             Fertility
Courtelary        80.2
Delemont          83.1
Franches-Mnt      92.5
Moutier           85.8
Neuveville        76.9
> sw[, 1, drop = FALSE]  # the same
             Fertility
Courtelary        80.2
Delemont          83.1
Franches-Mnt      92.5
Moutier           85.8
Neuveville        76.9
> sw[, 1]      # a (unnamed) vector
[1] 80.2 83.1 92.5 85.8 76.9
> sw[[1]]      # the same
[1] 80.2 83.1 92.5 85.8 76.9
> 
> sw[1,]       # a one-row data frame
           Fertility Agriculture Examination Education
Courtelary      80.2          17          15        12
> sw[1,, drop=TRUE]  # a list
$Fertility
[1] 80.2

$Agriculture
[1] 17

$Examination
[1] 15

$Education
[1] 12

> 
> sw["C", ] # partially matches
           Fertility Agriculture Examination Education
Courtelary      80.2          17          15        12
> sw[match("C", row.names(sw)), ] # no exact match
   Fertility Agriculture Examination Education
NA        NA          NA          NA        NA
> try(sw[, "Ferti"]) # column names must match exactly
Error in `[.data.frame`(sw, , "Ferti") : undefined columns selected
> 
> ## Don't show: 
> stopifnot(identical(sw[,1], sw[[1]]),
+           identical(sw[,1][1], 80.2),
+           identical(sw[,1, drop = FALSE], sw[1]),
+           is.data.frame(sw[1]), dim(sw[1] ) == c(5,1),
+           is.data.frame(sw[1,]),dim(sw[1,]) == c(1,4),
+           is.list(s1 <- sw[1,, drop=TRUE]), identical(s1$Fertility, 80.2))
> ## End Don't show
> swiss[ c(1, 1:2), ]   # duplicate row, unique row names are created
             Fertility Agriculture Examination Education Catholic
Courtelary        80.2        17.0          15        12     9.96
Courtelary.1      80.2        17.0          15        12     9.96
Delemont          83.1        45.1           6         9    84.84
             Infant.Mortality
Courtelary               22.2
Courtelary.1             22.2
Delemont                 22.2
> 
> sw[sw <= 6] <- 6  # logical matrix indexing
> sw
             Fertility Agriculture Examination Education
Courtelary        80.2        17.0          15        12
Delemont          83.1        45.1           6         9
Franches-Mnt      92.5        39.7           6         6
Moutier           85.8        36.5          12         7
Neuveville        76.9        43.5          17        15
> 
> ## adding a column
> sw["new1"] <- LETTERS[1:5]   # adds a character column
> sw[["new2"]] <- letters[1:5] # ditto
> sw[, "new3"] <- LETTERS[1:5] # ditto
> sw$new4 <- 1:5
> sapply(sw, class)
  Fertility Agriculture Examination   Education        new1        new2 
  "numeric"   "numeric"   "numeric"   "numeric" "character" "character" 
       new3        new4 
"character"   "integer" 
> sw$new4 <- NULL              # delete the column
> sw
             Fertility Agriculture Examination Education new1 new2 new3
Courtelary        80.2        17.0          15        12    A    a    A
Delemont          83.1        45.1           6         9    B    b    B
Franches-Mnt      92.5        39.7           6         6    C    c    C
Moutier           85.8        36.5          12         7    D    d    D
Neuveville        76.9        43.5          17        15    E    e    E
> sw[6:8] <- list(letters[10:14], NULL, aa=1:5)
> # update col. 6, delete 7, append
> sw
             Fertility Agriculture Examination Education new1 new2 aa
Courtelary        80.2        17.0          15        12    A    j  1
Delemont          83.1        45.1           6         9    B    k  2
Franches-Mnt      92.5        39.7           6         6    C    l  3
Moutier           85.8        36.5          12         7    D    m  4
Neuveville        76.9        43.5          17        15    E    n  5
> 
> ## matrices in a data frame
> A <- data.frame(x=1:3, y=I(matrix(4:6)), z=I(matrix(letters[1:9],3,3)))
> A[1:3, "y"] # a matrix
     [,1]
[1,]    4
[2,]    5
[3,]    6
> A[1:3, "z"] # a matrix
     [,1] [,2] [,3]
[1,] "a"  "d"  "g" 
[2,] "b"  "e"  "h" 
[3,] "c"  "f"  "i" 
> A[, "y"]    # a matrix
     [,1]
[1,]    4
[2,]    5
[3,]    6
> 
> ## keeping special attributes: use a class with a
> ## "as.data.frame" and "[" method:
> as.data.frame.avector <- as.data.frame.vector
> 
> `[.avector` <- function(x,i,...) {
+   r <- NextMethod("[")
+   mostattributes(r) <- attributes(x)
+   r
+ }
> 
> d <- data.frame(i= 0:7, f= gl(2,4),
+                 u= structure(11:18, unit = "kg", class="avector"))
> str(d[2:4, -1]) # 'u' keeps its "unit"
'data.frame':	3 obs. of  2 variables:
 $ f: Factor w/ 2 levels "1","2": 1 1 1
 $ u:Class 'avector'  atomic [1:3] 12 13 14
  .. ..- attr(*, "unit")= chr "kg"
> ## Don't show: 
> stopifnot(identical(d[2:4,-1][,"u"],
+        structure(12:14, unit = "kg", class = "avector")))
> ## End Don't show
> 
> 
> 
> cleanEx()
> nameEx("Extract.factor")
> ### * Extract.factor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.factor
> ### Title: Extract or Replace Parts of a Factor
> ### Aliases: [.factor [<-.factor [[.factor [[<-.factor
> ### Keywords: category
> 
> ### ** Examples
> 
> ## following example(factor)
> (ff <- factor(substring("statistics", 1:10, 1:10), levels=letters))
 [1] s t a t i s t i c s
Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z
> ff[, drop=TRUE]
 [1] s t a t i s t i c s
Levels: a c i s t
> factor(letters[7:10])[2:3, drop = TRUE]
[1] h i
Levels: h i
> 
> 
> 
> cleanEx()
> nameEx("Extremes")
> ### * Extremes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extremes
> ### Title: Maxima and Minima
> ### Aliases: max min pmax pmin pmax.int pmin.int
> ### Keywords: univar arith
> 
> ### ** Examples
> 
> require(stats); require(graphics)
>  min(5:1, pi) #-> one number
[1] 1
> pmin(5:1, pi) #->  5  numbers
[1] 3.141593 3.141593 3.000000 2.000000 1.000000
> 
> x <- sort(rnorm(100));  cH <- 1.35
> pmin(cH, quantile(x)) # no names
[1] -2.2146999 -0.4942425  0.1139092  0.6915454  1.3500000
> pmin(quantile(x), cH) # has names
        0%        25%        50%        75%       100% 
-2.2146999 -0.4942425  0.1139092  0.6915454  1.3500000 
> plot(x, pmin(cH, pmax(-cH, x)), type='b', main= "Huber's function")
> 
> cut01 <- function(x) pmax(pmin(x, 1), 0)
> curve(      x^2 - 1/4, -1.4, 1.5, col=2)
> curve(cut01(x^2 - 1/4), col="blue", add=TRUE, n=500)
> ## pmax(), pmin() preserve attributes of *first* argument
> D <- diag(x=(3:1)/4) ; n0 <- numeric()
> stopifnot(identical(D,  cut01(D) ),
+           identical(n0, cut01(n0)),
+           identical(n0, cut01(NULL)),
+           identical(n0, pmax(3:1, n0, 2)),
+           identical(n0, pmax(n0, 4)))
> 
> 
> 
> cleanEx()
> nameEx("Last.value")
> ### * Last.value
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Last.value
> ### Title: Value of Last Evaluated Expression
> ### Aliases: .Last.value
> ### Keywords: programming
> 
> ### ** Examples
> 
> ## These will not work correctly from example(),
> ## but they will in make check or if pasted in,
> ## as example() does not run them at the top level
> gamma(1:15)          # think of some intensive calculation...
 [1]           1           1           2           6          24         120
 [7]         720        5040       40320      362880     3628800    39916800
[13]   479001600  6227020800 87178291200
> fac14 <- .Last.value # keep them
> 
> library("splines") # returns invisibly
> .Last.value    # shows what library(.) above returned
[1] "splines"   "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[7] "methods"   "base"     
> ## Don't show: 
> detach("package:splines")
> ## End Don't show
> 
> 
> 
> cleanEx()
> nameEx("Log")
> ### * Log
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: log
> ### Title: Logarithms and Exponentials
> ### Aliases: log logb log10 log2 log1p exp expm1
> ### Keywords: math
> 
> ### ** Examples
> 
> log(exp(3))
[1] 3
> log10(1e7)# = 7
[1] 7
> 
> x <- 10^-(1+2*1:9)
> cbind(x, log(1+x), log1p(x), exp(x)-1, expm1(x))
          x                                                    
 [1,] 1e-03 9.995003e-04 9.995003e-04 1.000500e-03 1.000500e-03
 [2,] 1e-05 9.999950e-06 9.999950e-06 1.000005e-05 1.000005e-05
 [3,] 1e-07 1.000000e-07 1.000000e-07 1.000000e-07 1.000000e-07
 [4,] 1e-09 1.000000e-09 1.000000e-09 1.000000e-09 1.000000e-09
 [5,] 1e-11 1.000000e-11 1.000000e-11 1.000000e-11 1.000000e-11
 [6,] 1e-13 9.992007e-14 1.000000e-13 9.992007e-14 1.000000e-13
 [7,] 1e-15 1.110223e-15 1.000000e-15 1.110223e-15 1.000000e-15
 [8,] 1e-17 0.000000e+00 1.000000e-17 0.000000e+00 1.000000e-17
 [9,] 1e-19 0.000000e+00 1.000000e-19 0.000000e+00 1.000000e-19
> 
> 
> 
> cleanEx()
> nameEx("Logic")
> ### * Logic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Logic
> ### Title: Logical Operators
> ### Aliases: ! & && | || xor Logic isTRUE
> ### Keywords: logic
> 
> ### ** Examples
> 
> y <- 1 + (x <- stats::rpois(50, lambda=1.5) / 4 - 1)
> x[(x > 0) & (x < 1)]    # all x values between 0 and 1
[1] 0.25
> if (any(x == 0) || any(y == 0)) "zero encountered"
[1] "zero encountered"
> 
> ## construct truth tables :
> 
> x <- c(NA, FALSE, TRUE)
> names(x) <- as.character(x)
> outer(x, x, "&")## AND table
       <NA> FALSE  TRUE
<NA>     NA FALSE    NA
FALSE FALSE FALSE FALSE
TRUE     NA FALSE  TRUE
> outer(x, x, "|")## OR  table
      <NA> FALSE TRUE
<NA>    NA    NA TRUE
FALSE   NA FALSE TRUE
TRUE  TRUE  TRUE TRUE
> 
> 
> 
> cleanEx()
> nameEx("MathFun")
> ### * MathFun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MathFun
> ### Title: Miscellaneous Mathematical Functions
> ### Aliases: abs sqrt
> ### Keywords: math
> 
> ### ** Examples
> 
> require(stats) # for spline
> require(graphics)
> xx <- -9:9
> plot(xx, sqrt(abs(xx)),  col = "red")
> lines(spline(xx, sqrt(abs(xx)), n=101), col = "pink")
> 
> 
> 
> cleanEx()
> nameEx("NA")
> ### * NA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NA
> ### Title: 'Not Available' / Missing Values
> ### Aliases: NA NA_integer_ NA_real_ NA_complex_ NA_character_ is.na
> ###   is.na.data.frame is.na<- is.na<-.default
> ### Keywords: NA logic manip
> 
> ### ** Examples
> 
> is.na(c(1, NA))        #> FALSE  TRUE
[1] FALSE  TRUE
> is.na(paste(c(1, NA))) #> FALSE FALSE
[1] FALSE FALSE
> 
> (xx <- c(0:4))
[1] 0 1 2 3 4
> is.na(xx) <- c(2, 4)
> xx                     #> 0 NA  2 NA  4
[1]  0 NA  2 NA  4
> 
> 
> 
> cleanEx()
> nameEx("NULL")
> ### * NULL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NULL
> ### Title: The Null Object
> ### Aliases: NULL as.null as.null.default is.null
> ### Keywords: attribute manip list sysdata
> 
> ### ** Examples
> 
> is.null(list())    # FALSE (on purpose!)
[1] FALSE
> is.null(integer(0))# F
[1] FALSE
> is.null(logical(0))# F
[1] FALSE
> as.null(list(a=1,b='c'))
NULL
> 
> 
> 
> cleanEx()
> nameEx("NumericConstants")
> ### * NumericConstants
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NumericConstants
> ### Title: Numeric Constants
> ### Aliases: NumericConstants 1L 0x1 1i
> ### Keywords: documentation
> 
> ### ** Examples
> 
> 2.1
[1] 2.1
> typeof(2)
[1] "double"
> sqrt(1i) # remember elementary math?
[1] 0.7071068+0.7071068i
> utils::str(0xA0)
 num 160
> identical(1L, as.integer(1))
[1] TRUE
> 
> ## You can combine the "0x" prefix with the "L" suffix :
> identical(0xFL, as.integer(15))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("Ops.Date")
> ### * Ops.Date
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Ops.Date
> ### Title: Operators on the Date Class
> ### Aliases: +.Date -.Date Ops.Date
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Paren")
> ### * Paren
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Paren
> ### Title: Parentheses and Braces
> ### Aliases: Paren ( {
> ### Keywords: programming
> 
> ### ** Examples
> 
> f <- get("(")
> e <- expression(3 + 2 * 4)
> identical(f(e), e)
[1] TRUE
> 
> do <- get("{")
> do(x <- 3, y <- 2*x-3, 6-x-y); x; y
[1] 0
[1] 3
[1] 3
> 
> ## note the differences
> (2+3)
[1] 5
> {2+3; 4+5}
[1] 9
> (invisible(2+3))
[1] 5
> {invisible(2+3)}
> 
> 
> 
> cleanEx()
> nameEx("Platform")
> ### * Platform
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .Platform
> ### Title: Platform Specific Variables
> ### Aliases: .Platform
> ### Keywords: file utilities
> 
> ### ** Examples
> 
> ## Note: this can be done in a system-independent way
> ## by file.info()$isdir
> if(.Platform$OS.type == "unix") {
+    system.test <- function(...) { system(paste("test", ...)) == 0 }
+    dir.exists <- function(dir)
+        sapply(dir, function(d) system.test("-d", d))
+    dir.exists(c(R.home(), "/tmp", "~", "/NO"))# > T T T F
+ }
/usr/local/R-2.15.1                /tmp                   ~                 /NO 
               TRUE                TRUE                TRUE               FALSE 
> 
> 
> 
> cleanEx()
> nameEx("Primitive")
> ### * Primitive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Primitive
> ### Title: Look Up a Primitive Function
> ### Aliases: .Primitive primitive
> ### Keywords: interface
> 
> ### ** Examples
> 
> mysqrt <- .Primitive("sqrt")
> c
function (..., recursive = FALSE)  .Primitive("c")
> .Internal # this one *must* be primitive!
function (call)  .Primitive(".Internal")
> `if` # need backticks
.Primitive("if")
> 
> 
> 
> cleanEx()
> nameEx("Random-user")
> ### * Random-user
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Random.user
> ### Title: User-supplied Random Number Generation
> ### Aliases: Random.user
> ### Keywords: distribution sysdata
> 
> ### ** Examples
> ## Not run: 
> ##D ##  Marsaglia's congruential PRNG
> ##D #include <R_ext/Random.h>
> ##D 
> ##D static Int32 seed;
> ##D static double res;
> ##D static int nseed = 1;
> ##D 
> ##D double * user_unif_rand()
> ##D {
> ##D     seed = 69069 * seed + 1;
> ##D     res = seed * 2.32830643653869e-10;
> ##D     return &res;
> ##D }
> ##D 
> ##D void  user_unif_init(Int32 seed_in) { seed = seed_in; }
> ##D int * user_unif_nseed() { return &nseed; }
> ##D int * user_unif_seedloc() { return (int *) &seed; }
> ##D 
> ##D /*  ratio-of-uniforms for normal  */
> ##D #include <math.h>
> ##D static double x;
> ##D 
> ##D double * user_norm_rand()
> ##D {
> ##D     double u, v, z;
> ##D     do {
> ##D         u = unif_rand();
> ##D         v = 0.857764 * (2. * unif_rand() - 1);
> ##D         x = v/u; z = 0.25 * x * x;
> ##D         if (z < 1. - u) break;
> ##D         if (z > 0.259/u + 0.35) continue;
> ##D     } while (z > -log(u));
> ##D     return &x;
> ##D }
> ##D 
> ##D ## Use under Unix:
> ##D R CMD SHLIB urand.c
> ##D R
> ##D > dyn.load("urand.so")
> ##D > RNGkind("user")
> ##D > runif(10)
> ##D > .Random.seed
> ##D > RNGkind(, "user")
> ##D > rnorm(10)
> ##D > RNGkind()
> ##D [1] "user-supplied" "user-supplied"
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Random")
> ### * Random
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Random
> ### Title: Random Number Generation
> ### Aliases: Random RNG RNGkind RNGversion set.seed .Random.seed
> ### Keywords: distribution sysdata
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Recall")
> ### * Recall
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Recall
> ### Title: Recursive Calling
> ### Aliases: Recall
> ### Keywords: programming
> 
> ### ** Examples
> 
> ## A trivial (but inefficient!) example:
> fib <- function(n)
+    if(n<=2) { if(n>=0) 1 else 0 } else Recall(n-1) + Recall(n-2)
> fibonacci <- fib; rm(fib)
> ## renaming wouldn't work without Recall
> fibonacci(10) # 55
[1] 55
> 
> 
> 
> cleanEx()
> nameEx("Round")
> ### * Round
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Round
> ### Title: Rounding of Numbers
> ### Aliases: ceiling floor round signif trunc
> ### Keywords: arith
> 
> ### ** Examples
> 
> round(.5 + -2:4) # IEEE rounding: -2  0  0  2  2  4  4
[1] -2  0  0  2  2  4  4
> ( x1 <- seq(-2, 4, by = .5) )
 [1] -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0
> round(x1)#-- IEEE rounding !
 [1] -2 -2 -1  0  0  0  1  2  2  2  3  4  4
> x1[trunc(x1) != floor(x1)]
[1] -1.5 -0.5
> x1[round(x1) != floor(x1 + .5)]
[1] -1.5  0.5  2.5
> (non.int <- ceiling(x1) != floor(x1))
 [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
[13] FALSE
> 
> x2 <- pi * 100^(-1:3)
> round(x2, 3)
[1]       0.031       3.142     314.159   31415.927 3141592.654
> signif(x2, 3)
[1] 3.14e-02 3.14e+00 3.14e+02 3.14e+04 3.14e+06
> 
> 
> 
> cleanEx()
> nameEx("Special")
> ### * Special
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Special
> ### Title: Special Functions of Mathematics
> ### Aliases: Special beta lbeta gamma lgamma psigamma digamma trigamma
> ###   choose lchoose factorial lfactorial
> ### Keywords: math
> 
> ### ** Examples
> 
> require(graphics)
> 
> choose(5, 2)
[1] 10
> for (n in 0:10) print(choose(n, k = 0:n))
[1] 1
[1] 1 1
[1] 1 2 1
[1] 1 3 3 1
[1] 1 4 6 4 1
[1]  1  5 10 10  5  1
[1]  1  6 15 20 15  6  1
[1]  1  7 21 35 35 21  7  1
[1]  1  8 28 56 70 56 28  8  1
 [1]   1   9  36  84 126 126  84  36   9   1
 [1]   1  10  45 120 210 252 210 120  45  10   1
> 
> factorial(100)
[1] 9.332622e+157
> lfactorial(10000)
[1] 82108.93
> 
> ## gamma has 1st order poles at 0, -1, -2, ...
> ## this will generate loss of precision warnings, so turn off
> op <- options("warn")
> options(warn = -1)
> x <- sort(c(seq(-3,4, length.out=201), outer(0:-3, (-1:1)*1e-6, "+")))
> plot(x, gamma(x), ylim=c(-20,20), col="red", type="l", lwd=2,
+      main=expression(Gamma(x)))
> abline(h=0, v=-3:0, lty=3, col="midnightblue")
> options(op)
> 
> x <- seq(.1, 4, length.out = 201); dx <- diff(x)[1]
> par(mfrow = c(2, 3))
> for (ch in c("", "l","di","tri","tetra","penta")) {
+   is.deriv <- nchar(ch) >= 2
+   nm <- paste(ch, "gamma", sep = "")
+   if (is.deriv) {
+     dy <- diff(y) / dx # finite difference
+     der <- which(ch == c("di","tri","tetra","penta")) - 1
+     nm2 <- paste("psigamma(*, deriv = ", der,")",sep='')
+     nm  <- if(der >= 2) nm2 else paste(nm, nm2, sep = " ==\n")
+     y <- psigamma(x, deriv=der)
+   } else {
+     y <- get(nm)(x)
+   }
+   plot(x, y, type = "l", main = nm, col = "red")
+   abline(h = 0, col = "lightgray")
+   if (is.deriv) lines(x[-1], dy, col = "blue", lty = 2)
+ }
> par(mfrow = c(1, 1))
> 
> ## "Extended" Pascal triangle:
> fN <- function(n) formatC(n, width=2)
> for (n in -4:10) cat(fN(n),":", fN(choose(n, k= -2:max(3,n+2))), "\n")
-4 :  0  0  1 -4 10 -20 
-3 :  0  0  1 -3  6 -10 
-2 :  0  0  1 -2  3 -4 
-1 :  0  0  1 -1  1 -1 
 0 :  0  0  1  0  0  0 
 1 :  0  0  1  1  0  0 
 2 :  0  0  1  2  1  0  0 
 3 :  0  0  1  3  3  1  0  0 
 4 :  0  0  1  4  6  4  1  0  0 
 5 :  0  0  1  5 10 10  5  1  0  0 
 6 :  0  0  1  6 15 20 15  6  1  0  0 
 7 :  0  0  1  7 21 35 35 21  7  1  0  0 
 8 :  0  0  1  8 28 56 70 56 28  8  1  0  0 
 9 :  0  0  1  9 36 84 126 126 84 36  9  1  0  0 
10 :  0  0  1 10 45 120 210 252 210 120 45 10  1  0  0 
> 
> ## R code version of choose()  [simplistic; warning for k < 0]:
> mychoose <- function(r,k)
+     ifelse(k <= 0, (k==0),
+            sapply(k, function(k) prod(r:(r-k+1))) / factorial(k))
> k <- -1:6
> cbind(k=k, choose(1/2, k), mychoose(1/2, k))
Warning in gamma(x + 1) : NaNs produced
      k                        
[1,] -1  0.00000000  0.00000000
[2,]  0  1.00000000  1.00000000
[3,]  1  0.50000000  0.50000000
[4,]  2 -0.12500000 -0.12500000
[5,]  3  0.06250000  0.06250000
[6,]  4 -0.03906250 -0.03906250
[7,]  5  0.02734375  0.02734375
[8,]  6 -0.02050781 -0.02050781
> 
> ## Binomial theorem for n=1/2 ;
> ## sqrt(1+x) = (1+x)^(1/2) = sum_{k=0}^Inf  choose(1/2, k) * x^k :
> k <- 0:10 # 10 is sufficient for ~ 9 digit precision:
> sqrt(1.25)
[1] 1.118034
> sum(choose(1/2, k)* .25^k)
[1] 1.118034
> 
> ## Don't show: 
> k. <- 1:9
> stopifnot(all.equal( (choose(1/2, k.) -> ck.),
+                     mychoose(1/2, k.)),
+           all.equal(lchoose(1/2, k.), log(abs(ck.))),
+           all.equal(sqrt(1.25),
+                     sum(choose(1/2, k)* .25^k)))
> ## End Don't show
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("Startup")
> ### * Startup
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Startup
> ### Title: Initialization at Start of an R Session
> ### Aliases: Startup Rprofile .Rprofile Rprofile.site Renviron
> ###   Renviron.site .Renviron .First .First.sys .OptRequireMethods
> ###   R_DEFAULT_PACKAGES R_ENVIRON R_ENVIRON_USER R_PROFILE R_PROFILE_USER
> ### Keywords: environment
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Example ~/.Renviron on Unix
> ##D R_LIBS=~/R/library
> ##D PAGER=/usr/local/bin/less
> ##D 
> ##D ## Example .Renviron on Windows
> ##D R_LIBS=C:/R/library
> ##D MY_TCLTK="c:/Program Files/Tcl/bin"
> ##D 
> ##D ## Example of setting R_DEFAULT_PACKAGES (from R CMD check)
> ##D R_DEFAULT_PACKAGES='utils,grDevices,graphics,stats'
> ##D # this loads the packages in the order given, so they appear on
> ##D # the search path in reverse order.
> ##D 
> ##D ## Example of .Rprofile
> ##D options(width=65, digits=5)
> ##D options(show.signif.stars=FALSE)
> ##D setHook(packageEvent("grDevices", "onLoad"),
> ##D         function(...) grDevices::ps.options(horizontal=FALSE))
> ##D set.seed(1234)
> ##D .First <- function() cat("\n   Welcome to R!\n\n")
> ##D .Last <- function()  cat("\n   Goodbye!\n\n")
> ##D 
> ##D ## Example of Rprofile.site
> ##D local({
> ##D   # add MASS to the default packages, set a CRAN mirror
> ##D   old <- getOption("defaultPackages"); r <- getOption("repos")
> ##D   r["CRAN"] <- "http://my.local.cran"
> ##D   options(defaultPackages = c(old, "MASS"), repos = r)
> ##D   ## (for Unix terminal users) set the width from COLUMNS if set
> ##D   cols <- Sys.getenv("COLUMNS")
> ##D   if(nzchar(cols)) options(width = as.integer(cols))
> ##D   # interactive sessions get a fortune cookie (needs fortunes package)
> ##D   if (interactive()) 
> ##D     fortunes::fortune()
> ##D })
> ##D 
> ##D ## if .Renviron contains
> ##D FOOBAR="coo\bar"doh\ex"abc\"def'"
> ##D 
> ##D ## then we get
> ##D # > cat(Sys.getenv("FOOBAR"), "\n")
> ##D # coo\bardoh\exabc"def'
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Sys.getenv")
> ### * Sys.getenv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.getenv
> ### Title: Get Environment Variables
> ### Aliases: Sys.getenv
> ### Keywords: environment utilities
> 
> ### ** Examples
> 
> ## whether HOST is set will be shell-dependent e.g. Solaris' csh does not.
> Sys.getenv(c("R_HOME", "R_PAPERSIZE", "R_PRINTCMD", "HOST"))
               R_HOME           R_PAPERSIZE            R_PRINTCMD 
"/usr/local/R-2.15.1"                  "a4"                 "lpr" 
                 HOST 
                   "" 
> 
> names(s <- Sys.getenv()) # all settings (the values could be very long)
 [1] "BIBINPUTS"        "BSTINPUTS"        "COLORTERM"        "DISPLAY"         
 [5] "EDITOR"           "ftp_proxy"        "HOME"             "http_proxy"      
 [9] "https_proxy"      "LANG"             "LANGUAGE"         "LC_TIME"         
[13] "LD_LIBRARY_PATH"  "LN_S"             "LOGNAME"          "LS_COLORS"       
[17] "MAIL"             "MAKE"             "MAKEFLAGS"        "MAKELEVEL"       
[21] "MFLAGS"           "PAGER"            "PATH"             "PWD"             
[25] "R_ARCH"           "R_BROWSER"        "R_BZIPCMD"        "R_CMD"           
[29] "R_DOC_DIR"        "R_ENVIRON"        "R_ENVIRON_USER"   "R_GZIPCMD"       
[33] "R_HOME"           "R_INCLUDE_DIR"    "R_LIBS"           "R_LIBS_SITE"     
[37] "R_LIBS_USER"      "R_OSTYPE"         "R_PAPERSIZE"      "R_PAPERSIZE_USER"
[41] "R_PDFVIEWER"      "R_PLATFORM"       "R_PRINTCMD"       "R_PROFILE"       
[45] "R_PROFILE_USER"   "R_RD4PDF"         "R_SESSION_TMPDIR" "R_SHARE_DIR"     
[49] "R_SYSTEM_ABI"     "R_TEXI2DVICMD"    "R_UNZIPCMD"       "R_VERSION"       
[53] "R_ZIPCMD"         "SED"              "SHELL"            "SHLVL"           
[57] "socks_proxy"      "SUDO_COMMAND"     "SUDO_GID"         "SUDO_UID"        
[61] "SUDO_USER"        "TAR"              "TERM"             "TEXINPUTS"       
[65] "USER"             "USERNAME"         "XAUTHORITY"      
> 
> ## Language and Locale settings -- but rather use Sys.getlocale()
> s[grep("^L(C|ANG)", names(s))]
    LANG LANGUAGE  LC_TIME 
 "en_IN"     "en"      "C" 
> 
> 
> 
> cleanEx()
> nameEx("Sys.getpid")
> ### * Sys.getpid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.getpid
> ### Title: Get the Process ID of the R Session
> ### Aliases: Sys.getpid
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Sys.glob")
> ### * Sys.glob
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.glob
> ### Title: Wildcard Expansion on File Paths
> ### Aliases: Sys.glob
> ### Keywords: utilities file
> 
> ### ** Examples
> 
> ## Not run: 
> ##D Sys.glob(file.path(R.home(), "library", "*", "R", "*.rdx"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Sys.info")
> ### * Sys.info
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.info
> ### Title: Extract System and User Information
> ### Aliases: Sys.info
> ### Keywords: utilities
> 
> ### ** Examples
> 
> Sys.info()
                                     sysname 
                                     "Linux" 
                                     release 
                      "3.2.0-31-generic-pae" 
                                     version 
"#50-Ubuntu SMP Fri Sep 7 16:39:45 UTC 2012" 
                                    nodename 
                                      "RISH" 
                                     machine 
                                      "i686" 
                                       login 
                                   "unknown" 
                                        user 
                                      "root" 
                              effective_user 
                                      "root" 
> ## An alternative (and probably better) way to get the login name on Unix
> Sys.getenv("LOGNAME")
[1] "root"
> 
> 
> 
> cleanEx()
> nameEx("Sys.localeconv")
> ### * Sys.localeconv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.localeconv
> ### Title: Find Details of the Numerical and Monetary Representations in
> ###   the Current Locale
> ### Aliases: localeconv Sys.localeconv
> ### Keywords: utilities
> 
> ### ** Examples
> 
> Sys.localeconv()
    decimal_point     thousands_sep          grouping   int_curr_symbol 
              "."                ""                ""            "INR " 
  currency_symbol mon_decimal_point mon_thousands_sep      mon_grouping 
         "\u20b9"               "."               ","        "\003\002" 
    positive_sign     negative_sign   int_frac_digits       frac_digits 
               ""               "-"               "2"               "2" 
    p_cs_precedes    p_sep_by_space     n_cs_precedes    n_sep_by_space 
              "1"               "1"               "1"               "1" 
      p_sign_posn       n_sign_posn 
              "1"               "1" 
> ## The results in the C locale are
> ##    decimal_point     thousands_sep          grouping   int_curr_symbol 
> ##              "."                ""                ""                "" 
> ##  currency_symbol mon_decimal_point mon_thousands_sep      mon_grouping 
> ##               ""                ""                ""                "" 
> ##    positive_sign     negative_sign   int_frac_digits       frac_digits 
> ##               ""                ""             "127"             "127" 
> ##    p_cs_precedes    p_sep_by_space     n_cs_precedes    n_sep_by_space 
> ##            "127"             "127"             "127"             "127" 
> ##      p_sign_posn       n_sign_posn 
> ##            "127"             "127"
> 
> ## Now try your default locale (which might be "C").
> ## Not run: 
> ##D old <- Sys.getlocale()
> ##D ## The category may not be set:
> ##D ## the following may do so, but it might not be supported. 
> ##D Sys.setlocale("LC_MONETARY", locale = "")
> ##D Sys.localeconv()
> ##D ## or set an appropriate value yourself, e.g.
> ##D Sys.setlocale("LC_MONETARY", "de_AT")
> ##D Sys.localeconv()
> ##D Sys.setlocale(locale = old)
> ## End(Not run)
> 
> ## Not run: read.table("foo", dec=Sys.localeconv()["decimal_point"])
> 
> 
> 
> cleanEx()
> nameEx("Sys.setenv")
> ### * Sys.setenv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.setenv
> ### Title: Set or Unset Environment Variables
> ### Aliases: Sys.setenv Sys.unsetenv
> ### Keywords: environment utilities
> 
> ### ** Examples
> 
> print(Sys.setenv(R_TEST="testit", "A+C"=123))  # `A+C` could also be used
[1] TRUE TRUE
> Sys.getenv("R_TEST")
[1] "testit"
> Sys.unsetenv("R_TEST")  # may warn and not succeed
> Sys.getenv("R_TEST", unset=NA)
[1] NA
> 
> 
> 
> cleanEx()
> nameEx("Sys.sleep")
> ### * Sys.sleep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.sleep
> ### Title: Suspend Execution for a Time Interval
> ### Aliases: Sys.sleep
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Sys.time")
> ### * Sys.time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.time
> ### Title: Get Current Date and Time
> ### Aliases: Sys.time Sys.Date
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Sys.which")
> ### * Sys.which
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.which
> ### Title: Find Full Paths to Executables
> ### Aliases: Sys.which
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## the first two are likely to exist everywhere
> ## texi2dvi exists on most Unix-alikes and under MiKTeX
> Sys.which(c("ftp", "ping", "texi2dvi", "this-does-not-exist"))
                ftp                ping            texi2dvi this-does-not-exist 
     "/usr/bin/ftp"         "/bin/ping"                  ""                  "" 
> 
> 
> 
> cleanEx()
> nameEx("Vectorize")
> ### * Vectorize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Vectorize
> ### Title: Vectorize a Scalar Function
> ### Aliases: Vectorize
> ### Keywords: manip utilities
> 
> ### ** Examples
> 
> # We use rep.int as rep is primitive
> vrep <- Vectorize(rep.int)
> vrep(1:4, 4:1)
[[1]]
[1] 1 1 1 1

[[2]]
[1] 2 2 2

[[3]]
[1] 3 3

[[4]]
[1] 4

> vrep(times = 1:4, x = 4:1)
[[1]]
[1] 4

[[2]]
[1] 3 3

[[3]]
[1] 2 2 2

[[4]]
[1] 1 1 1 1

> 
> vrep <- Vectorize(rep.int, "times")
> vrep(times = 1:4, x = 42)
[[1]]
[1] 42

[[2]]
[1] 42 42

[[3]]
[1] 42 42 42

[[4]]
[1] 42 42 42 42

> 
> f <- function(x = 1:3, y) c(x,y)
> vf <- Vectorize(f, SIMPLIFY = FALSE)
> f(1:3, 1:3)
[1] 1 2 3 1 2 3
> vf(1:3, 1:3)
[[1]]
[1] 1 1

[[2]]
[1] 2 2

[[3]]
[1] 3 3

> vf(y = 1:3) # Only vectorizes y, not x
[[1]]
[1] 1 2 3 1

[[2]]
[1] 1 2 3 2

[[3]]
[1] 1 2 3 3

> 
> # Nonlinear regression contour plot, based on nls() example
> require(graphics)
> SS <- function(Vm, K, resp, conc) {
+     pred <- (Vm * conc)/(K + conc)
+     sum((resp - pred)^2 / pred)
+ }
> vSS <- Vectorize(SS, c("Vm", "K"))
> Treated <- subset(Puromycin, state == "treated")
> 
> Vm <- seq(140, 310, length.out = 50)
> K <- seq(0, 0.15, length.out = 40)
> SSvals <- outer(Vm, K, vSS, Treated$rate, Treated$conc)
> contour(Vm, K, SSvals, levels = (1:10)^2, xlab = "Vm", ylab = "K")
> 
> 
> 
> cleanEx()
> nameEx("Version")
> ### * Version
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: R.Version
> ### Title: Version Information
> ### Aliases: R.Version R.version version R.version.string
> ### Keywords: environment sysdata programming
> 
> ### ** Examples
> 
> require(graphics)
> 
> R.version$os # to check how lucky you are ...
[1] "linux-gnu"
> plot(0) # any plot
> mtext(R.version.string, side=1,line=4,adj=1)# a useful bottom-right note
> 
> 
> 
> cleanEx()
> nameEx("abbreviate")
> ### * abbreviate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: abbreviate
> ### Title: Abbreviate Strings
> ### Aliases: abbreviate
> ### Keywords: character
> 
> ### ** Examples
> 
> x <- c("abcd", "efgh", "abce")
> abbreviate(x, 2)
  abcd   efgh   abce 
"abcd"   "ef" "abce" 
> abbreviate(x, 2, strict=TRUE)# >> 1st and 3rd are == "ab"
abcd efgh abce 
"ab" "ef" "ab" 
> 
> (st.abb <- abbreviate(state.name, 2))
       Alabama         Alaska        Arizona       Arkansas     California 
         "Alb"          "Als"          "Arz"          "Ark"          "Clf" 
      Colorado    Connecticut       Delaware        Florida        Georgia 
         "Clr"           "Cn"           "Dl"           "Fl"           "Gr" 
        Hawaii          Idaho       Illinois        Indiana           Iowa 
          "Hw"           "Id"           "Il"           "In"           "Iw" 
        Kansas       Kentucky      Louisiana          Maine       Maryland 
         "Kns"          "Knt"           "Ls"          "Man"           "Mr" 
 Massachusetts       Michigan      Minnesota    Mississippi       Missouri 
        "Mssc"           "Mc"          "Mnn"         "Msss"         "Mssr" 
       Montana       Nebraska         Nevada  New Hampshire     New Jersey 
         "Mnt"           "Nb"           "Nv"           "NH"           "NJ" 
    New Mexico       New York North Carolina   North Dakota           Ohio 
          "NM"           "NY"           "NC"           "ND"           "Oh" 
      Oklahoma         Oregon   Pennsylvania   Rhode Island South Carolina 
          "Ok"           "Or"           "Pn"           "RI"           "SC" 
  South Dakota      Tennessee          Texas           Utah        Vermont 
          "SD"           "Tn"           "Tx"           "Ut"          "Vrm" 
      Virginia     Washington  West Virginia      Wisconsin        Wyoming 
         "Vrg"          "Wsh"           "WV"          "Wsc"           "Wy" 
> table(nchar(st.abb))# out of 50, 3 need 4 letters :

 2  3  4 
32 15  3 
> as <- abbreviate(state.name, 3, strict=TRUE)
> as[which(as == "Mss")]
Massachusetts   Mississippi      Missouri 
        "Mss"         "Mss"         "Mss" 
> ## Don't show: 
> stopifnot(which(as == "Mss") == c(21,24,25))
> ## End Don't show
> ## method="both.sides" helps:  no 4-letters, and only 4 3-letters:
> st.ab2 <- abbreviate(state.name, 2, method="both")
> table(nchar(st.ab2))

 2  3 
46  4 
> ## Compare the two methods:
> cbind(st.abb, st.ab2)
               st.abb st.ab2
Alabama        "Alb"  "Al"  
Alaska         "Als"  "Aa"  
Arizona        "Arz"  "Ar"  
Arkansas       "Ark"  "As"  
California     "Clf"  "Cl"  
Colorado       "Clr"  "Co"  
Connecticut    "Cn"   "Cn"  
Delaware       "Dl"   "Dl"  
Florida        "Fl"   "Fl"  
Georgia        "Gr"   "Gr"  
Hawaii         "Hw"   "Hw"  
Idaho          "Id"   "Id"  
Illinois       "Il"   "Il"  
Indiana        "In"   "In"  
Iowa           "Iw"   "Iw"  
Kansas         "Kns"  "Kn"  
Kentucky       "Knt"  "Ky"  
Louisiana      "Ls"   "Ls"  
Maine          "Man"  "Mn"  
Maryland       "Mr"   "Mr"  
Massachusetts  "Mssc" "Ms"  
Michigan       "Mc"   "Mc"  
Minnesota      "Mnn"  "Mnn" 
Mississippi    "Msss" "Mss" 
Missouri       "Mssr" "Mri" 
Montana        "Mnt"  "Mnt" 
Nebraska       "Nb"   "Nb"  
Nevada         "Nv"   "Nv"  
New Hampshire  "NH"   "NH"  
New Jersey     "NJ"   "NJ"  
New Mexico     "NM"   "NM"  
New York       "NY"   "NY"  
North Carolina "NC"   "NC"  
North Dakota   "ND"   "ND"  
Ohio           "Oh"   "Oh"  
Oklahoma       "Ok"   "Ok"  
Oregon         "Or"   "Or"  
Pennsylvania   "Pn"   "Pn"  
Rhode Island   "RI"   "RI"  
South Carolina "SC"   "SC"  
South Dakota   "SD"   "SD"  
Tennessee      "Tn"   "Tn"  
Texas          "Tx"   "Tx"  
Utah           "Ut"   "Ut"  
Vermont        "Vrm"  "Vr"  
Virginia       "Vrg"  "Va"  
Washington     "Wsh"  "Ws"  
West Virginia  "WV"   "WV"  
Wisconsin      "Wsc"  "Wn"  
Wyoming        "Wy"   "Wy"  
> 
> 
> 
> cleanEx()
> nameEx("agrep")
> ### * agrep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: agrep
> ### Title: Approximate String Matching (Fuzzy Matching)
> ### Aliases: agrep 'fuzzy matching' .amatch_bounds .amatch_costs
> ### Keywords: character
> 
> ### ** Examples
> 
> agrep("lasy", "1 lazy 2")
[1] 1
> agrep("lasy", c(" 1 lazy 2", "1 lasy 2"), max = list(sub = 0))
[1] 2
> agrep("laysy", c("1 lazy", "1", "1 LAZY"), max = 2)
[1] 1
> agrep("laysy", c("1 lazy", "1", "1 LAZY"), max = 2, value = TRUE)
[1] "1 lazy"
> agrep("laysy", c("1 lazy", "1", "1 LAZY"), max = 2, ignore.case = TRUE)
[1] 1 3
> 
> 
> 
> cleanEx()
> nameEx("all")
> ### * all
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all
> ### Title: Are All Values True?
> ### Aliases: all
> ### Keywords: logic
> 
> ### ** Examples
> 
> range(x <- sort(round(stats::rnorm(10) - 1.2, 1)))
[1] -2.0  0.4
> if(all(x < 0)) cat("all x values are negative\n")
> 
> all(logical(0))  # true, as all zero of the elements are true.
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("all.equal")
> ### * all.equal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all.equal
> ### Title: Test if Two Objects are (Nearly) Equal
> ### Aliases: all.equal all.equal.default all.equal.numeric
> ###   all.equal.character all.equal.factor all.equal.formula all.equal.list
> ###   all.equal.language all.equal.raw attr.all.equal
> ### Keywords: programming utilities logic arith
> 
> ### ** Examples
> 
> all.equal(pi, 355/113)
[1] "Mean relative difference: 8.491368e-08"
> # not precise enough (default tol) > relative error
> 
> d45 <- pi*(1/4 + 1:10)
> stopifnot(
+ all.equal(tan(d45), rep(1,10)))        # TRUE, but
> all      (tan(d45) == rep(1,10))       # FALSE, since not exactly
[1] FALSE
> all.equal(tan(d45), rep(1,10), tol=0)  # to see difference
[1] "Mean relative difference: 1.29526e-15"
> 
> 
> 
> cleanEx()
> nameEx("allnames")
> ### * allnames
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all.names
> ### Title: Find All Names in an Expression
> ### Aliases: all.names all.vars
> ### Keywords: programming
> 
> ### ** Examples
> 
> all.names(expression(sin(x+y)))
[1] "sin" "+"   "x"   "y"  
> all.names(quote(sin(x+y))) # or a call
[1] "sin" "+"   "x"   "y"  
> all.vars(expression(sin(x+y)))
[1] "x" "y"
> 
> 
> 
> cleanEx()
> nameEx("any")
> ### * any
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: any
> ### Title: Are Some Values True?
> ### Aliases: any
> ### Keywords: logic
> 
> ### ** Examples
> 
> range(x <- sort(round(stats::rnorm(10) - 1.2,1)))
[1] -2.0  0.4
> if(any(x < 0)) cat("x contains negative values\n")
x contains negative values
> 
> 
> 
> cleanEx()
> nameEx("aperm")
> ### * aperm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aperm
> ### Title: Array Transposition
> ### Aliases: aperm aperm.default aperm.table
> ### Keywords: array
> 
> ### ** Examples
> 
> # interchange the first two subscripts on a 3-way array x
> x  <- array(1:24, 2:4)
> xt <- aperm(x, c(2,1,3))
> stopifnot(t(xt[,,2]) == x[,,2],
+           t(xt[,,3]) == x[,,3],
+           t(xt[,,4]) == x[,,4])
> 
> UCB <- aperm(UCBAdmissions, c(2,1,3))
> UCB[1,,]
          Dept
Admit        A   B   C   D   E   F
  Admitted 512 353 120 138  53  22
  Rejected 313 207 205 279 138 351
> summary(UCB)# UCB is still a continency table
Number of cases in table: 4526 
Number of factors: 3 
Test for independence of all factors:
	Chisq = 2000.3, df = 16, p-value = 0
> ## Don't show: 
> stopifnot(is.table(UCB))
> ## End Don't show
> 
> 
> 
> cleanEx()
> nameEx("append")
> ### * append
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: append
> ### Title: Vector Merging
> ### Aliases: append
> ### Keywords: manip
> 
> ### ** Examples
> 
> append(1:5, 0:1, after=3)
[1] 1 2 3 0 1 4 5
> 
> 
> 
> cleanEx()
> nameEx("apply")
> ### * apply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: apply
> ### Title: Apply Functions Over Array Margins
> ### Aliases: apply
> ### Keywords: iteration array
> 
> ### ** Examples
> 
> ## Compute row and column sums for a matrix:
> x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
> dimnames(x)[[1]] <- letters[1:8]
> apply(x, 2, mean, trim = .2)
x1 x2 
 3  3 
> col.sums <- apply(x, 2, sum)
> row.sums <- apply(x, 1, sum)
> rbind(cbind(x, Rtot = row.sums), Ctot = c(col.sums, sum(col.sums)))
     x1 x2 Rtot
a     3  4    7
b     3  3    6
c     3  2    5
d     3  1    4
e     3  2    5
f     3  3    6
g     3  4    7
h     3  5    8
Ctot 24 24   48
> 
> stopifnot( apply(x, 2, is.vector))
> 
> ## Sort the columns of a matrix
> apply(x, 2, sort)
     x1 x2
[1,]  3  1
[2,]  3  2
[3,]  3  2
[4,]  3  3
[5,]  3  3
[6,]  3  4
[7,]  3  4
[8,]  3  5
> 
> ##- function with extra args:
> cave <- function(x, c1, c2) c(mean(x[c1]), mean(x[c2]))
> apply(x,1, cave,  c1="x1", c2=c("x1","x2"))
       a b   c d   e f   g h
[1,] 3.0 3 3.0 3 3.0 3 3.0 3
[2,] 3.5 3 2.5 2 2.5 3 3.5 4
> 
> ma <- matrix(c(1:4, 1, 6:8), nrow = 2)
> ma
     [,1] [,2] [,3] [,4]
[1,]    1    3    1    7
[2,]    2    4    6    8
> apply(ma, 1, table)  #--> a list of length 2
[[1]]

1 3 7 
2 1 1 

[[2]]

2 4 6 8 
1 1 1 1 

> apply(ma, 1, stats::quantile)# 5 x n matrix with rownames
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
> 
> stopifnot(dim(ma) == dim(apply(ma, 1:2, sum)))
> 
> ## Example with different lengths for each call
> z <- array(1:24, dim=2:4)
> zseq <- apply(z, 1:2, function(x) seq_len(max(x)))
> zseq         ## a 2 x 3 matrix
     [,1]       [,2]       [,3]      
[1,] Integer,19 Integer,21 Integer,23
[2,] Integer,20 Integer,22 Integer,24
> typeof(zseq) ## list
[1] "list"
> dim(zseq) ## 2 3
[1] 2 3
> zseq[1,]
[[1]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19

[[2]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21

[[3]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23

> apply(z, 3, function(x) seq_len(max(x)))
[[1]]
[1] 1 2 3 4 5 6

[[2]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12

[[3]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18

[[4]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24

> # a list without a dim attribute
> 
> 
> 
> cleanEx()
> nameEx("args")
> ### * args
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: args
> ### Title: Argument List of a Function
> ### Aliases: args
> ### Keywords: documentation
> 
> ### ** Examples
> 
> args(c)
function (..., recursive = FALSE) 
NULL
> args(graphics::plot.default)
function (x, y = NULL, type = "p", xlim = NULL, ylim = NULL, 
    log = "", main = NULL, sub = NULL, xlab = NULL, ylab = NULL, 
    ann = par("ann"), axes = TRUE, frame.plot = axes, panel.first = NULL, 
    panel.last = NULL, asp = NA, ...) 
NULL
> 
> 
> 
> cleanEx()
> nameEx("array")
> ### * array
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: array
> ### Title: Multi-way Arrays
> ### Aliases: array as.array as.array.default is.array
> ### Keywords: array
> 
> ### ** Examples
> 
> dim(as.array(letters))
[1] 26
> array(1:3, c(2,4)) # recycle 1:3 "2 2/3 times"
     [,1] [,2] [,3] [,4]
[1,]    1    3    2    1
[2,]    2    1    3    2
> #     [,1] [,2] [,3] [,4]
> #[1,]    1    3    2    1
> #[2,]    2    1    3    2
> 
> 
> 
> cleanEx()
> nameEx("as.Date")
> ### * as.Date
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.Date
> ### Title: Date Conversion Functions to and from Character
> ### Aliases: format.Date as.character.Date as.Date as.Date.character
> ###   as.Date.default as.Date.factor as.Date.POSIXct as.Date.POSIXlt
> ###   as.Date.date as.Date.dates as.Date.numeric
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> ## read in date info in format 'ddmmmyyyy'
> ## This will give NA(s) in some locales; setting the C locale
> ## as in the commented lines will overcome this on most systems.
> ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
> x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")
> z <- as.Date(x, "%d%b%Y")
> ## Sys.setlocale("LC_TIME", lct)
> z
[1] "1960-01-01" "1960-01-02" "1960-03-31" "1960-07-30"
> 
> ## read in date/time info in format 'm/d/y'
> dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")
> as.Date(dates, "%m/%d/%y")
[1] "1992-02-27" "1992-02-27" "1992-01-14" "1992-02-28" "1992-02-01"
> 
> ## date given as number of days since 1900-01-01 (a date in 1989)
> as.Date(32768, origin="1900-01-01")
[1] "1989-09-19"
> ## Excel is said to use 1900-01-01 as day 1 (Windows default) or
> ## 1904-01-01 as day 0 (Mac default), but this is complicated by Excel
> ## treating 1900 as a leap year.
> ## So for dates (post-1901) from Windows Excel
> as.Date(35981, origin="1899-12-30") # 1998-07-05
[1] "1998-07-05"
> ## and Mac Excel
> as.Date(34519, origin="1904-01-01") # 1998-07-05
[1] "1998-07-05"
> ## (these values come from http://support.microsoft.com/kb/214330)
> 
> ## Experiment shows that Matlab's origin is 719529 days before ours,
> ## so Matlab day 734373 can be imported as
> as.Date(734373, origin = "1970-01-01") - 719529
[1] "2010-08-23"
> ## (value from http://www.mathworks.com/help/techdoc/matlab_prog/bspgcx2-1.html)
> 
> ## Timezone effect
> z <- ISOdate(2010, 04, 13, c(0,12)) # midnight and midday UTC
> as.Date(z) # in UTC
[1] "2010-04-13" "2010-04-13"
> 
> 
> 
> cleanEx()
> nameEx("as.POSIXlt")
> ### * as.POSIXlt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.POSIX*
> ### Title: Date-time Conversion Functions
> ### Aliases: as.POSIXct as.POSIXct.default as.POSIXct.POSIXlt
> ###   as.POSIXct.date as.POSIXct.dates as.POSIXct.Date as.POSIXct.numeric
> ###   as.POSIXlt as.POSIXlt.Date as.POSIXlt.date as.POSIXlt.dates
> ###   as.POSIXlt.POSIXct as.POSIXlt.factor as.POSIXlt.character
> ###   as.POSIXlt.default as.POSIXlt.numeric as.double.POSIXlt
> ### Keywords: utilities chron
> 
> ### ** Examples
> ## Not run: 
> ##D ## These may not be correct names on your system
> ##D as.POSIXlt(Sys.time(), "America/New_York")  # in New York
> ##D as.POSIXlt(Sys.time(), "EST5EDT")           # alternative.
> ##D as.POSIXlt(Sys.time(), "EST" )   # somewhere in Eastern Canada
> ##D as.POSIXlt(Sys.time(), "HST")    # in Hawaii
> ##D as.POSIXlt(Sys.time(), "Australia/Darwin")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("as.environment")
> ### * as.environment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.environment
> ### Title: Coerce to an Environment Object
> ### Aliases: as.environment
> ### Keywords: data environment
> 
> ### ** Examples
> 
> as.environment(1) ## the global environment
<environment: R_GlobalEnv>
> identical(globalenv(), as.environment(1)) ## is TRUE
[1] TRUE
> try( ## <<- stats need not be attached
+     as.environment("package:stats"))
<environment: package:stats>
attr(,"name")
[1] "package:stats"
attr(,"path")
[1] "/usr/local/R-2.15.1/library/stats"
> ee <- as.environment(list(a = "A", b = pi, ch = letters[1:8]))
> ls(ee) # names of objects in ee
[1] "a"  "b"  "ch"
> utils::ls.str(ee)
a :  chr "A"
b :  num 3.14
ch :  chr [1:8] "a" "b" "c" "d" "e" "f" "g" "h"
> 
> 
> 
> cleanEx()
> nameEx("as.function")
> ### * as.function
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.function
> ### Title: Convert Object to Function
> ### Aliases: as.function as.function.default
> ### Keywords: programming
> 
> ### ** Examples
> 
> as.function(alist(a=,b=2,a+b))
function (a, b = 2) 
a + b
> as.function(alist(a=,b=2,a+b))(3)
[1] 5
> 
> 
> 
> cleanEx()
> nameEx("assign")
> ### * assign
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: assign
> ### Title: Assign a Value to a Name
> ### Aliases: assign
> ### Keywords: data
> 
> ### ** Examples
> 
> for(i in 1:6) { #-- Create objects  'r.1', 'r.2', ... 'r.6' --
+  nam <- paste("r",i, sep=".")
+  assign(nam, 1:i)
+ }
> ls(pattern = "^r..$")
[1] "r.1" "r.2" "r.3" "r.4" "r.5" "r.6"
> 
> ##-- Global assignment within a function:
> myf <- function(x) {
+  innerf <- function(x) assign("Global.res", x^2, envir = .GlobalEnv)
+  innerf(x+1)
+ }
> myf(3)
> Global.res # 16
[1] 16
> 
> a <- 1:4
> assign("a[1]", 2)
> a[1] == 2          #FALSE
[1] FALSE
> get("a[1]") == 2   #TRUE
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("attach")
> ### * attach
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: attach
> ### Title: Attach Set of R Objects to Search Path
> ### Aliases: attach .conflicts.OK
> ### Keywords: data
> 
> ### ** Examples
> 
> require(utils)
> 
> summary(women$height)   # refers to variable 'height' in the data frame
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   58.0    61.5    65.0    65.0    68.5    72.0 
> attach(women)
> summary(height)         # The same variable now available by name
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   58.0    61.5    65.0    65.0    68.5    72.0 
> height <- height*2.54   # Don't do this. It creates a new variable
>                         # in the user's workspace
> find("height")
[1] ".GlobalEnv" "women"     
> summary(height)         # The new variable in the workspace
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  147.3   156.2   165.1   165.1   174.0   182.9 
> rm(height)
> summary(height)         # The original variable.
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   58.0    61.5    65.0    65.0    68.5    72.0 
> height <<- height*25.4  # Change the copy in the attached environment
> find("height")
[1] "women"
> summary(height)         # The changed copy
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   1473    1562    1651    1651    1740    1829 
> detach("women")
> summary(women$height)   # unchanged
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   58.0    61.5    65.0    65.0    68.5    72.0 
> 
> ## Not run: 
> ##D ## create an environment on the search path and populate it
> ##D sys.source("myfuns.R", envir=attach(NULL, name="myfuns"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("attr")
> ### * attr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: attr
> ### Title: Object Attributes
> ### Aliases: attr attr<-
> ### Keywords: attribute
> 
> ### ** Examples
> 
> # create a 2 by 5 matrix
> x <- 1:10
> attr(x,"dim") <- c(2, 5)
> 
> 
> 
> cleanEx()
> nameEx("attributes")
> ### * attributes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: attributes
> ### Title: Object Attribute Lists
> ### Aliases: attributes attributes<- mostattributes<-
> ### Keywords: attribute
> 
> ### ** Examples
> 
> x <- cbind(a=1:3, pi=pi) # simple matrix w/ dimnames
> attributes(x)
$dim
[1] 3 2

$dimnames
$dimnames[[1]]
NULL

$dimnames[[2]]
[1] "a"  "pi"


> 
> ## strip an object's attributes:
> attributes(x) <- NULL
> x # now just a vector of length 6
[1] 1.000000 2.000000 3.000000 3.141593 3.141593 3.141593
> 
> mostattributes(x) <- list(mycomment = "really special", dim = 3:2,
+    dimnames = list(LETTERS[1:3], letters[1:5]), names = paste(1:6))
> x # dim(), but not {dim}names
     [,1]     [,2]
[1,]    1 3.141593
[2,]    2 3.141593
[3,]    3 3.141593
attr(,"mycomment")
[1] "really special"
> 
> 
> 
> cleanEx()
> nameEx("autoload")
> ### * autoload
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoload
> ### Title: On-demand Loading of Packages
> ### Aliases: autoload autoloader .AutoloadEnv .Autoloaded Autoloads
> ### Keywords: data programming
> 
> ### ** Examples
> 
> require(stats)
> autoload("interpSpline", "splines")
> search()
 [1] ".GlobalEnv"        "CheckExEnv"        "package:stats"    
 [4] "package:graphics"  "package:grDevices" "package:utils"    
 [7] "package:datasets"  "package:methods"   "Autoloads"        
[10] "package:base"     
> ls("Autoloads")
[1] "interpSpline"
> .Autoloaded
[1] "splines"
> 
> x <- sort(stats::rnorm(12))
> y <- x^2
> is <- interpSpline(x,y)
> search() ## now has splines
 [1] ".GlobalEnv"        "package:splines"   "CheckExEnv"       
 [4] "package:stats"     "package:graphics"  "package:grDevices"
 [7] "package:utils"     "package:datasets"  "package:methods"  
[10] "Autoloads"         "package:base"     
> detach("package:splines")
> search()
 [1] ".GlobalEnv"        "CheckExEnv"        "package:stats"    
 [4] "package:graphics"  "package:grDevices" "package:utils"    
 [7] "package:datasets"  "package:methods"   "Autoloads"        
[10] "package:base"     
> is2 <- interpSpline(x,y+x)
> search() ## and again
 [1] ".GlobalEnv"        "package:splines"   "CheckExEnv"       
 [4] "package:stats"     "package:graphics"  "package:grDevices"
 [7] "package:utils"     "package:datasets"  "package:methods"  
[10] "Autoloads"         "package:base"     
> detach("package:splines")
> 
> 
> 
> cleanEx()
> nameEx("backsolve")
> ### * backsolve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backsolve
> ### Title: Solve an Upper or Lower Triangular System
> ### Aliases: backsolve forwardsolve
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> ## upper triangular matrix 'r':
> r <- rbind(c(1,2,3),
+            c(0,1,1),
+            c(0,0,2))
> ( y <- backsolve(r, x <- c(8,4,2)) ) # -1 3 1
[1] -1  3  1
> r %*% y # == x = (8,4,2)
     [,1]
[1,]    8
[2,]    4
[3,]    2
> backsolve(r, x, transpose = TRUE) # 8 -12 -5
[1]   8 -12  -5
> 
> 
> 
> cleanEx()
> nameEx("basename")
> ### * basename
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: basename
> ### Title: Manipulate File Paths
> ### Aliases: basename dirname
> ### Keywords: file
> 
> ### ** Examples
> 
> basename(file.path("","p1","p2","p3", c("file1", "file2")))
[1] "file1" "file2"
> dirname(file.path("","p1","p2","p3","filename"))
[1] "/p1/p2/p3"
> 
> 
> 
> cleanEx()
> nameEx("bindenv")
> ### * bindenv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bindenv
> ### Title: Binding and Environment Adjustments
> ### Aliases: bindenv lockEnvironment environmentIsLocked lockBinding
> ###   unlockBinding makeActiveBinding bindingIsLocked bindingIsActive
> ### Keywords: utilities
> 
> ### ** Examples
> 
> # locking environments
> e <- new.env()
> assign("x", 1, envir = e)
> get("x", envir = e)
[1] 1
> lockEnvironment(e)
> get("x", envir = e)
[1] 1
> assign("x", 2, envir = e)
> try(assign("y", 2, envir = e)) # error
Error in assign("y", 2, envir = e) : 
  cannot add bindings to a locked environment
> 
> # locking bindings
> e <- new.env()
> assign("x", 1, envir = e)
> get("x", envir = e)
[1] 1
> lockBinding("x", e)
> try(assign("x", 2, envir = e)) # error
Error in assign("x", 2, envir = e) : 
  cannot change value of locked binding for 'x'
> unlockBinding("x", e)
> assign("x", 2, envir = e)
> get("x", envir = e)
[1] 2
> 
> # active bindings
> f <- local( {
+     x <- 1
+     function(v) {
+        if (missing(v))
+            cat("get\n")
+        else {
+            cat("set\n")
+            x <<- v
+        }
+        x
+     }
+ })
> makeActiveBinding("fred", f, .GlobalEnv)
> bindingIsActive("fred", .GlobalEnv)
[1] TRUE
> fred
get
[1] 1
> fred <- 2
set
> fred
get
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("body")
> ### * body
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: body
> ### Title: Access to and Manipulation of the Body of a Function
> ### Aliases: body body<-
> ### Keywords: programming
> 
> ### ** Examples
> 
> body(body)
{
    if (is.character(fun)) 
        fun <- get(fun, mode = "function", envir = parent.frame())
    .Internal(body(fun))
}
> f <- function(x) x^5
> body(f) <- quote(5^x)
> ## or equivalently  body(f) <- expression(5^x)
> f(3) # = 125
[1] 125
> body(f)
5^x
> 
> ## creating a multi-expression body
> e <- expression(y <- x^2, return(y)) # or a list
> body(f) <- as.call(c(as.name("{"), e))
> f
function (x) 
{
    y <- x^2
    return(y)
}
> f(8)
[1] 64
> 
> 
> 
> cleanEx()
> nameEx("bquote")
> ### * bquote
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bquote
> ### Title: Partial substitution in expressions
> ### Aliases: bquote
> ### Keywords: programming data
> 
> ### ** Examples
> 
> require(graphics)
> 
> a <- 2
> 
> bquote(a == a)
a == a
> quote(a == a)
a == a
> 
> bquote(a == .(a))
a == 2
> substitute(a == A, list(A = a))
a == 2
> 
> plot(1:10, a*(1:10), main = bquote(a == .(a)))
> 
> ## to set a function default arg
> default <- 1
> bquote( function(x, y = .(default)) x+y )
function(x, y = 1) x + y
> 
> 
> 
> cleanEx()
> nameEx("by")
> ### * by
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: by
> ### Title: Apply a Function to a Data Frame Split by Factors
> ### Aliases: by by.default by.data.frame print.by
> ### Keywords: iteration category
> 
> ### ** Examples
> 
> require(stats)
> by(warpbreaks[, 1:2], warpbreaks[,"tension"], summary)
warpbreaks[, "tension"]: L
     breaks      wool 
 Min.   :14.00   A:9  
 1st Qu.:26.00   B:9  
 Median :29.50        
 Mean   :36.39        
 3rd Qu.:49.25        
 Max.   :70.00        
------------------------------------------------------------ 
warpbreaks[, "tension"]: M
     breaks      wool 
 Min.   :12.00   A:9  
 1st Qu.:18.25   B:9  
 Median :27.00        
 Mean   :26.39        
 3rd Qu.:33.75        
 Max.   :42.00        
------------------------------------------------------------ 
warpbreaks[, "tension"]: H
     breaks      wool 
 Min.   :10.00   A:9  
 1st Qu.:15.25   B:9  
 Median :20.50        
 Mean   :21.67        
 3rd Qu.:25.50        
 Max.   :43.00        
> by(warpbreaks[, 1],   warpbreaks[, -1],       summary)
wool: A
tension: L
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  25.00   26.00   51.00   44.56   54.00   70.00 
------------------------------------------------------------ 
wool: B
tension: L
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  14.00   20.00   29.00   28.22   31.00   44.00 
------------------------------------------------------------ 
wool: A
tension: M
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
     12      18      21      24      30      36 
------------------------------------------------------------ 
wool: B
tension: M
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  16.00   21.00   28.00   28.78   39.00   42.00 
------------------------------------------------------------ 
wool: A
tension: H
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  10.00   18.00   24.00   24.56   28.00   43.00 
------------------------------------------------------------ 
wool: B
tension: H
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  13.00   15.00   17.00   18.78   21.00   28.00 
> by(warpbreaks, warpbreaks[,"tension"],
+    function(x) lm(breaks ~ wool, data = x))
warpbreaks[, "tension"]: L

Call:
lm(formula = breaks ~ wool, data = x)

Coefficients:
(Intercept)        woolB  
      44.56       -16.33  

------------------------------------------------------------ 
warpbreaks[, "tension"]: M

Call:
lm(formula = breaks ~ wool, data = x)

Coefficients:
(Intercept)        woolB  
     24.000        4.778  

------------------------------------------------------------ 
warpbreaks[, "tension"]: H

Call:
lm(formula = breaks ~ wool, data = x)

Coefficients:
(Intercept)        woolB  
     24.556       -5.778  

> 
> ## now suppose we want to extract the coefficients by group
> tmp <- with(warpbreaks,
+             by(warpbreaks, tension,
+                function(x) lm(breaks ~ wool, data = x)))
> sapply(tmp, coef)
                    L         M         H
(Intercept)  44.55556 24.000000 24.555556
woolB       -16.33333  4.777778 -5.777778
> 
> 
> 
> cleanEx()
> nameEx("c")
> ### * c
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: c
> ### Title: Combine Values into a Vector or List
> ### Aliases: c
> ### Keywords: manip
> 
> ### ** Examples
> 
> c(1,7:9)
[1] 1 7 8 9
> c(1:5, 10.5, "next")
[1] "1"    "2"    "3"    "4"    "5"    "10.5" "next"
> 
> ## uses with a single argument to drop attributes
> x <- 1:4
> names(x) <- letters[1:4]
> x
a b c d 
1 2 3 4 
> c(x)          # has names
a b c d 
1 2 3 4 
> as.vector(x)  # no names
[1] 1 2 3 4
> dim(x) <- c(2,2)
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> c(x)
[1] 1 2 3 4
> as.vector(x)
[1] 1 2 3 4
> 
> ## append to a list:
> ll <- list(A = 1, c="C")
> ## do *not* use
> c(ll, d = 1:3) # which is == c(ll, as.list(c(d=1:3))
$A
[1] 1

$c
[1] "C"

$d1
[1] 1

$d2
[1] 2

$d3
[1] 3

> ## but rather
> c(ll, d = list(1:3))# c() combining two lists
$A
[1] 1

$c
[1] "C"

$d
[1] 1 2 3

> 
> c(list(A=c(B=1)), recursive=TRUE)
A.B 
  1 
> 
> c(options(), recursive=TRUE)
$add.smooth
[1] TRUE

$bitmapType
[1] "Xlib"

$browser
[1] "/usr/bin/firefox"

$browserNLdisabled
[1] FALSE

$check.bounds
[1] FALSE

$continue
[1] "+ "

$contrasts.unordered
[1] "contr.treatment"

$contrasts.ordered
[1] "contr.poly"

$defaultPackages1
[1] "datasets"

$defaultPackages2
[1] "utils"

$defaultPackages3
[1] "grDevices"

$defaultPackages4
[1] "graphics"

$defaultPackages5
[1] "stats"

$defaultPackages6
[1] "methods"

$demo.ask
[1] "default"

$device
function (file = ifelse(onefile, "Rplots.pdf", "Rplot%03d.pdf"), 
    width, height, onefile, family, title, fonts, version, paper, 
    encoding, bg, fg, pointsize, pagecentre, colormodel, useDingbats, 
    useKerning, fillOddEven, maxRasters, compress) 
{
    initPSandPDFfonts()
    new <- list()
    if (!missing(width)) 
        new$width <- width
    if (!missing(height)) 
        new$height <- height
    if (!missing(onefile)) 
        new$onefile <- onefile
    if (!missing(title)) 
        new$title <- title
    if (!missing(fonts)) 
        new$fonts <- fonts
    if (!missing(version)) 
        new$version <- version
    if (!missing(paper)) 
        new$paper <- paper
    if (!missing(encoding)) 
        new$encoding <- encoding
    if (!missing(bg)) 
        new$bg <- bg
    if (!missing(fg)) 
        new$fg <- fg
    if (!missing(pointsize)) 
        new$pointsize <- pointsize
    if (!missing(pagecentre)) 
        new$pagecentre <- pagecentre
    if (!missing(colormodel)) 
        new$colormodel <- colormodel
    if (!missing(useDingbats)) 
        new$useDingbats <- useDingbats
    if (!missing(useKerning)) 
        new$useKerning <- useKerning
    if (!missing(fillOddEven)) 
        new$fillOddEven <- fillOddEven
    if (!missing(maxRasters)) 
        warning("'maxRasters' is no longer needed, and will be ignored")
    if (!missing(compress)) 
        new$compress <- compress
    old <- check.options(new, name.opt = ".PDF.Options", envir = .PSenv)
    if (!missing(family) && (inherits(family, "Type1Font") || 
        inherits(family, "CIDFont"))) {
        enc <- family$encoding
        if (inherits(family, "Type1Font") && !is.null(enc) && 
            enc != "default" && (is.null(old$encoding) || old$encoding == 
            "default")) 
            old$encoding <- enc
        family <- family$metrics
    }
    if (is.null(old$encoding) || old$encoding == "default") 
        old$encoding <- guessEncoding()
    if (!missing(family)) {
        if (length(family) == 4L) {
            family <- c(family, "Symbol.afm")
        }
        else if (length(family) == 5L) {
        }
        else if (length(family) == 1L) {
            pf <- pdfFonts(family)[[1L]]
            if (is.null(pf)) 
                stop(gettextf("unknown family '%s'", family), 
                  domain = NA)
            matchFont(pf, old$encoding)
        }
        else stop("invalid 'family' argument")
        old$family <- family
    }
    version <- old$version
    versions <- c("1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", 
        "2.0")
    if (version %in% versions) 
        version <- as.integer(strsplit(version, "[.]")[[1L]])
    else stop("invalid PDF version")
    onefile <- old$onefile
    if (!checkIntFormat(file)) 
        stop("invalid 'file'")
    .External(PDF, file, old$paper, old$family, old$encoding, 
        old$bg, old$fg, old$width, old$height, old$pointsize, 
        onefile, old$pagecentre, old$title, old$fonts, version[1L], 
        version[2L], old$colormodel, old$useDingbats, old$useKerning, 
        old$fillOddEven, old$compress)
    invisible()
}
<bytecode: 0x9c966b0>
<environment: namespace:grDevices>

$device.ask.default
[1] FALSE

$digits
[1] 7

$dvipscmd
[1] "dvips"

$echo
[1] TRUE

$editor
[1] "vi"

$encoding
[1] "native.enc"

$example.ask
[1] "default"

$expressions
[1] 5000

$help.search.types1
[1] "vignette"

$help.search.types2
[1] "demo"

$help.search.types3
[1] "help"

$help.try.all.packages
[1] FALSE

$HTTPUserAgent
[1] "R (2.15.1 i686-pc-linux-gnu i686 linux-gnu)"

$internet.info
[1] 2

$keep.source
[1] FALSE

$keep.source.pkgs
[1] FALSE

$locatorBell
[1] TRUE

$mailer
[1] "mailto"

$max.print
[1] 99999

$menu.graphics
[1] TRUE

$na.action
[1] "na.omit"

$nwarnings
[1] 50

$OutDec
[1] "."

$pager
[1] "/usr/local/R-2.15.1/bin/pager"

$papersize
[1] "a4"

$pdfviewer
[1] "/usr/bin/xdg-open"

$pkgType
[1] "source"

$printcmd
[1] "lpr"

$prompt
[1] "> "

$repos.CRAN
[1] "@CRAN@"

$rl_word_breaks
[1] " \t\n\"\\'`><=%;,|&{()}"

$scipen
[1] 0

$show.coef.Pvalues
[1] TRUE

$showErrorCalls
[1] TRUE

$show.error.messages
[1] TRUE

$show.signif.stars
[1] TRUE

$str.strict.width
[1] "no"

$str.digits.d
[1] 3

$str.vec.len
[1] 4

$str.dendrogram.last
[1] "`"

$stringsAsFactors
[1] TRUE

$texi2dvi
[1] "texi2dvi"

$timeout
[1] 60

$ts.eps
[1] 1e-05

$ts.S.compat
[1] FALSE

$unzip
[1] "/usr/bin/unzip"

$useFancyQuotes
[1] TRUE

$verbose
[1] FALSE

$warn
[1] 1

$warning.length
[1] 1000

$width
[1] 80

> c(list(A=c(B=1,C=2), B=c(E=7)), recursive=TRUE)
A.B A.C B.E 
  1   2   7 
> 
> 
> 
> cleanEx()
> nameEx("call")
> ### * call
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: call
> ### Title: Function Calls
> ### Aliases: call is.call as.call
> ### Keywords: programming attribute
> 
> ### ** Examples
> 
> is.call(call) #-> FALSE: Functions are NOT calls
[1] FALSE
> 
> ## set up a function call to round with argument 10.5
> cl <- call("round", 10.5)
> is.call(cl)# TRUE
[1] TRUE
> cl
round(10.5)
> ## such a call can also be evaluated.
> eval(cl)# [1] 10
[1] 10
> 
> A <- 10.5
> call("round", A)        # round(10.5)
round(10.5)
> call("round", quote(A)) # round(A)
round(A)
> f <- "round"
> call(f, quote(A))       # round(A)
round(A)
> ## if we want to supply a function we need to use as.call or similar
> f <- round
> ## Not run: call(f, quote(A))  # error: first arg must be character
> (g <- as.call(list(f, quote(A))))
.Primitive("round")(A)
> eval(g)
[1] 10
> ## alternatively but less transparently
> g <- list(f, quote(A))
> mode(g) <- "call"
> g
.Primitive("round")(A)
> eval(g)
[1] 10
> ## see also the examples in the help for do.call
> 
> 
> 
> cleanEx()
> nameEx("callCC")
> ### * callCC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: callCC
> ### Title: Call With Current Continuation
> ### Aliases: callCC
> ### Keywords: programming
> 
> ### ** Examples
> 
> # The following all return the value 1
> callCC(function(k) 1)
[1] 1
> callCC(function(k) k(1))
[1] 1
> callCC(function(k) {k(1); 2})
[1] 1
> callCC(function(k) repeat k(1))
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("capabilities")
> ### * capabilities
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: capabilities
> ### Title: Report Capabilities of this Build of R
> ### Aliases: capabilities
> ### Keywords: utilities
> 
> ### ** Examples
> 
> capabilities()
    jpeg      png     tiff    tcltk      X11     aqua http/ftp  sockets 
    TRUE     TRUE    FALSE    FALSE     TRUE    FALSE     TRUE     TRUE 
  libxml     fifo   cledit    iconv      NLS  profmem    cairo 
    TRUE     TRUE    FALSE     TRUE     TRUE    FALSE    FALSE 
> 
> if(!capabilities("http/ftp"))
+    warning("internal download.file() is not available")
> 
> ## See also the examples for 'connections'.
> 
> 
> 
> cleanEx()
> nameEx("cat")
> ### * cat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cat
> ### Title: Concatenate and Print
> ### Aliases: cat
> ### Keywords: print file connection
> 
> ### ** Examples
> 
> iter <- stats::rpois(1, lambda=10)
> ## print an informative message
> cat("iteration = ", iter <- iter + 1, "\n")
iteration =  9 
> 
> ## 'fill' and label lines:
> cat(paste(letters, 100* 1:26), fill = TRUE,
+     labels = paste("{",1:10,"}:",sep=""))
{1}: a 100 b 200 c 300 d 400 e 500 f 600 g 700 h 800 i 900 j 1000 k 1100 l 1200 
{2}: m 1300 n 1400 o 1500 p 1600 q 1700 r 1800 s 1900 t 2000 u 2100 v 2200 
{3}: w 2300 x 2400 y 2500 z 2600
> 
> 
> 
> cleanEx()
> nameEx("cbind")
> ### * cbind
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cbind
> ### Title: Combine R Objects by Rows or Columns
> ### Aliases: cbind rbind cbind.data.frame rbind.data.frame .__H__.cbind
> ###   .__H__.rbind
> ### Keywords: array manip
> 
> ### ** Examples
> 
> m <- cbind(1, 1:7) # the '1' (= shorter vector) is recycled
> m
     [,1] [,2]
[1,]    1    1
[2,]    1    2
[3,]    1    3
[4,]    1    4
[5,]    1    5
[6,]    1    6
[7,]    1    7
> m <- cbind(m, 8:14)[, c(1, 3, 2)] # insert a column
> m
     [,1] [,2] [,3]
[1,]    1    8    1
[2,]    1    9    2
[3,]    1   10    3
[4,]    1   11    4
[5,]    1   12    5
[6,]    1   13    6
[7,]    1   14    7
> cbind(1:7, diag(3))# vector is subset -> warning
Warning in cbind(1:7, diag(3)) :
  number of rows of result is not a multiple of vector length (arg 1)
     [,1] [,2] [,3] [,4]
[1,]    1    1    0    0
[2,]    2    0    1    0
[3,]    3    0    0    1
> 
> cbind(0, rbind(1, 1:3))
     [,1] [,2] [,3] [,4]
[1,]    0    1    1    1
[2,]    0    1    2    3
> cbind(I=0, X=rbind(a=1, b=1:3))  # use some names
  I      
a 0 1 1 1
b 0 1 2 3
> xx <- data.frame(I=rep(0,2))
> cbind(xx, X=rbind(a=1, b=1:3))   # named differently
  I X.1 X.2 X.3
a 0   1   1   1
b 0   1   2   3
> 
> cbind(0, matrix(1, nrow=0, ncol=4))#> Warning (making sense)
Warning in cbind(0, matrix(1, nrow = 0, ncol = 4)) :
  number of rows of result is not a multiple of vector length (arg 1)
     [,1] [,2] [,3] [,4] [,5]
> dim(cbind(0, matrix(1, nrow=2, ncol=0)))#-> 2 x 1
[1] 2 1
> 
> ## deparse.level
> dd <- 10
> rbind(1:4, c=2, "a++" = 10, dd, deparse.level=0)# middle 2 rownames
    [,1] [,2] [,3] [,4]
       1    2    3    4
c      2    2    2    2
a++   10   10   10   10
      10   10   10   10
> rbind(1:4, c=2, "a++" = 10, dd, deparse.level=1)# 3 rownames (default)
    [,1] [,2] [,3] [,4]
       1    2    3    4
c      2    2    2    2
a++   10   10   10   10
dd    10   10   10   10
> rbind(1:4, c=2, "a++" = 10, dd, deparse.level=2)# 4 rownames
    [,1] [,2] [,3] [,4]
1:4    1    2    3    4
c      2    2    2    2
a++   10   10   10   10
dd    10   10   10   10
> 
> 
> 
> cleanEx()
> nameEx("char.expand")
> ### * char.expand
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: char.expand
> ### Title: Expand a String with Respect to a Target Table
> ### Aliases: char.expand
> ### Keywords: character
> 
> ### ** Examples
> 
> locPars <- c("mean", "median", "mode")
> char.expand("me", locPars, warning("Could not expand!"))
character(0)
> char.expand("mo", locPars)
[1] "mode"
> 
> 
> 
> cleanEx()
> nameEx("character")
> ### * character
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: character
> ### Title: Character Vectors
> ### Aliases: character as.character as.character.default
> ###   as.character.factor is.character
> ### Keywords: character classes
> 
> ### ** Examples
> 
> form <- y ~ a + b + c
> as.character(form)  ## length 3
[1] "~"         "y"         "a + b + c"
> deparse(form)       ## like the input
[1] "y ~ a + b + c"
> 
> a0 <- 11/999          # has a repeating decimal representation
> (a1 <- as.character(a0))
[1] "0.011011011011011"
> format(a0, digits=16) # shows one more digit
[1] "0.01101101101101101"
> a2 <- as.numeric(a1)
> a2 - a0               # normally around -1e-17
[1] -1.040834e-17
> as.character(a2)      # normally different from a1
[1] "0.011011011011011"
> print(c(a0, a2), digits = 16)
[1] 0.01101101101101101 0.01101101101101100
> 
> 
> 
> cleanEx()
> nameEx("charmatch")
> ### * charmatch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: charmatch
> ### Title: Partial String Matching
> ### Aliases: charmatch
> ### Keywords: character
> 
> ### ** Examples
> 
> charmatch("", "")                             # returns 1
[1] 1
> charmatch("m",   c("mean", "median", "mode")) # returns 0
[1] 0
> charmatch("med", c("mean", "median", "mode")) # returns 2
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("chartr")
> ### * chartr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chartr
> ### Title: Character Translation and Casefolding
> ### Aliases: chartr tolower toupper casefold
> ### Keywords: character
> 
> ### ** Examples
> 
> x <- "MiXeD cAsE 123"
> chartr("iXs", "why", x)
[1] "MwheD cAyE 123"
> chartr("a-cX", "D-Fw", x)
[1] "MiweD FAsE 123"
> tolower(x)
[1] "mixed case 123"
> toupper(x)
[1] "MIXED CASE 123"
> 
> ## "Mixed Case" Capitalizing - toupper( every first letter of a word ) :
> 
> .simpleCap <- function(x) {
+     s <- strsplit(x, " ")[[1]]
+     paste(toupper(substring(s, 1,1)), substring(s, 2),
+           sep="", collapse=" ")
+ }
> .simpleCap("the quick red fox jumps over the lazy brown dog")
[1] "The Quick Red Fox Jumps Over The Lazy Brown Dog"
> ## ->  [1] "The Quick Red Fox Jumps Over The Lazy Brown Dog"
> 
> ## and the better, more sophisticated version:
> capwords <- function(s, strict = FALSE) {
+     cap <- function(s) paste(toupper(substring(s,1,1)),
+                   {s <- substring(s,2); if(strict) tolower(s) else s},
+                              sep = "", collapse = " " )
+     sapply(strsplit(s, split = " "), cap, USE.NAMES = !is.null(names(s)))
+ }
> capwords(c("using AIC for model selection"))
[1] "Using AIC For Model Selection"
> ## ->  [1] "Using AIC For Model Selection"
> capwords(c("using AIC", "for MODEL selection"), strict=TRUE)
[1] "Using Aic"           "For Model Selection"
> ## ->  [1] "Using Aic"  "For Model Selection"
> ##                ^^^        ^^^^^
> ##               'bad'       'good'
> 
> ## -- Very simple insecure crypto --
> rot <- function(ch, k = 13) {
+    p0 <- function(...) paste(c(...), collapse="")
+    A <- c(letters, LETTERS, " '")
+    I <- seq_len(k); chartr(p0(A), p0(c(A[-I], A[I])), ch)
+ }
> 
> pw <- "my secret pass phrase"
> (crypw <- rot(pw, 13)) #-> you can send this off
[1] "zLlFrpErGlCnFFlCuEnFr"
> 
> ## now ``decrypt'' :
> rot(crypw, 54 - 13)# -> the original:
[1] "my secret pass phrase"
> stopifnot(identical(pw, rot(crypw, 54 - 13)))
> 
> 
> 
> cleanEx()
> nameEx("chol")
> ### * chol
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chol
> ### Title: The Choleski Decomposition
> ### Aliases: chol chol.default
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> ( m <- matrix(c(5,1,1,3),2,2) )
     [,1] [,2]
[1,]    5    1
[2,]    1    3
> ( cm <- chol(m) )
         [,1]      [,2]
[1,] 2.236068 0.4472136
[2,] 0.000000 1.6733201
> t(cm) %*% cm  #-- = 'm'
     [,1] [,2]
[1,]    5    1
[2,]    1    3
> crossprod(cm)  #-- = 'm'
     [,1] [,2]
[1,]    5    1
[2,]    1    3
> 
> # now for something positive semi-definite
> x <- matrix(c(1:5, (1:5)^2), 5, 2)
> x <- cbind(x, x[, 1] + 3*x[, 2])
> m <- crossprod(x)
> qr(m)$rank # is 2, as it should be
[1] 2
> 
> # chol() may fail, depending on numerical rounding:
> # chol() unlike qr() does not use a tolerance.
> try(chol(m))
         [,1]     [,2]         [,3]
[1,] 7.416198 30.33899 9.843318e+01
[2,] 0.000000  7.65150 2.295450e+01
[3,] 0.000000  0.00000 4.308472e-07
> 
> (Q <- chol(m, pivot = TRUE)) # NB wrong rank here - see Warning section.
         [,1]     [,2]          [,3]
[1,] 101.0742 7.222415  3.128394e+01
[2,]   0.0000 1.684259 -5.614195e-01
[3,]   0.0000 0.000000  2.092056e-07
attr(,"pivot")
[1] 3 1 2
attr(,"rank")
[1] 3
> ## we can use this by
> pivot <- attr(Q, "pivot")
> crossprod(Q[, order(pivot)]) # recover m
     [,1] [,2]  [,3]
[1,]   55  225   730
[2,]  225  979  3162
[3,]  730 3162 10216
> 
> ## now for a non-positive-definite matrix
> ( m <- matrix(c(5,-5,-5,3),2,2) )
     [,1] [,2]
[1,]    5   -5
[2,]   -5    3
> try(chol(m))  # fails
Error in chol.default(m) : 
  the leading minor of order 2 is not positive definite
> try(chol(m, LINPACK=TRUE))   # fails
Error in chol.default(m, LINPACK = TRUE) : 
  non-positive definite matrix in 'chol'
> (Q <- chol(m, pivot = TRUE)) # warning
Warning in chol.default(m, pivot = TRUE) : matrix not positive definite
         [,1]      [,2]
[1,] 2.236068 -2.236068
[2,] 0.000000 -2.000000
attr(,"pivot")
[1] 1 2
attr(,"rank")
[1] 1
> crossprod(Q)  # not equal to m
     [,1] [,2]
[1,]    5   -5
[2,]   -5    9
> 
> 
> 
> cleanEx()
> nameEx("chol2inv")
> ### * chol2inv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chol2inv
> ### Title: Inverse from Choleski (or QR) Decomposition
> ### Aliases: chol2inv
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> cma <- chol(ma  <- cbind(1, 1:3, c(1,3,7)))
> ma %*% chol2inv(cma)
             [,1]         [,2]         [,3]
[1,] 1.000000e+00 0.000000e+00 0.000000e+00
[2,] 1.110223e-16 1.000000e+00 1.110223e-16
[3,] 1.110223e-16 6.661338e-16 1.000000e+00
> 
> 
> 
> cleanEx()
> nameEx("class")
> ### * class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: class
> ### Title: Object Classes
> ### Aliases: class class<- oldClass oldClass<- unclass inherits
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> x <- 10
> class(x) # "numeric"
[1] "numeric"
> oldClass(x) # NULL
NULL
> inherits(x, "a") #FALSE
[1] FALSE
> class(x) <- c("a", "b")
> inherits(x,"a") #TRUE
[1] TRUE
> inherits(x, "a", TRUE) # 1
[1] 1
> inherits(x, c("a", "b", "c"), TRUE) # 1 2 0
[1] 1 2 0
> 
> 
> 
> cleanEx()
> nameEx("col")
> ### * col
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: col
> ### Title: Column Indexes
> ### Aliases: col
> ### Keywords: array
> 
> ### ** Examples
> 
> # extract an off-diagonal of a matrix
> ma <- matrix(1:12, 3, 4)
> ma[row(ma) == col(ma) + 1]
[1] 2 6
> 
> # create an identity 5-by-5 matrix
> x <- matrix(0, nrow = 5, ncol = 5)
> x[row(x) == col(x)] <- 1
> 
> 
> 
> cleanEx()
> nameEx("colSums")
> ### * colSums
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colSums
> ### Title: Form Row and Column Sums and Means
> ### Aliases: colSums rowSums colMeans rowMeans .colSums .rowSums .colMeans
> ###   .rowMeans
> ### Keywords: array algebra arith
> 
> ### ** Examples
> 
> ## Compute row and column sums for a matrix:
> x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
> rowSums(x); colSums(x)
[1] 7 6 5 4 5 6 7 8
x1 x2 
24 24 
> dimnames(x)[[1]] <- letters[1:8]
> rowSums(x); colSums(x); rowMeans(x); colMeans(x)
a b c d e f g h 
7 6 5 4 5 6 7 8 
x1 x2 
24 24 
  a   b   c   d   e   f   g   h 
3.5 3.0 2.5 2.0 2.5 3.0 3.5 4.0 
x1 x2 
 3  3 
> x[] <- as.integer(x)
> rowSums(x); colSums(x)
a b c d e f g h 
7 6 5 4 5 6 7 8 
x1 x2 
24 24 
> x[] <- x < 3
> rowSums(x); colSums(x)
a b c d e f g h 
0 0 1 1 1 0 0 0 
x1 x2 
 0  3 
> x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
> x[3, ] <- NA; x[4, 2] <- NA
> rowSums(x); colSums(x); rowMeans(x); colMeans(x)
[1]  7  6 NA NA  5  6  7  8
x1 x2 
NA NA 
[1] 3.5 3.0  NA  NA 2.5 3.0 3.5 4.0
x1 x2 
NA NA 
> rowSums(x, na.rm = TRUE); colSums(x, na.rm = TRUE)
[1] 7 6 0 3 5 6 7 8
x1 x2 
21 21 
> rowMeans(x, na.rm = TRUE); colMeans(x, na.rm = TRUE)
[1] 3.5 3.0 NaN 3.0 2.5 3.0 3.5 4.0
 x1  x2 
3.0 3.5 
> 
> ## an array
> dim(UCBAdmissions)
[1] 2 2 6
> rowSums(UCBAdmissions); rowSums(UCBAdmissions, dims = 2)
Admitted Rejected 
    1755     2771 
          Gender
Admit      Male Female
  Admitted 1198    557
  Rejected 1493   1278
> colSums(UCBAdmissions); colSums(UCBAdmissions, dims = 2)
        Dept
Gender     A   B   C   D   E   F
  Male   825 560 325 417 191 373
  Female 108  25 593 375 393 341
  A   B   C   D   E   F 
933 585 918 792 584 714 
> 
> ## complex case
> x <- cbind(x1 = 3 + 2i, x2 = c(4:1, 2:5) - 5i)
> x[3, ] <- NA; x[4, 2] <- NA
> rowSums(x); colSums(x); rowMeans(x); colMeans(x)
[1] 7-3i 6-3i   NA   NA 5-3i 6-3i 7-3i 8-3i
x1 x2 
NA NA
[1] 3.5-1.5i 3.0-1.5i       NA       NA 2.5-1.5i 3.0-1.5i 3.5-1.5i 4.0-1.5i
x1 x2 
NA NA
> rowSums(x, na.rm = TRUE); colSums(x, na.rm = TRUE)
[1] 7-3i 6-3i 0+0i 3+2i 5-3i 6-3i 7-3i 8-3i
    x1     x2 
21+14i 21-30i
> rowMeans(x, na.rm = TRUE); colMeans(x, na.rm = TRUE)
[1] 3.5-1.5i 3.0-1.5i       NA 3.0+2.0i 2.5-1.5i 3.0-1.5i 3.5-1.5i 4.0-1.5i
    x1     x2 
3.0+2i 3.5-5i
> 
> 
> 
> cleanEx()
> nameEx("colnames")
> ### * colnames
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: row+colnames
> ### Title: Row and Column Names
> ### Aliases: rownames rownames<- colnames colnames<-
> ### Keywords: array manip
> 
> ### ** Examples
> 
> m0 <- matrix(NA, 4, 0)
> rownames(m0)
NULL
> 
> m2 <- cbind(1,1:4)
> colnames(m2, do.NULL = FALSE)
[1] "col1" "col2"
> colnames(m2) <- c("x","Y")
> rownames(m2) <- rownames(m2, do.NULL = FALSE, prefix = "Obs.")
> m2
      x Y
Obs.1 1 1
Obs.2 1 2
Obs.3 1 3
Obs.4 1 4
> 
> 
> 
> cleanEx()
> nameEx("commandArgs")
> ### * commandArgs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: commandArgs
> ### Title: Extract Command Line Arguments
> ### Aliases: commandArgs
> ### Keywords: environment sysdata programming
> 
> ### ** Examples
> 
> commandArgs()
[1] "/usr/local/R-2.15.1/bin/exec/R" "-f"                            
[3] "base-Ex.R"                      "--restore"                     
[5] "--save"                         "--no-readline"                 
[7] "--vanilla"                     
> ## Spawn a copy of this application as it was invoked,
> ## subject to shell quoting issues
> ## system(paste(commandArgs(), collapse=" "))
> 
> 
> 
> cleanEx()
> nameEx("comment")
> ### * comment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: comment
> ### Title: Query or Set a '"comment"' Attribute
> ### Aliases: comment comment<-
> ### Keywords: attribute
> 
> ### ** Examples
> 
> x <- matrix(1:12, 3,4)
> comment(x) <- c("This is my very important data from experiment #0234",
+                 "Jun 5, 1998")
> x
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> comment(x)
[1] "This is my very important data from experiment #0234"
[2] "Jun 5, 1998"                                         
> 
> 
> 
> cleanEx()
> nameEx("complex")
> ### * complex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: complex
> ### Title: Complex Vectors
> ### Aliases: complex as.complex is.complex Re Im Mod Arg Conj
> ### Keywords: complex
> 
> ### ** Examples
> 
> require(graphics)
> 
> 0i ^ (-3:3)
[1] Inf+0i Inf+0i Inf+0i   1+0i   0+0i   0+0i   0+0i
> 
> matrix(1i^ (-6:5), nrow=4) #- all columns are the same
      [,1]  [,2]  [,3]
[1,] -1+0i -1+0i -1+0i
[2,]  0-1i  0-1i  0-1i
[3,]  1+0i  1+0i  1+0i
[4,]  0+1i  0+1i  0+1i
> 0 ^ 1i # a complex NaN
[1] NaN+NaNi
> 
> ## create a complex normal vector
> z <- complex(real = stats::rnorm(100), imaginary = stats::rnorm(100))
> ## or also (less efficiently):
> z2 <- 1:2 + 1i*(8:9)
> 
> ## The Arg(.) is an angle:
> zz <- (rep(1:4,len=9) + 1i*(9:1))/10
> zz.shift <- complex(modulus = Mod(zz), argument= Arg(zz) + pi)
> plot(zz, xlim=c(-1,1), ylim=c(-1,1), col="red", asp = 1,
+      main = expression(paste("Rotation by "," ", pi == 180^o)))
> abline(h=0,v=0, col="blue", lty=3)
> points(zz.shift, col="orange")
> 
> 
> 
> cleanEx()
> nameEx("conditions")
> ### * conditions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: conditions
> ### Title: Condition Handling and Recovery
> ### Aliases: conditions condition computeRestarts conditionCall
> ###   conditionMessage findRestart invokeRestart invokeRestartInteractively
> ###   isRestart restartDescription restartFormals signalCondition
> ###   simpleCondition simpleError simpleWarning simpleMessage tryCatch
> ###   withCallingHandlers withRestarts .signalSimpleWarning
> ###   .handleSimpleError as.character.condition as.character.error
> ###   conditionCall.condition conditionMessage.condition print.condition
> ###   print.restart
> ### Keywords: programming error
> 
> ### ** Examples
> 
> tryCatch(1, finally=print("Hello"))
[1] "Hello"
[1] 1
> e <- simpleError("test error")
> ## Not run: 
> ##D  stop(e)
> ##D  tryCatch(stop(e), finally=print("Hello"))
> ##D  tryCatch(stop("fred"), finally=print("Hello"))
> ## End(Not run)
> tryCatch(stop(e), error = function(e) e, finally=print("Hello"))
[1] "Hello"
<simpleError: test error>
> tryCatch(stop("fred"),  error = function(e) e, finally=print("Hello"))
[1] "Hello"
<simpleError in doTryCatch(return(expr), name, parentenv, handler): fred>
> withCallingHandlers({ warning("A"); 1+2 }, warning = function(w) {})
Warning in withCallingHandlers({ : A
[1] 3
> ## Not run: 
> ##D  { withRestarts(stop("A"), abort = function() {}); 1 }
> ## End(Not run)
> withRestarts(invokeRestart("foo", 1, 2), foo = function(x, y) {x + y})
[1] 3
> 
> ##--> More examples are part of
> ##-->   demo(error.catching)
> 
> 
> 
> cleanEx()
> nameEx("conflicts")
> ### * conflicts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: conflicts
> ### Title: Search for Masked Objects on the Search Path
> ### Aliases: conflicts
> ### Keywords: utilities
> 
> ### ** Examples
> 
> lm <- 1:3
> conflicts(, TRUE)
$.GlobalEnv
[1] "lm"

$CheckExEnv
[1] "F" "T"

$`package:stats`
[1] "lm"

$`package:methods`
[1] "body<-"    "kronecker"

$`package:base`
[1] "body<-"    "F"         "kronecker" "T"        

> ## gives something like
> # $.GlobalEnv
> # [1] "lm"
> #
> # $package:base
> # [1] "lm"
> 
> ## Remove things from your "workspace" that mask others:
> remove(list = conflicts(detail=TRUE)$.GlobalEnv)
> 
> 
> 
> cleanEx()
> nameEx("connections")
> ### * connections
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: connections
> ### Title: Functions to Manipulate Connections
> ### Aliases: connections connection file clipboard pipe fifo gzfile unz
> ###   bzfile xzfile url socketConnection open open.connection isOpen
> ###   isIncomplete close close.connection flush flush.connection
> ###   print.connection summary.connection
> ### Keywords: file connection
> 
> ### ** Examples
> 
> zz <- file("ex.data", "w")  # open an output file connection
> cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = zz, sep = "\n")
> cat("One more line\n", file = zz)
> close(zz)
> readLines("ex.data")
[1] "TITLE extra line" "2 3 5 7"          ""                 "11 13 17"        
[5] "One more line"   
> unlink("ex.data")
> 
> zz <- gzfile("ex.gz", "w")  # compressed file
> cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = zz, sep = "\n")
> close(zz)
> readLines(zz <- gzfile("ex.gz"))
[1] "TITLE extra line" "2 3 5 7"          ""                 "11 13 17"        
> close(zz)
> unlink("ex.gz")
> 
> zz <- bzfile("ex.bz2", "w")  # bzip2-ed file
> cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = zz, sep = "\n")
> close(zz)
> print(readLines(zz <- bzfile("ex.bz2")))
[1] "TITLE extra line" "2 3 5 7"          ""                 "11 13 17"        
> close(zz)
> unlink("ex.bz2")
> 
> ## An example of a file open for reading and writing
> Tfile <- file("test1", "w+")
> c(isOpen(Tfile, "r"), isOpen(Tfile, "w")) # both TRUE
[1] TRUE TRUE
> cat("abc\ndef\n", file=Tfile)
> readLines(Tfile)
[1] "abc" "def"
> seek(Tfile, 0, rw="r") # reset to beginning
[1] 8
> readLines(Tfile)
[1] "abc" "def"
> cat("ghi\n", file=Tfile)
> readLines(Tfile)
[1] "ghi"
> close(Tfile)
> unlink("test1")
> 
> ## We can do the same thing with an anonymous file.
> Tfile <- file()
> cat("abc\ndef\n", file=Tfile)
> readLines(Tfile)
[1] "abc" "def"
> close(Tfile)
> 
> 
> ## Not run: 
> ##D ## Two R processes communicating via non-blocking sockets
> ##D # R process 1
> ##D con1 <- socketConnection(port = 6011, server=TRUE)
> ##D writeLines(LETTERS, con1)
> ##D close(con1)
> ##D 
> ##D # R process 2
> ##D con2 <- socketConnection(Sys.info()["nodename"], port = 6011)
> ##D # as non-blocking, may need to loop for input
> ##D readLines(con2)
> ##D while(isIncomplete(con2)) {
> ##D    Sys.sleep(1)
> ##D    z <- readLines(con2)
> ##D    if(length(z)) print(z)
> ##D }
> ##D close(con2)
> ##D 
> ##D ## examples of use of encodings
> ##D # write a file in UTF-8
> ##D cat(x, file = (con <- file("foo", "w", encoding="UTF-8"))); close(con)
> ##D # read a 'Windows Unicode' file
> ##D A <- read.table(con <- file("students", encoding="UCS-2LE")); close(con)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("converters")
> ### * converters
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: converters
> ### Title: Management of .C argument conversion list
> ### Aliases: getNumCConverters getCConverterDescriptions
> ###   getCConverterStatus setCConverterStatus removeCConverter
> ### Keywords: interface programming
> 
> ### ** Examples
> 
> getNumCConverters()
[1] 0
> getCConverterDescriptions()
character(0)
> getCConverterStatus()
named logical(0)
> ## Not run: 
> ##D old <- setCConverterStatus(1, FALSE)
> ##D 
> ##D setCConverterStatus(1, old)
> ## End(Not run)
> ## Not run: 
> ##D removeCConverter(1)
> ##D removeCConverter(getCConverterDescriptions()[1])
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("crossprod")
> ### * crossprod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossprod
> ### Title: Matrix Crossproduct
> ### Aliases: crossprod tcrossprod
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> (z <- crossprod(1:4))    # = sum(1 + 2^2 + 3^2 + 4^2)
     [,1]
[1,]   30
> drop(z)                  # scalar
[1] 30
> x <- 1:4; names(x) <- letters[1:4]; x
a b c d 
1 2 3 4 
> tcrossprod(as.matrix(x)) # is
  a b  c  d
a 1 2  3  4
b 2 4  6  8
c 3 6  9 12
d 4 8 12 16
> identical(tcrossprod(as.matrix(x)),
+           crossprod(t(x)))
[1] TRUE
> tcrossprod(x)            # no dimnames
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
[2,]    2    4    6    8
[3,]    3    6    9   12
[4,]    4    8   12   16
> 
> m <- matrix(1:6, 2,3) ; v <- 1:3; v2 <- 2:1
> stopifnot(identical(tcrossprod(v, m), v %*% t(m)),
+           identical(tcrossprod(v, m), crossprod(v, t(m))),
+           identical(crossprod(m, v2), t(m) %*% v2))
> 
> 
> 
> cleanEx()
> nameEx("cumsum")
> ### * cumsum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cumsum
> ### Title: Cumulative Sums, Products, and Extremes
> ### Aliases: cumsum cumprod cummin cummax
> ### Keywords: arith
> 
> ### ** Examples
> 
> cumsum(1:10)
 [1]  1  3  6 10 15 21 28 36 45 55
> cumprod(1:10)
 [1]       1       2       6      24     120     720    5040   40320  362880
[10] 3628800
> cummin(c(3:1, 2:0, 4:2))
[1] 3 2 1 1 1 0 0 0 0
> cummax(c(3:1, 2:0, 4:2))
[1] 3 3 3 3 3 3 4 4 4
> 
> 
> 
> cleanEx()
> nameEx("cut.POSIXt")
> ### * cut.POSIXt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cut.POSIXt
> ### Title: Convert a Date or Date-Time Object to a Factor
> ### Aliases: cut.POSIXt cut.Date
> ### Keywords: manip chron
> 
> ### ** Examples
> 
> ## random dates in a 10-week period
> cut(ISOdate(2001, 1, 1) + 70*86400*stats::runif(100), "weeks")
  [1] 2001-01-15 2001-01-22 2001-02-05 2001-03-05 2001-01-15 2001-03-05
  [7] 2001-03-05 2001-02-12 2001-02-12 2001-01-01 2001-01-15 2001-01-08
 [13] 2001-02-12 2001-01-22 2001-02-19 2001-02-05 2001-02-19 2001-03-05
 [19] 2001-01-22 2001-02-19 2001-03-05 2001-01-15 2001-02-12 2001-01-08
 [25] 2001-01-15 2001-01-22 2001-01-01 2001-01-22 2001-02-26 2001-01-22
 [31] 2001-01-29 2001-02-12 2001-02-05 2001-01-08 2001-02-26 2001-02-12
 [37] 2001-02-26 2001-01-08 2001-02-19 2001-01-29 2001-02-26 2001-02-12
 [43] 2001-02-19 2001-02-05 2001-02-05 2001-02-19 2001-01-01 2001-01-29
 [49] 2001-02-19 2001-02-12 2001-01-29 2001-02-26 2001-01-29 2001-01-15
 [55] 2001-01-01 2001-01-08 2001-01-22 2001-02-05 2001-02-12 2001-01-29
 [61] 2001-03-05 2001-01-22 2001-01-29 2001-01-22 2001-02-12 2001-01-15
 [67] 2001-01-29 2001-02-19 2001-01-01 2001-02-26 2001-01-22 2001-02-26
 [73] 2001-01-22 2001-01-22 2001-01-29 2001-02-26 2001-02-26 2001-01-22
 [79] 2001-02-19 2001-03-05 2001-01-29 2001-02-19 2001-01-29 2001-01-22
 [85] 2001-02-19 2001-01-15 2001-02-19 2001-01-08 2001-01-15 2001-01-08
 [91] 2001-01-15 2001-01-01 2001-02-12 2001-02-26 2001-02-19 2001-02-26
 [97] 2001-01-29 2001-01-29 2001-02-26 2001-02-12
10 Levels: 2001-01-01 2001-01-08 2001-01-15 2001-01-22 ... 2001-03-05
> cut(as.Date("2001/1/1") + 70*stats::runif(100), "weeks")
  [1] 2001-02-12 2001-01-22 2001-01-15 2001-03-05 2001-02-12 2001-01-15
  [7] 2001-01-08 2001-01-29 2001-03-05 2001-02-05 2001-03-05 2001-02-19
 [13] 2001-01-22 2001-01-29 2001-01-08 2001-01-01 2001-02-19 2001-01-08
 [19] 2001-01-29 2001-02-12 2001-03-05 2001-01-29 2001-01-29 2001-01-08
 [25] 2001-02-19 2001-01-29 2001-02-05 2001-01-15 2001-01-15 2001-02-05
 [31] 2001-02-05 2001-01-01 2001-01-01 2001-02-12 2001-03-05 2001-02-05
 [37] 2001-02-05 2001-02-05 2001-03-05 2001-02-05 2001-02-12 2001-02-12
 [43] 2001-01-15 2001-01-15 2001-02-19 2001-01-29 2001-01-08 2001-02-19
 [49] 2001-01-08 2001-02-26 2001-02-12 2001-02-05 2001-01-22 2001-01-29
 [55] 2001-02-05 2001-01-08 2001-02-05 2001-01-01 2001-01-15 2001-01-15
 [61] 2001-01-15 2001-02-26 2001-01-29 2001-02-19 2001-02-26 2001-01-29
 [67] 2001-01-01 2001-01-22 2001-02-19 2001-01-22 2001-02-12 2001-02-26
 [73] 2001-02-26 2001-01-22 2001-01-22 2001-02-26 2001-02-12 2001-02-19
 [79] 2001-02-12 2001-03-05 2001-01-15 2001-01-08 2001-02-26 2001-02-05
 [85] 2001-02-26 2001-01-08 2001-02-19 2001-02-19 2001-03-05 2001-02-05
 [91] 2001-02-19 2001-01-22 2001-01-08 2001-03-05 2001-01-15 2001-02-05
 [97] 2001-01-08 2001-02-26 2001-01-22 2001-02-19
10 Levels: 2001-01-01 2001-01-08 2001-01-15 2001-01-22 ... 2001-03-05
> 
> 
> 
> cleanEx()
> nameEx("cut")
> ### * cut
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cut
> ### Title: Convert Numeric to Factor
> ### Aliases: cut cut.default
> ### Keywords: category
> 
> ### ** Examples
> 
> Z <- stats::rnorm(10000)
> table(cut(Z, breaks = -6:6))

(-6,-5] (-5,-4] (-4,-3] (-3,-2] (-2,-1]  (-1,0]   (0,1]   (1,2]   (2,3]   (3,4] 
      0       0      18     241    1348    3461    3296    1393     233      10 
  (4,5]   (5,6] 
      0       0 
> sum(table(cut(Z, breaks = -6:6, labels=FALSE)))
[1] 10000
> sum(graphics::hist(Z, breaks = -6:6, plot=FALSE)$counts)
[1] 10000
> 
> cut(rep(1,5),4)#-- dummy
[1] (0.9995,1] (0.9995,1] (0.9995,1] (0.9995,1] (0.9995,1]
Levels: (0.999,0.9995] (0.9995,1] (1,1.0005] (1.0005,1.001]
> tx0 <- c(9, 4, 6, 5, 3, 10, 5, 3, 5)
> x <- rep(0:8, tx0)
> stopifnot(table(x) == tx0)
> 
> table( cut(x, b = 8))

(-0.008,0.994]      (0.994,2]          (2,3]          (3,4]          (4,5] 
             9              4              6              5             13 
         (5,6]       (6,7.01]    (7.01,8.01] 
             5              3              5 
> table( cut(x, breaks = 3*(-2:5)))

(-6,-3]  (-3,0]   (0,3]   (3,6]   (6,9]  (9,12] (12,15] 
      0       9      15      18       8       0       0 
> table( cut(x, breaks = 3*(-2:5), right = FALSE))

[-6,-3)  [-3,0)   [0,3)   [3,6)   [6,9)  [9,12) [12,15) 
      0       0      19      18      13       0       0 
> 
> ##--- some values OUTSIDE the breaks :
> table(cx  <- cut(x, breaks = 2*(0:4)))

(0,2] (2,4] (4,6] (6,8] 
   10     8    15     8 
> table(cxl <- cut(x, breaks = 2*(0:4), right = FALSE))

[0,2) [2,4) [4,6) [6,8) 
   13    11    13     8 
> which(is.na(cx));  x[is.na(cx)]  #-- the first 9  values  0
[1] 1 2 3 4 5 6 7 8 9
[1] 0 0 0 0 0 0 0 0 0
> which(is.na(cxl)); x[is.na(cxl)] #-- the last  5  values  8
[1] 46 47 48 49 50
[1] 8 8 8 8 8
> 
> 
> ## Label construction:
> y <- stats::rnorm(100)
> table(cut(y, breaks = pi/3*(-3:3)))

(-3.14,-2.09] (-2.09,-1.05]     (-1.05,0]      (0,1.05]   (1.05,2.09] 
            0             9            45            36            10 
  (2.09,3.14] 
            0 
> table(cut(y, breaks = pi/3*(-3:3), dig.lab=4))

(-3.142,-2.094] (-2.094,-1.047]      (-1.047,0]       (0,1.047]   (1.047,2.094] 
              0               9              45              36              10 
  (2.094,3.142] 
              0 
> 
> table(cut(y, breaks =  1*(-3:3), dig.lab=4))

(-3,-2] (-2,-1]  (-1,0]   (0,1]   (1,2]   (2,3] 
      0      10      44      33      13       0 
> # extra digits don't "harm" here
> table(cut(y, breaks =  1*(-3:3), right = FALSE))

[-3,-2) [-2,-1)  [-1,0)   [0,1)   [1,2)   [2,3) 
      0      10      44      33      13       0 
> #- the same, since no exact INT!
> 
> ## sometimes the default dig.lab is not enough to be avoid confusion:
> aaa <- c(1,2,3,4,5,2,3,4,5,6,7)
> cut(aaa, 3)
 [1] (0.994,3] (0.994,3] (3,5]     (3,5]     (3,5]     (0.994,3] (3,5]    
 [8] (3,5]     (3,5]     (5,7.01]  (5,7.01] 
Levels: (0.994,3] (3,5] (5,7.01]
> cut(aaa, 3, dig.lab=4, ordered = TRUE)
 [1] (0.994,2.998] (0.994,2.998] (2.998,5.002] (2.998,5.002] (2.998,5.002]
 [6] (0.994,2.998] (2.998,5.002] (2.998,5.002] (2.998,5.002] (5.002,7.006]
[11] (5.002,7.006]
Levels: (0.994,2.998] < (2.998,5.002] < (5.002,7.006]
> 
> ## one way to extract the breakpoints
> labs <- levels(cut(aaa, 3))
> cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
+       upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
     lower upper
[1,] 0.994  3.00
[2,] 3.000  5.00
[3,] 5.000  7.01
> 
> 
> 
> cleanEx()
> nameEx("data.class")
> ### * data.class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.class
> ### Title: Object Classes
> ### Aliases: data.class
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> x <- LETTERS
> data.class(factor(x))                 # has a class attribute
[1] "factor"
> data.class(matrix(x, ncol = 13))      # has a dim attribute
[1] "matrix"
> data.class(list(x))                   # the same as mode(x)
[1] "list"
> data.class(x)                         # the same as mode(x)
[1] "character"
> 
> stopifnot(data.class(1:2) == "numeric")# compatibility "rule"
> 
> 
> 
> cleanEx()
> nameEx("data.frame")
> ### * data.frame
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.frame
> ### Title: Data Frames
> ### Aliases: data.frame default.stringsAsFactors
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> L3 <- LETTERS[1:3]
> (d <- data.frame(cbind(x=1, y=1:10), fac=sample(L3, 10, replace=TRUE)))
   x  y fac
1  1  1   A
2  1  2   B
3  1  3   B
4  1  4   C
5  1  5   A
6  1  6   C
7  1  7   C
8  1  8   B
9  1  9   B
10 1 10   A
> 
> ## The same with automatic column names:
> data.frame(cbind(  1,   1:10),     sample(L3, 10, replace=TRUE))
   X1 X2 sample.L3..10..replace...TRUE.
1   1  1                              A
2   1  2                              A
3   1  3                              C
4   1  4                              B
5   1  5                              C
6   1  6                              B
7   1  7                              C
8   1  8                              C
9   1  9                              B
10  1 10                              C
> 
> is.data.frame(d)
[1] TRUE
> 
> ## do not convert to factor, using I() :
> (dd <- cbind(d, char = I(letters[1:10])))
   x  y fac char
1  1  1   A    a
2  1  2   B    b
3  1  3   B    c
4  1  4   C    d
5  1  5   A    e
6  1  6   C    f
7  1  7   C    g
8  1  8   B    h
9  1  9   B    i
10 1 10   A    j
> rbind(class=sapply(dd, class), mode=sapply(dd, mode))
      x         y         fac       char       
class "numeric" "numeric" "factor"  "AsIs"     
mode  "numeric" "numeric" "numeric" "character"
> 
> stopifnot(1:10 == row.names(d))# {coercion}
> 
> (d0  <- d[, FALSE]) # NULL data frame with 10 rows
data frame with 0 columns and 10 rows
> (d.0 <- d[FALSE, ]) # <0 rows> data frame  (3 cols)
[1] x   y   fac
<0 rows> (or 0-length row.names)
> (d00 <- d0[FALSE,])  # NULL data frame with 0 rows
data frame with 0 columns and 0 rows
> 
> 
> 
> cleanEx()
> nameEx("data.matrix")
> ### * data.matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.matrix
> ### Title: Convert a Data Frame to a Numeric Matrix
> ### Aliases: data.matrix
> ### Keywords: array
> 
> ### ** Examples
> 
> DF <- data.frame(a=1:3, b=letters[10:12],
+                  c=seq(as.Date("2004-01-01"), by = "week", len = 3),
+                  stringsAsFactors = TRUE)
> data.matrix(DF[1:2])
     a b
[1,] 1 1
[2,] 2 2
[3,] 3 3
> data.matrix(DF)
     a b     c
[1,] 1 1 12418
[2,] 2 2 12425
[3,] 3 3 12432
> 
> 
> 
> cleanEx()
> nameEx("date")
> ### * date
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: date
> ### Title: System Date and Time
> ### Aliases: date
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("dcf")
> ### * dcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dcf
> ### Title: Read and Write Data in DCF Format
> ### Aliases: read.dcf write.dcf
> ### Keywords: print file
> 
> ### ** Examples
> ## Not run: 
> ##D ## Create a reduced version of the 'CONTENTS' file in package 'splines'
> ##D x <- read.dcf(file = system.file("CONTENTS", package = "splines"),
> ##D               fields = c("Entry", "Description"))
> ##D write.dcf(x)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("delayedAssign")
> ### * delayedAssign
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: delayedAssign
> ### Title: Delay Evaluation
> ### Aliases: delayedAssign promise promises
> ### Keywords: programming data
> 
> ### ** Examples
> 
> msg <- "old"
> delayedAssign("x", msg)
> msg <- "new!"
> x #- new!
[1] "new!"
> substitute(x) #- x (was 'msg' ?)
x
> 
> delayedAssign("x", {
+     for(i in 1:3)
+         cat("yippee!\n")
+     10
+ })
> 
> x^2 #- yippee
yippee!
yippee!
yippee!
[1] 100
> x^2 #- simple number
[1] 100
> 
> e <- (function(x, y = 1, z) environment())(1+2, "y", {cat(" HO! "); pi+2})
> (le <- as.list(e)) # evaluates the promises
 HO! $x
[1] 3

$y
[1] "y"

$z
[1] 5.141593

> 
> 
> 
> 
> cleanEx()
> nameEx("deparse")
> ### * deparse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deparse
> ### Title: Expression Deparsing
> ### Aliases: deparse
> ### Keywords: programming manip data
> 
> ### ** Examples
> 
> require(stats); require(graphics)
> 
> deparse(args(lm))
[1] "function (formula, data, subset, weights, na.action, method = \"qr\", " 
[2] "    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, "
[3] "    contrasts = NULL, offset, ...) "                                    
[4] "NULL"                                                                   
> deparse(args(lm), width = 500)
[1] "function (formula, data, subset, weights, na.action, method = \"qr\", model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...) "
[2] "NULL"                                                                                                                                                                    
> myplot <-
+ function(x, y) {
+     plot(x, y, xlab=deparse(substitute(x)),
+         ylab=deparse(substitute(y)))
+ }
> e <- quote(`foo bar`)
> deparse(e)
[1] "foo bar"
> deparse(e, backtick=TRUE)
[1] "`foo bar`"
> e <- quote(`foo bar`+1)
> deparse(e)
[1] "`foo bar` + 1"
> deparse(e, control = "all")
[1] "quote(`foo bar` + 1)"
> 
> 
> 
> cleanEx()
> nameEx("det")
> ### * det
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: det
> ### Title: Calculate the Determinant of a Matrix
> ### Aliases: det determinant determinant.matrix
> ### Keywords: array
> 
> ### ** Examples
> 
> (x <- matrix(1:4, ncol=2))
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> unlist(determinant(x))
   modulus       sign 
 0.6931472 -1.0000000 
> det(x)
[1] -2
> 
> det(print(cbind(1,1:3,c(2,0,1))))
     [,1] [,2] [,3]
[1,]    1    1    2
[2,]    1    2    0
[3,]    1    3    1
[1] 3
> 
> 
> 
> cleanEx()
> nameEx("detach")
> ### * detach
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: detach
> ### Title: Detach Objects from the Search Path
> ### Aliases: detach
> ### Keywords: data
> 
> ### ** Examples
> 
> require(splines) # package
Loading required package: splines
> detach(package:splines)
> ## or also
> library(splines)
> pkg <- "package:splines"
> ## Don't show: 
> stopifnot(inherits(tryCatch(detach(pkg), error=function(.).),  "error"))
> ## End Don't show
> detach(pkg, character.only = TRUE)
> 
> ## careful: do not do this unless 'splines' is not already attached.
> library(splines)
> detach(2) # 'pos' used for 'name'
> 
> ## an example of the name argument to attach
> ## and of detaching a database named by a character vector
> attach_and_detach <- function(db, pos=2)
+ {
+    name <- deparse(substitute(db))
+    attach(db, pos=pos, name=name)
+    print(search()[pos])
+    detach(name, character.only = TRUE)
+ }
> attach_and_detach(women, pos=3)
[1] "women"
> 
> 
> 
> cleanEx()
> nameEx("diag")
> ### * diag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diag
> ### Title: Matrix Diagonals
> ### Aliases: diag diag<-
> ### Keywords: array
> 
> ### ** Examples
> 
> require(stats)
> dim(diag(3))
[1] 3 3
> diag(10,3,4) # guess what?
     [,1] [,2] [,3] [,4]
[1,]   10    0    0    0
[2,]    0   10    0    0
[3,]    0    0   10    0
> all(diag(1:3) == {m <- matrix(0,3,3); diag(m) <- 1:3; m})
[1] TRUE
> 
> diag(var(M <- cbind(X = 1:5, Y = stats::rnorm(5))))
        X         Y 
2.5000000 0.9235968 
> #-> vector with names "X" and "Y"
> 
> rownames(M) <- c(colnames(M),rep("",3));
> M; diag(M) #  named as well
  X          Y
X 1 -0.6264538
Y 2  0.1836433
  3 -0.8356286
  4  1.5952808
  5  0.3295078
        X         Y 
1.0000000 0.1836433 
> 
> 
> 
> cleanEx()
> nameEx("diff")
> ### * diff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diff
> ### Title: Lagged Differences
> ### Aliases: diff diff.default diff.POSIXt diff.Date
> ### Keywords: arith
> 
> ### ** Examples
> 
> diff(1:10, 2)
[1] 2 2 2 2 2 2 2 2
> diff(1:10, 2, 2)
[1] 0 0 0 0 0 0
> x <- cumsum(cumsum(1:10))
> diff(x, lag = 2)
[1]   9  16  25  36  49  64  81 100
> diff(x, differences = 2)
[1]  3  4  5  6  7  8  9 10
> 
> diff(.leap.seconds)
Time differences in days
 [1]  184  365  365  365  366  365  365  365  547  365  365  731  914  731  365
[16]  547  365  365  549  547  549 2557 1096
> 
> 
> 
> cleanEx()
> nameEx("difftime")
> ### * difftime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: difftime
> ### Title: Time Intervals
> ### Aliases: difftime as.difftime as.double.difftime is.numeric.difftime
> ###   print.difftime format.difftime units.difftime units<-.difftime
> ###   Ops.difftime *.difftime /.difftime Math.difftime Summary.difftime
> ###   [.difftime mean.difftime units units<- 'time interval'
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("dim")
> ### * dim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dim
> ### Title: Dimensions of an Object
> ### Aliases: dim dim.data.frame dim<-
> ### Keywords: array
> 
> ### ** Examples
> 
> x <- 1:12 ; dim(x) <- c(3,4)
> x
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> 
> # simple versions of nrow and ncol could be defined as follows
> nrow0 <- function(x) dim(x)[1]
> ncol0 <- function(x) dim(x)[2]
> 
> 
> 
> cleanEx()
> nameEx("dimnames")
> ### * dimnames
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dimnames
> ### Title: Dimnames of an Object
> ### Aliases: dimnames dimnames<- dimnames.data.frame dimnames<-.data.frame
> ### Keywords: array manip
> 
> ### ** Examples
> 
> ## simple versions of rownames and colnames
> ## could be defined as follows
> rownames0 <- function(x) dimnames(x)[[1]]
> colnames0 <- function(x) dimnames(x)[[2]]
> 
> 
> 
> cleanEx()
> nameEx("do.call")
> ### * do.call
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: do.call
> ### Title: Execute a Function Call
> ### Aliases: do.call
> ### Keywords: programming
> 
> ### ** Examples
> 
> do.call("complex", list(imag = 1:3))
[1] 0+1i 0+2i 0+3i
> 
> ## if we already have a list (e.g. a data frame)
> ## we need c() to add further arguments
> tmp <- expand.grid(letters[1:2], 1:3, c("+", "-"))
> do.call("paste", c(tmp, sep=""))
 [1] "a1+" "b1+" "a2+" "b2+" "a3+" "b3+" "a1-" "b1-" "a2-" "b2-" "a3-" "b3-"
> 
> do.call(paste, list(as.name("A"), as.name("B")), quote=TRUE)
[1] "A B"
> 
> ## examples of where objects will be found.
> A <- 2
> f <- function(x) print(x^2)
> env <- new.env()
> assign("A", 10, envir = env)
> assign("f", f, envir = env)
> f <- function(x) print(x)
> f(A)                                    # 2
[1] 2
> do.call("f", list(A))                   # 2
[1] 2
> do.call("f", list(A), envir=env)        # 4
[1] 4
> do.call(f, list(A), envir=env)          # 2
[1] 2
> do.call("f", list(quote(A)), envir=env) # 100
[1] 100
> do.call(f, list(quote(A)), envir=env)   # 10
[1] 10
> do.call("f", list(as.name("A")), envir=env) # 100
[1] 100
> 
> eval(call("f", A))                      # 2
[1] 2
> eval(call("f", quote(A)))               # 2
[1] 2
> eval(call("f", A), envir=env)           # 4
[1] 4
> eval(call("f", quote(A)), envir=env)    # 100
[1] 100
> 
> 
> 
> cleanEx()
> nameEx("double")
> ### * double
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: double
> ### Title: Double-Precision Vectors
> ### Aliases: double as.double is.double single as.single as.single.default
> ### Keywords: classes
> 
> ### ** Examples
> 
> is.double(1)
[1] TRUE
> all(double(3) == 0)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("dput")
> ### * dput
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dput
> ### Title: Write an Object to a File or Recreate it
> ### Aliases: dput dget
> ### Keywords: file programming connection
> 
> ### ** Examples
> 
> ## Write an ASCII version of mean to the file "foo"
> dput(mean, "foo")
> ## And read it back into 'bar'
> bar <- dget("foo")
> unlink("foo")
> ## Create a function with comments
> baz <- function(x) {
+   # Subtract from one
+   1-x
+ }
> ## and display it
> dput(baz)
function (x) 
{
    1 - x
}
> ## and now display the saved source
> dput(baz, control = "useSource")
function (x) 
{
    1 - x
}
> 
> 
> 
> cleanEx()
> nameEx("drop")
> ### * drop
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drop
> ### Title: Drop Redundant Extent Information
> ### Aliases: drop
> ### Keywords: array
> 
> ### ** Examples
> 
> dim(drop(array(1:12, dim=c(1,3,1,1,2,1,2))))# = 3 2 2
[1] 3 2 2
> drop(1:3 %*% 2:4)# scalar product
[1] 20
> 
> 
> 
> cleanEx()
> nameEx("droplevels")
> ### * droplevels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: droplevels
> ### Title: droplevels
> ### Aliases: droplevels droplevels.factor droplevels.data.frame
> ### Keywords: category NA
> 
> ### ** Examples
> 
> aq <- transform(airquality, Month=factor(Month,labels=month.abb[5:9]))
> aq <- subset(aq, Month != "Jul")
> table(aq$Month)

May Jun Jul Aug Sep 
 31  30   0  31  30 
> table(droplevels(aq)$Month)

May Jun Aug Sep 
 31  30  31  30 
> 
> 
> 
> cleanEx()
> nameEx("dump")
> ### * dump
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dump
> ### Title: Text Representations of R Objects
> ### Aliases: dump
> ### Keywords: file connection
> 
> ### ** Examples
> 
> x <- 1; y <- 1:10
> dump(ls(pattern = '^[xyz]'), "xyz.Rdmped")
> print(.Last.value)
[1] "x" "y"
> unlink("xyz.Rdmped")
> 
> 
> 
> cleanEx()
> nameEx("duplicated")
> ### * duplicated
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: duplicated
> ### Title: Determine Duplicate Elements
> ### Aliases: duplicated duplicated.default duplicated.data.frame
> ###   duplicated.matrix duplicated.array anyDuplicated
> ###   anyDuplicated.default anyDuplicated.array anyDuplicated.matrix
> ###   anyDuplicated.data.frame
> ### Keywords: logic manip
> 
> ### ** Examples
> 
> x <- c(9:20, 1:5, 3:7, 0:8)
> ## extract unique elements
> (xu <- x[!duplicated(x)])
 [1]  9 10 11 12 13 14 15 16 17 18 19 20  1  2  3  4  5  6  7  0  8
> ## similar, same elements but different order:
> (xu2 <- x[!duplicated(x, fromLast = TRUE)])
 [1]  9 10 11 12 13 14 15 16 17 18 19 20  0  1  2  3  4  5  6  7  8
> 
> ## xu == unique(x) but unique(x) is more efficient
> stopifnot(identical(xu,  unique(x)),
+           identical(xu2, unique(x, fromLast = TRUE)))
> 
> duplicated(iris)[140:143]
[1] FALSE FALSE FALSE  TRUE
> 
> duplicated(iris3, MARGIN = c(1, 3))
      Setosa Versicolor Virginica
 [1,]  FALSE      FALSE     FALSE
 [2,]  FALSE      FALSE     FALSE
 [3,]  FALSE      FALSE     FALSE
 [4,]  FALSE      FALSE     FALSE
 [5,]  FALSE      FALSE     FALSE
 [6,]  FALSE      FALSE     FALSE
 [7,]  FALSE      FALSE     FALSE
 [8,]  FALSE      FALSE     FALSE
 [9,]  FALSE      FALSE     FALSE
[10,]  FALSE      FALSE     FALSE
[11,]  FALSE      FALSE     FALSE
[12,]  FALSE      FALSE     FALSE
[13,]  FALSE      FALSE     FALSE
[14,]  FALSE      FALSE     FALSE
[15,]  FALSE      FALSE     FALSE
[16,]  FALSE      FALSE     FALSE
[17,]  FALSE      FALSE     FALSE
[18,]  FALSE      FALSE     FALSE
[19,]  FALSE      FALSE     FALSE
[20,]  FALSE      FALSE     FALSE
[21,]  FALSE      FALSE     FALSE
[22,]  FALSE      FALSE     FALSE
[23,]  FALSE      FALSE     FALSE
[24,]  FALSE      FALSE     FALSE
[25,]  FALSE      FALSE     FALSE
[26,]  FALSE      FALSE     FALSE
[27,]  FALSE      FALSE     FALSE
[28,]  FALSE      FALSE     FALSE
[29,]  FALSE      FALSE     FALSE
[30,]  FALSE      FALSE     FALSE
[31,]  FALSE      FALSE     FALSE
[32,]  FALSE      FALSE     FALSE
[33,]  FALSE      FALSE     FALSE
[34,]  FALSE      FALSE     FALSE
[35,]  FALSE      FALSE     FALSE
[36,]  FALSE      FALSE     FALSE
[37,]  FALSE      FALSE     FALSE
[38,]  FALSE      FALSE     FALSE
[39,]  FALSE      FALSE     FALSE
[40,]  FALSE      FALSE     FALSE
[41,]  FALSE      FALSE     FALSE
[42,]  FALSE      FALSE     FALSE
[43,]  FALSE      FALSE      TRUE
[44,]  FALSE      FALSE     FALSE
[45,]  FALSE      FALSE     FALSE
[46,]  FALSE      FALSE     FALSE
[47,]  FALSE      FALSE     FALSE
[48,]  FALSE      FALSE     FALSE
[49,]  FALSE      FALSE     FALSE
[50,]  FALSE      FALSE     FALSE
> anyDuplicated(iris) ## 143
[1] 143
> ## Don't show: 
> stopifnot(identical(anyDuplicated(iris), 143L),
+           identical(anyDuplicated(iris3, MARGIN = c(1, 3)), 143L))
> ## End Don't show
> anyDuplicated(x)
[1] 18
> anyDuplicated(x, fromLast = TRUE)
[1] 22
> 
> 
> 
> cleanEx()
> nameEx("dynload")
> ### * dynload
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dyn.load
> ### Title: Foreign Function Interface
> ### Aliases: dyn.load dyn.unload is.loaded
> ### Keywords: interface
> 
> ### ** Examples
> 
> is.loaded("hcass2") #-> probably TRUE, as stats is loaded
[1] TRUE
> is.loaded("supsmu") # Fortran entry point in stats
[1] TRUE
> is.loaded("supsmu", "stats", "Fortran")
[1] TRUE
> is.loaded("PDF", type = "External")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("eapply")
> ### * eapply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eapply
> ### Title: Apply a Function Over Values in an Environment
> ### Aliases: eapply
> ### Keywords: iteration environment list
> 
> ### ** Examples
> 
> require(stats)
> 
> env <- new.env(hash = FALSE) # so the order is fixed
> env$a <- 1:10
> env$beta <- exp(-3:3)
> env$logic <- c(TRUE, FALSE, FALSE, TRUE)
> # what have we there?
> utils::ls.str(env)
a :  int [1:10] 1 2 3 4 5 6 7 8 9 10
beta :  num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
logic :  logi [1:4] TRUE FALSE FALSE TRUE
> 
> # compute the mean for each list element
>        eapply(env, mean)
$logic
[1] 0.5

$beta
[1] 4.535125

$a
[1] 5.5

> unlist(eapply(env, mean, USE.NAMES = FALSE))
[1] 0.500000 4.535125 5.500000
> 
> # median and quartiles for each element (making use of "..." passing):
> eapply(env, quantile, probs = 1:3/4)
$logic
25% 50% 75% 
0.0 0.5 1.0 

$beta
      25%       50%       75% 
0.2516074 1.0000000 5.0536690 

$a
 25%  50%  75% 
3.25 5.50 7.75 

> eapply(env, quantile)
$logic
  0%  25%  50%  75% 100% 
 0.0  0.0  0.5  1.0  1.0 

$beta
         0%         25%         50%         75%        100% 
 0.04978707  0.25160736  1.00000000  5.05366896 20.08553692 

$a
   0%   25%   50%   75%  100% 
 1.00  3.25  5.50  7.75 10.00 

> 
> 
> 
> cleanEx()
> nameEx("eigen")
> ### * eigen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eigen
> ### Title: Spectral Decomposition of a Matrix
> ### Aliases: eigen
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> eigen(cbind(c(1,-1),c(-1,1)))
$values
[1] 2 0

$vectors
           [,1]       [,2]
[1,] -0.7071068 -0.7071068
[2,]  0.7071068 -0.7071068

> eigen(cbind(c(1,-1),c(-1,1)), symmetric = FALSE)
$values
[1] 2 0

$vectors
           [,1]      [,2]
[1,]  0.7071068 0.7071068
[2,] -0.7071068 0.7071068

> # same (different algorithm).
> 
> eigen(cbind(1,c(1,-1)), only.values = TRUE)
$values
[1]  1.414214 -1.414214

$vectors
NULL

> eigen(cbind(-1,2:1)) # complex values
$values
[1] 0+1i 0-1i

$vectors
                     [,1]                 [,2]
[1,] 0.8164966+0.0000000i 0.8164966+0.0000000i
[2,] 0.4082483+0.4082483i 0.4082483-0.4082483i

> eigen(print(cbind(c(0,1i), c(-1i,0))))# Hermite ==> real Eigen values
     [,1] [,2]
[1,] 0+0i 0-1i
[2,] 0+1i 0+0i
$values
[1]  1 -1

$vectors
                      [,1]                  [,2]
[1,] -0.7071068+0.0000000i -0.7071068+0.0000000i
[2,]  0.0000000-0.7071068i  0.0000000+0.7071068i

> ## 3 x 3:
> eigen(cbind( 1,3:1,1:3))
$values
[1]  5.000000e+00  1.000000e+00 -4.705708e-16

$vectors
           [,1]       [,2]       [,3]
[1,] -0.5773503 -0.8451543 -0.9428090
[2,] -0.5773503 -0.1690309  0.2357023
[3,] -0.5773503  0.5070926  0.2357023

> eigen(cbind(-1,c(1:2,0),0:2)) # complex values
$values
[1]  1.8846462+0.589743i  1.8846462-0.589743i -0.7692924+0.000000i

$vectors
                     [,1]                 [,2]         [,3]
[1,] 0.2777976-0.0567935i 0.2777976+0.0567935i 0.9191652+0i
[2,] 0.8348414+0.0000000i 0.8348414+0.0000000i 0.2120584+0i
[3,] 0.1814955+0.4355482i 0.1814955-0.4355482i 0.3319134+0i

> 
> 
> 
> 
> cleanEx()
> nameEx("encodeString")
> ### * encodeString
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: encodeString
> ### Title: Encode Character Vector as for Printing
> ### Aliases: encodeString
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- "ab\bc\ndef"
> print(x)
[1] "ab\bc\ndef"
> cat(x) # interprets escapes
abc
def> cat(encodeString(x), "\n", sep="") # similar to print()
ab\bc\ndef
> 
> factor(x) # makes use of this to print the levels
[1] ab\bc\ndef
Levels: ab\bc\ndef
> 
> x <- c("a", "ab", "abcde")
> encodeString(x, width = NA) # left justification
[1] "a    " "ab   " "abcde"
> encodeString(x, width = NA, justify = "c")
[1] "  a  " " ab  " "abcde"
> encodeString(x, width = NA, justify = "r")
[1] "    a" "   ab" "abcde"
> encodeString(x, width = NA, quote = "'", justify = "r")
[1] "    'a'" "   'ab'" "'abcde'"
> 
> 
> 
> cleanEx()
> nameEx("environment")
> ### * environment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: environment
> ### Title: Environment Access
> ### Aliases: environment environment<- .GlobalEnv globalenv emptyenv
> ###   baseenv is.environment new.env parent.env parent.env<-
> ###   .BaseNamespaceEnv environmentName env.profile enclosure
> ### Keywords: data programming
> 
> ### ** Examples
> 
> f <- function() "top level function"
> 
> ##-- all three give the same:
> environment()
<environment: R_GlobalEnv>
> environment(f)
<environment: R_GlobalEnv>
> .GlobalEnv
<environment: R_GlobalEnv>
> 
> ls(envir=environment(stats::approxfun(1:2,1:2, method="const")))
[1] "f"      "method" "n"      "x"      "y"      "yleft"  "yright"
> 
> is.environment(.GlobalEnv) # TRUE
[1] TRUE
> 
> e1 <- new.env(parent = baseenv())  # this one has enclosure package:base.
> e2 <- new.env(parent = e1)
> assign("a", 3, envir=e1)
> ls(e1)
[1] "a"
> ls(e2)
character(0)
> exists("a", envir=e2)   # this succeeds by inheritance
[1] TRUE
> exists("a", envir=e2, inherits = FALSE)
[1] FALSE
> exists("+", envir=e2)   # this succeeds by inheritance
[1] TRUE
> 
> eh <- new.env(hash = TRUE, size = NA)
> with(env.profile(eh), stopifnot(size == length(counts)))
> 
> 
> 
> cleanEx()
> nameEx("eval")
> ### * eval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eval
> ### Title: Evaluate an (Unevaluated) Expression
> ### Aliases: eval evalq eval.parent local
> ### Keywords: data programming
> 
> ### ** Examples
> 
> eval(2 ^ 2 ^ 3)
[1] 256
> mEx <- expression(2^2^3); mEx; 1 + eval(mEx)
expression(2^2^3)
[1] 257
> eval({ xx <- pi; xx^2}) ; xx
[1] 9.869604
[1] 3.141593
> 
> a <- 3 ; aa <- 4 ; evalq(evalq(a+b+aa, list(a=1)), list(b=5)) # == 10
[1] 10
> a <- 3 ; aa <- 4 ; evalq(evalq(a+b+aa, -1), list(b=5))        # == 12
[1] 12
> 
> ev <- function() {
+    e1 <- parent.frame()
+    ## Evaluate a in e1
+    aa <- eval(expression(a),e1)
+    ## evaluate the expression bound to a in e1
+    a <- expression(x+y)
+    list(aa = aa, eval = eval(a, e1))
+ }
> tst.ev <- function(a = 7) { x <- pi; y <- 1; ev() }
> tst.ev()#-> aa : 7,  eval : 4.14
$aa
[1] 7

$eval
[1] 4.141593

> 
> a <- list(a=3, b=4)
> with(a, a <- 5) # alters the copy of a from the list, discarded.
> 
> ##
> ## Example of evalq()
> ##
> 
> N <- 3
> env <- new.env()
> assign("N", 27, envir=env)
> ## this version changes the visible copy of N only, since the argument
> ## passed to eval is '4'.
> eval(N <- 4, env)
[1] 4
> N
[1] 4
> get("N", envir=env)
[1] 27
> ## this version does the assignment in env, and changes N only there.
> evalq(N <- 5, env)
> N
[1] 4
> get("N", envir=env)
[1] 5
> 
> 
> ##
> ## Uses of local()
> ##
> 
> # Mutually recursive.
> # gg gets value of last assignment, an anonymous version of f.
> 
> gg <- local({
+     k <- function(y)f(y)
+     f <- function(x) if(x) x*k(x-1) else 1
+ })
> gg(10)
[1] 3628800
> sapply(1:5, gg)
[1]   1   2   6  24 120
> 
> # Nesting locals: a is private storage accessible to k
> gg <- local({
+     k <- local({
+         a <- 1
+         function(y){print(a <<- a+1);f(y)}
+     })
+     f <- function(x) if(x) x*k(x-1) else 1
+ })
> sapply(1:5, gg)
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
[1] 11
[1] 12
[1] 13
[1] 14
[1] 15
[1] 16
[1]   1   2   6  24 120
> 
> ls(envir=environment(gg))
[1] "f" "k"
> ls(envir=environment(get("k", envir=environment(gg))))
[1] "a"
> 
> 
> 
> cleanEx()
> nameEx("exists")
> ### * exists
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: exists
> ### Title: Is an Object Defined?
> ### Aliases: exists
> ### Keywords: data
> 
> ### ** Examples
> 
> ##  Define a substitute function if necessary:
> if(!exists("some.fun", mode="function"))
+   some.fun <- function(x) { cat("some.fun(x)\n"); x }
> search()
 [1] ".GlobalEnv"        "CheckExEnv"        "package:stats"    
 [4] "package:graphics"  "package:grDevices" "package:utils"    
 [7] "package:datasets"  "package:methods"   "Autoloads"        
[10] "package:base"     
> exists("ls", 2) # true even though ls is in pos=3
[1] TRUE
> exists("ls", 2, inherits = FALSE) # false
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("expand.grid")
> ### * expand.grid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expand.grid
> ### Title: Create a Data Frame from All Combinations of Factors
> ### Aliases: expand.grid
> ### Keywords: models array
> 
> ### ** Examples
> 
> require(utils)
> 
> expand.grid(height = seq(60, 80, 5), weight = seq(100, 300, 50),
+             sex = c("Male","Female"))
   height weight    sex
1      60    100   Male
2      65    100   Male
3      70    100   Male
4      75    100   Male
5      80    100   Male
6      60    150   Male
7      65    150   Male
8      70    150   Male
9      75    150   Male
10     80    150   Male
11     60    200   Male
12     65    200   Male
13     70    200   Male
14     75    200   Male
15     80    200   Male
16     60    250   Male
17     65    250   Male
18     70    250   Male
19     75    250   Male
20     80    250   Male
21     60    300   Male
22     65    300   Male
23     70    300   Male
24     75    300   Male
25     80    300   Male
26     60    100 Female
27     65    100 Female
28     70    100 Female
29     75    100 Female
30     80    100 Female
31     60    150 Female
32     65    150 Female
33     70    150 Female
34     75    150 Female
35     80    150 Female
36     60    200 Female
37     65    200 Female
38     70    200 Female
39     75    200 Female
40     80    200 Female
41     60    250 Female
42     65    250 Female
43     70    250 Female
44     75    250 Female
45     80    250 Female
46     60    300 Female
47     65    300 Female
48     70    300 Female
49     75    300 Female
50     80    300 Female
> 
> x <- seq(0,10, length.out=100)
> y <- seq(-1,1, length.out=20)
> d1 <- expand.grid(x=x, y=y)
> d2 <- expand.grid(x=x, y=y, KEEP.OUT.ATTRS = FALSE)
> object.size(d1) - object.size(d2)
5992 bytes
> ##-> 5992 or 8832 (on 32- / 64-bit platform)
> ## Don't show: 
> stopifnot(object.size(d1) > object.size(d2))
> ## End Don't show
> 
> 
> 
> cleanEx()
> nameEx("expression")
> ### * expression
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expression
> ### Title: Unevaluated Expressions
> ### Aliases: expression is.expression as.expression as.expression.default
> ### Keywords: programming dplot
> 
> ### ** Examples
> 
> length(ex1 <- expression(1+ 0:9))# 1
[1] 1
> ex1
expression(1 + 0:9)
> eval(ex1)# 1:10
 [1]  1  2  3  4  5  6  7  8  9 10
> 
> length(ex3 <- expression(u,v, 1+ 0:9))# 3
[1] 3
> mode(ex3 [3]) # expression
[1] "expression"
> mode(ex3[[3]])# call
[1] "call"
> rm(ex3)
> 
> 
> 
> cleanEx()
> nameEx("factor")
> ### * factor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: factor
> ### Title: Factors
> ### Aliases: factor ordered is.factor is.ordered as.factor as.ordered
> ###   is.na<-.factor Math.factor Ops.factor Summary.factor Ops.ordered
> ###   Summary.ordered addNA
> ### Keywords: category NA
> 
> ### ** Examples
> 
> (ff <- factor(substring("statistics", 1:10, 1:10), levels=letters))
 [1] s t a t i s t i c s
Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z
> as.integer(ff)  # the internal codes
 [1] 19 20  1 20  9 19 20  9  3 19
> (f. <- factor(ff))# drops the levels that do not occur
 [1] s t a t i s t i c s
Levels: a c i s t
> ff[, drop=TRUE] # the same, more transparently
 [1] s t a t i s t i c s
Levels: a c i s t
> 
> factor(letters[1:20], labels="letter")
 [1] letter1  letter2  letter3  letter4  letter5  letter6  letter7  letter8 
 [9] letter9  letter10 letter11 letter12 letter13 letter14 letter15 letter16
[17] letter17 letter18 letter19 letter20
20 Levels: letter1 letter2 letter3 letter4 letter5 letter6 letter7 ... letter20
> 
> class(ordered(4:1)) # "ordered", inheriting from "factor"
[1] "ordered" "factor" 
> z <- factor(LETTERS[3:1], ordered = TRUE)
> ## and "relational" methods work:
> stopifnot(sort(z)[c(1,3)] == range(z), min(z) < max(z))
> ## Don't show: 
> of <- ordered(ff)
> stopifnot(identical(range(of, rev(of)), of[3:2]),
+ 	  identical(max(of), of[2]))
> ## End Don't show
> 
> ## suppose you want "NA" as a level, and to allow missing values.
> (x <- factor(c(1, 2, NA), exclude = NULL))
[1] 1    2    <NA>
Levels: 1 2 <NA>
> is.na(x)[2] <- TRUE
> x  # [1] 1    <NA> <NA>
[1] 1    <NA> <NA>
Levels: 1 2 <NA>
> is.na(x)
[1] FALSE  TRUE FALSE
> # [1] FALSE  TRUE FALSE
> 
> ## Using addNA()
> Month <- airquality$Month
> table(addNA(Month))

   5    6    7    8    9 <NA> 
  31   30   31   31   30    0 
> table(addNA(Month, ifany=TRUE))

 5  6  7  8  9 
31 30 31 31 30 
> 
> 
> 
> cleanEx()
> nameEx("file.access")
> ### * file.access
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file.access
> ### Title: Ascertain File Accessibility
> ### Aliases: file.access
> ### Keywords: file
> 
> ### ** Examples
> 
> fa <- file.access(dir("."))
> table(fa) # count successes & failures
fa
 0 
67 
> 
> 
> cleanEx()
> nameEx("file.info")
> ### * file.info
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file.info
> ### Title: Extract File Information
> ### Aliases: file.info
> ### Keywords: file
> 
> ### ** Examples
> 
> ncol(finf <- file.info(dir()))# at least six
[1] 10
> ## Not run: finf # the whole list
> ## Those that are more than 100 days old :
> finf[difftime(Sys.time(), finf[,"mtime"], units="days") > 100 , 1:4]
                         size isdir mode               mtime
datasets-Ex.Rout.save  106972 FALSE  644 2012-04-15 03:35:04
graphics-Ex.Rout.save   89268 FALSE  644 2012-03-03 04:35:05
grDevices-Ex.Rout.save  93688 FALSE  644 2012-04-14 03:35:06
grid-Ex.Rout.save       51000 FALSE  644 2012-03-03 04:35:05
Makefile.in              1946 FALSE  644 2011-11-02 04:35:10
Makefile.win             1020 FALSE  644 2011-10-16 03:35:04
splines-Ex.Rout.save    22670 FALSE  644 2012-04-10 03:35:02
stats4-Ex.Rout.save      4762 FALSE  644 2012-05-27 03:35:05
stats-Ex.Rout.save     507676 FALSE  644 2012-04-24 03:35:02
tools-Ex.Rout.save      24372 FALSE  644 2012-04-16 03:35:38
> 
> file.info("no-such-file-exists")
                    size isdir mode mtime ctime atime uid gid uname grname
no-such-file-exists   NA    NA <NA>  <NA>  <NA>  <NA>  NA  NA  <NA>   <NA>
> 
> 
> 
> cleanEx()
> nameEx("file.show")
> ### * file.show
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file.show
> ### Title: Display One or More Files
> ### Aliases: file.show
> ### Keywords: file
> 
> ### ** Examples
> 
> file.show(file.path(R.home("doc"), "COPYRIGHTS"))

COPYRIGHT STATUS

The bulk of this code is copyright by members of or all of the R Core
Team.

See the file COPYING for the exact conditions under which you may
redistribute it.  R as a whole is distributed under GPL version 2 or
3: most source files contain a copyright statement allowing use of
that file under GPL version 2 or later: the main exceptions are the
included versions of packages 'MASS', 'class', 'nnet', 'rpart' and
'spatial' (GPL-2 or GPL-3).

The status of files used only in the Windows port is in file
src/gnuwin32/COPYRIGHTS.win, which is appended to this file in binary
Windows distributions.

Note that all the code *is* copyright and may only be reproduced if
the copyright notice (that in the file or this notice) is preserved.

	---------------------------------------------------

Some (but not all) of the public header files are distributed under
the more permissive terms of version 2.1 or later of the LGPL: see
files R_HOME/share/licenses/LGPL-2.1 and R_HOME/share/licenses/LGPL-3.
This applies only to the header files

src/include/R.h
src/include/Rdefines.h
src/include/Rgraphics.h
src/include/Rinternals.h
src/include/Rmath.h
src/include/S.h
src/include/R_ext/*.h

Note that it does not apply to the header files such as Rembedded.h
and Rinterface.h used for third-party front ends.

From the announcement of the change (2001-Feb-05)

    It came to our attention that some projects are interpreting GPL to
    mean that compiling against the header files or linking against a
    Windows import library brings the compiled code under the scope of
    GPL.  This would mean it would be impossible to distribute binary
    versions of non-GPL packages with compiled code which called entry
    points in the R executable or DLL, of which there are many on CRAN.

    We encourage packages to be distributed under Open Source conditions,
    but accept that this is not possible for some contributions.  Our
    intention is that export files and import libraries be `accessors'
    under clause 5 of the LGPL, so that in most cases no (additional)
    restrictions are imposed by compiling a package using the LGPL-ed
    components of R.

    To avoid any anomalies, the versions of the same files in R versions
    1.0.0 to 1.2.1 may also be used under LGPL or GPL.

As from R 2.3.0 import libraries are no longer used under Windows, and
as from R 2.4.0 fewer export files are used under AIX.

Some contributed files are also covered by the Library General Public License.
These include (see also below)

src/library/stats/R/embed.R
src/library/stats/src/PPsum.c

	---------------------------------------------------




Some of the code contains different copyright statements.  It is used
here in accordance with the copyright conditions in that code.  A
not-necessarily-complete list of such files is:

src/library/grDevices/inst/afm/*___.afm

	Copyright (c) 1984 to 1992 Adobe Systems Incorporated.

src/library/grDevices/inst/afm/MustRead.html
src/library/grDevices/inst/afm/Courier*.afm
src/library/grDevices/inst/afm/Helvetica*.afm
src/library/grDevices/inst/afm/Times*.afm
src/library/grDevices/inst/afm/Symbol.afm
src/library/grDevices/inst/afm/ZapfDingbats.afm

	Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems
	Incorporated.  All Rights Reserved.

src/library/grDevices/inst/afm/*l.afm

	Copyright 1999 by (URW)++ Design & Development

src/library/grDevices/inst/afm/CM_*.afm
src/library/grDevices/inst/afm/cm*.afm

	are derived from afms which are copyright by the American
	Mathematical Society, but `the AMS does require that the
	AMS copyright notice be removed from any derivative versions
	of the fonts which have been altered in any way'.

doc/manual/R-intro.texi

in part

	Copyright (C) 1990 W. N. Venables
	Copyright (C) 1992 W. N. Venables & D. M. Smith
	Copyright (C) 1997 R. Gentleman & R. Ihaka
	Copyright (C) 1997, 1998 M. Maechler

shares/licenses/*

	See the individual files.

share/texmf/bibtex/bst/jss.bst

	Copyright 1994-2005 Patrick W Daly

share/texmf/tex/latex/jss.cls

	Copyright: (C) Achim Zeileis

share/texmf/tex/latex/upquote.sty

	Copyright 2000 Michael A. Covington.
	Copyright 2003 Michael A. Covington, Frank Mittelbach.

src/library/graphics/R/mosaicplot.R

	Original code copyright (C) 1998 John W. Emerson

src/library/graphics/R/pairs.R

	In part, Copyright 1999 Dr. Jens Oehlschlaegel-Akiyoshi

src/library/graphics/R/polygon.R

	Copyright (C) 2001 by Kevin Buhr <buhr@stat.wisc.edu>

src/library/splines/R/splineClasses.R

	Copyright (C) 1998 Douglas M. Bates and William N. Venables.

src/library/datasets/man/austres.Rd
src/library/datasets/man/beavers.Rd
src/library/datasets/man/lh.Rd
src/library/datasets/man/rock.Rd
src/library/datasets/man/UKLungDeaths.Rd
src/library/datasets/man/USAccDeaths.Rd
src/library/stats/R/bandwidths.R
src/library/stats/R/cpgram.R
src/library/stats/R/spectrum.R
src/library/stats/src//bandwidths.c
src/appl/maxcol.c

	Copyright (C) various dates W. N. Venables and B. D. Ripley


src/appl/interv.c : moved to API from code originally in
		    src/library/stats/src/bvalue.f, see
		    src/library/stats/COPYRIGHTS.modreg

src/library/stats:

	See the files src/library/stats/COPYRIGHTS.modreg and
	src/library/stats/COPYRIGHTS.portsrc for further details


src/library/stats/R/diffinv.R
src/library/stats/R/embed.R
src/library/stats/R/kernel.R
src/library/stats/src/PPsum.c

	Copyright (C) 1997-1999	 Adrian Trapletti


src/library/stats/src/carray.c, mburg.c, myw.c, qr.c

	Copyright (C) 1999 Martyn Plummer


src/library/stats/R/nls.R

	In part, Copyright 1999-1999 Saikat DebRoy


src/library/stats/R/nlsFunc.R
src/library/stats/R/selfStart.R
src/library/stats/R/zzModels.R

	Copyright 1997,1999 Jose C. Pinheiro

src/library/stats/R/runmed.R
src/library/stats/src/Trunmed.c

	In part Copyright (C) 1995 Berwin A. Turlach

src/library/stats/src/loessc.c
src/library/stats/src/loessf.f

	In part Copyright (c) 1989, 1992 by AT&T

src/library/tcltk/exec/{hierarchy,util*,widget}.tcl

	Copyright (c) various dates Jeffrey Hobbs


src/modules/X11/rotated.[ch]

	Copyright (c) 1993 Alan Richardson


src/appl/loglin.c
src/library/stats/src/chisqsim.c
src/library/stats/src/nscor.c
src/library/stats/src/prho.c
src/library/stats/src/swilk.c
src/library/stats/src/kmns.f
src/library/ts/src/starma.c
src/nmath/pgamma.c
src/nmath/pnbeta.c
src/nmath/pnchisq.c
src/nmath/pnt.c
src/nmath/qbeta.c
src/nmath/qgamma.c
src/nmath/qnorm.c
src/nmath/qtukey.c
src/nmath/sunif.c
  are based in whole or in part on Applied Statistics algorithms
  (C) Royal Statistical Society

src/nmath/stirlerr.c
src/nmath/dbinom.c
src/nmath/dpois.c
  are partly based on Clive Loader's (1999) work,
  (C) 1999-2000 Lucent Technologies, Bell Laboratories.


src/main/RNG.c

  The Mersenne-Twister part is
  Copyright (C) 1997, 1999 Makoto Matsumoto and Takuji Nishimura.


src/main/xspline.c

 * Copyright (c) 1985-1988 by Supoj Sutanthavibul
 * Parts Copyright (c) 1989-2002 by Brian V. Smith
 * Parts Copyright (c) 1991 by Paul King
 * Parts Copyright (c) 1992 by James Tough
 * Parts Copyright (c) 1998 by Georg Stemmer
 * Parts Copyright (c) 1995 by C. Blanc and C. Schlick
  
 * Any party obtaining a copy of these files is granted, free of charge, a
 * full and unrestricted irrevocable, world-wide, paid up, royalty-free,
 * nonexclusive right and license to deal in this software and
 * documentation files (the "Software"), including without limitation the
 * rights to use, copy, modify, merge, publish and/or distribute copies of
 * the Software, and to permit persons who receive copies from any such 
 * party to do so, with the only requirement being that this copyright 
 * notice remain intact.


src/modules/lapack/dlapack[0123].f, cmplx.f, dlamc.f

  Extracted from
  *  -- LAPACK routine (version 3.1) --
  *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
  *     Courant Institute, Argonne National Lab, and Rice University

  The README says

    It is freely-available software, and is copyrighted.

  although no actual copyright statement appears in the code.


src/extra/xdr/*

	Copyright (undated) Sun Microsystems, Inc.

	See the file src/extra/xdr/copyrght.txt


src/extra/zlib/README, *.c, *.h

  Taken from zlib-1.2.7 (C) 1995-2012 Jean-loup Gailly and Mark Adler
  See src/extra/zlib/README for the licence.

src/main/connections.c, src/main/gzio.h

  Contain code derived from the zlib 1.2.3 distribution
  (C) 1995-2005 Jean-loup Gailly and Mark Adler

src/main/dounzip.c, unzip.h

  Contain code Copyright (C) 1998-2010 Gilles Vollant from contrib/minizip
  in the zlib 1.2.3 distribution with updates taken from 1.2.5.


src/extra/pcre/LICENCE
src/extra/pcre/*.[ch]
src/main/valid_utf8.h

   Copyright (c) 1997-2012 University of Cambridge
   All rights reserved.
   Copyright(c) 2009-2012 Zoltan Herczeg

See file src/extra/pcre/LICENCE.  For binary builds of R that requires
us to include

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright notice,
	this list of conditions and the following disclaimer.

      * Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.

      * Neither the name of the University of Cambridge nor the name of Google
	Inc. nor the names of their contributors may be used to endorse or
	promote products derived from this software without specific prior
	written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.


src/extra/bzip2/LICENSE
src/extra/bzip2/blocksort.c
src/extra/bzip2/bzlib.c
src/extra/bzip2/bzlib.h
src/extra/bzip2/bzlib_private.h
src/extra/bzip2/compress.c
src/extra/bzip2/crctable.c
src/extra/bzip2/decompress.c
src/extra/bzip2/huffman.c
src/extra/bzip2/randtable.c

   copyright (C) 1996-2010 Julian R Seward.


src/extra/tre/LICENSE
src/extra/tre/*.[ch]

Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
All rights reserved.

From tre-0.8.0 (http://laurikari.net/tre/).  See file
src/extra/tre/LICENSE.  For binary builds of R that requires us to
include

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the name of Google
      Inc. nor the names of their contributors may be used to endorse or
      promote products derived from this software without specific prior
      written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.


src/library/tools/src/md5.[ch]

    Copyright (C) 1995, 1996, 2001 Free Software Foundation, Inc.


src/extra/intl/*

Based on gettextize from gettext 0.17
   Copyright (C) various dates Free Software Foundation, Inc.
   Distributed under the GNU Library General Public License
   version 2 or later.

src/include/memcheck.h
src/include/valgrind.h

From valgrind,

   Copyright (C) 2000-2005 Julian Seward.  All rights reserved.


src/main/mkdtemp.c

From glibc via
http://lists.gnu.org/archive/html/bug-gnulib/2003-02/msg00019.html

   Copyright (C) 1999, 2001-2003 Free Software Foundation, Inc.
   Distributed under the GNU Library General Public License
   version 2 or later.

src/main/Rstrptime.h

   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
   Distributed under the GNU Library General Public License
   version 2 or later.

po/*.po
src/library/*/po/*.po

   Some of the translations are (C) the translator as marked in the files.

COPYING
doc/COPYING
doc/COPYING.LIB
m4/codeset.m4
m4/gettext.m4
m4/gettext-lib.m4
share/licenses/GPL-2
share/licenses/GPL-3
share/licenses/LGPL-2
share/licenses/LGPL-2.1
share/licenses/LGPL-3
src/main/strdup.c
tools/config.quess
tools/config.rpath
tools/config.sub
tools/help2man.pl
tools/ltmain.sh
tools/mdate-sh
tools/missing

   Copyright various dates Free Software Foundation


tools/install-sh:

   Copyright (C) 1994 X Consortium


m4/stat-time.m4

From GNU coreutils 8.12
# Copyright (C) 1998-1999, 2001, 2003, 2005-2007, 2009-2011 Free Software
# Foundation, Inc.

# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

> 
> 
> 
> cleanEx()
> nameEx("files")
> ### * files
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: files
> ### Title: File Manipulation
> ### Aliases: files file.append file.copy file.create file.exists
> ###   file.remove file.rename file.symlink file.link
> ### Keywords: file
> 
> ### ** Examples
> 
> cat("file A\n", file="A")
> cat("file B\n", file="B")
> file.append("A", "B")
[1] TRUE
> file.create("A")
[1] TRUE
> file.append("A", rep("B", 10))
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> if(interactive()) file.show("A")
> file.copy("A", "C")
[1] TRUE
> dir.create("tmp")
> file.copy(c("A", "B"), "tmp")
[1] TRUE TRUE
> list.files("tmp")
[1] "A" "B"
> setwd("tmp")
> file.remove("B")
[1] TRUE
> file.symlink(file.path("..", c("A", "B")), ".")
Warning in file.symlink(file.path("..", c("A", "B")), ".") :
  cannot symlink '../A' to './A', reason 'File exists'
[1] FALSE  TRUE
> setwd("..")
> unlink("tmp", recursive=TRUE)
> file.remove("A", "B", "C")
[1] TRUE TRUE TRUE
> 
> 
> 
> cleanEx()
> nameEx("files2")
> ### * files2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: files2
> ### Title: Manipulaton of Directories and File Permissions
> ### Aliases: dir.create Sys.chmod Sys.umask umask
> ### Keywords: file
> 
> ### ** Examples
> ## Not run: 
> ##D ## Fix up maximal allowed permissions in a file tree
> ##D Sys.chmod(list.dirs("."), "777")
> ##D f <- list.files(".", all.files = TRUE, full.names = TRUE, recursive = TRUE)
> ##D Sys.chmod(f, (file.info(f)$mode | "664"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("findInterval")
> ### * findInterval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findInterval
> ### Title: Find Interval Numbers or Indices
> ### Aliases: findInterval
> ### Keywords: arith utilities
> 
> ### ** Examples
> 
> N <- 100
> X <- sort(round(stats::rt(N, df=2), 2))
> tt <- c(-100, seq(-2,2, len=201), +100)
> it <- findInterval(tt, X)
> tt[it < 1 | it >= N] # only first and last are outside range(X)
[1] -100  100
> 
> 
> 
> cleanEx()
> nameEx("force")
> ### * force
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: force
> ### Title: Force Evaluation of an Argument
> ### Aliases: force
> ### Keywords: data programming
> 
> ### ** Examples
> 
> f <- function(y) function() y
> lf <- vector("list", 5)
> for (i in seq_along(lf)) lf[[i]] <- f(i)
> lf[[1]]()  # returns 5
[1] 5
> 
> g <- function(y) { force(y); function() y }
> lg <- vector("list", 5)
> for (i in seq_along(lg)) lg[[i]] <- g(i)
> lg[[1]]()  # returns 1
[1] 1
> 
> ## This is identical to
> g <- function(y) { y; function() y }
> 
> 
> 
> cleanEx()
> nameEx("formals")
> ### * formals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: formals
> ### Title: Access to and Manipulation of the Formal Arguments
> ### Aliases: formals formals<-
> ### Keywords: programming
> 
> ### ** Examples
> 
> require(stats); require(graphics)
> length(formals(lm))      # the number of formal arguments
[1] 14
> names(formals(boxplot))  # formal arguments names
[1] "x"   "..."
> 
> f <- function(x) a+b
> formals(f) <- alist(a=,b=3) # function(a,b=3)a+b
> f(2) # result = 5
[1] 5
> 
> 
> 
> cleanEx()
> nameEx("format")
> ### * format
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format
> ### Title: Encode in a Common Format
> ### Aliases: format format.AsIs format.data.frame format.default
> ###   format.factor
> ### Keywords: character print
> 
> ### ** Examples
> 
> format(1:10)
 [1] " 1" " 2" " 3" " 4" " 5" " 6" " 7" " 8" " 9" "10"
> format(1:10, trim = TRUE)
 [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10"
> 
> zz <- data.frame("(row names)"= c("aaaaa", "b"), check.names=FALSE)
> format(zz)
  (row names)
1       aaaaa
2           b
> format(zz, justify = "left")
  (row names)
1       aaaaa
2       b    
> 
> ## use of nsmall
> format(13.7)
[1] "13.7"
> format(13.7, nsmall = 3)
[1] "13.700"
> format(c(6.0, 13.1), digits = 2)
[1] " 6" "13"
> format(c(6.0, 13.1), digits = 2, nsmall = 1)
[1] " 6.0" "13.1"
> 
> ## use of scientific
> format(2^31-1)
[1] "2147483647"
> format(2^31-1, scientific = TRUE)
[1] "2.147484e+09"
> 
> ## a list
> z <- list(a=letters[1:3], b=(-pi+0i)^((-2:2)/2), c=c(1,10,100,1000),
+           d=c("a", "longer", "character", "string"))
> format(z, digits = 2)
                                                             a 
                                                     "a, b, c" 
                                                             b 
"-0.32+0.00i, 0.00-0.56i, 1.00+0.00i, 0.00+1.77i, -3.14+0.00i" 
                                                             c 
                                            "1, 10, 100, 1000" 
                                                             d 
                  "a        , longer   , character, string   " 
> format(z, digits = 2, justify = "left", trim = FALSE)
                                                                a 
                                                        "a, b, c" 
                                                                b 
"-0.32+0.00i,  0.00-0.56i,  1.00+0.00i,  0.00+1.77i, -3.14+0.00i" 
                                                                c 
                                         "   1,   10,  100, 1000" 
                                                                d 
                     "a        , longer   , character, string   " 
> 
> 
> 
> cleanEx()
> nameEx("format.info")
> ### * format.info
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format.info
> ### Title: format(.) Information
> ### Aliases: format.info
> ### Keywords: character print programming
> 
> ### ** Examples
> 
> dd <- options("digits") ; options(digits = 7) #-- for the following
> format.info(123)   # 3 0 0
[1] 3 0 0
> format.info(pi)    # 8 6 0
[1] 8 6 0
> format.info(1e8)   # 5 0 1 - exponential "1e+08"
[1] 5 0 1
> format.info(1e222) # 6 0 2 - exponential "1e+222"
[1] 6 0 2
> 
> x <- pi*10^c(-10,-2,0:2,8,20)
> names(x) <- formatC(x, width=1, digits=3, format="g")
> cbind(sapply(x,format))
         [,1]          
3.14e-10 "3.141593e-10"
0.0314   "0.03141593"  
3.14     "3.141593"    
31.4     "31.41593"    
314      "314.1593"    
3.14e+08 "314159265"   
3.14e+20 "3.141593e+20"
> t(sapply(x, format.info))
         [,1] [,2] [,3]
3.14e-10   12    6    1
0.0314     10    8    0
3.14        8    6    0
31.4        8    5    0
314         8    4    0
3.14e+08    9    0    0
3.14e+20   12    6    1
> 
> ## using at least 8 digits right of "."
> t(sapply(x, format.info, nsmall = 8))
         [,1] [,2] [,3]
3.14e-10   12    6    1
0.0314     10    8    0
3.14       10    8    0
31.4       11    8    0
314        12    8    0
3.14e+08   18    8    0
3.14e+20   12    6    1
> 
> # Reset old options:
> options(dd)
> 
> 
> 
> cleanEx()
> nameEx("format.pval")
> ### * format.pval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format.pval
> ### Title: Format P Values
> ### Aliases: format.pval
> ### Keywords: print
> 
> ### ** Examples
> 
> format.pval(c(stats::runif(5), pi^-100, NA))
[1] "0.26551" "0.37212" "0.57285" "0.90821" "0.20168" "< 2e-16" "NA"     
> format.pval(c(0.1, 0.0001, 1e-27))
[1] "1e-01"  "1e-04"  "<2e-16"
> 
> 
> 
> cleanEx()
> nameEx("formatDL")
> ### * formatDL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: formatDL
> ### Title: Format Description Lists
> ### Aliases: formatDL
> ### Keywords: print
> 
> ### ** Examples
> ## Not run: 
> ##D 
> ##D ## Use R to create the 'INDEX' for package 'splines' from its 'CONTENTS'
> ##D x <- read.dcf(file = system.file("CONTENTS", package = "splines"),
> ##D                fields = c("Entry", "Description"))
> ##D x <- as.data.frame(x)
> ##D writeLines(formatDL(x$Entry, x$Description))
> ##D ## or equivalently: writeLines(formatDL(x))
> ##D ## Same information in tagged description list style:
> ##D writeLines(formatDL(x$Entry, x$Description, style = "list"))
> ##D ## or equivalently: writeLines(formatDL(x, style = "list"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("formatc")
> ### * formatc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: formatC
> ### Title: Formatting Using C-style Formats
> ### Aliases: formatC prettyNum
> ### Keywords: character print
> 
> ### ** Examples
> 
> xx  <- pi * 10^(-5:4)
> cbind(format(xx, digits=4), formatC(xx))
      [,1]        [,2]       
 [1,] "3.142e-05" "3.142e-05"
 [2,] "3.142e-04" "0.0003142"
 [3,] "3.142e-03" "0.003142" 
 [4,] "3.142e-02" "0.03142"  
 [5,] "3.142e-01" "0.3142"   
 [6,] "3.142e+00" "3.142"    
 [7,] "3.142e+01" "31.42"    
 [8,] "3.142e+02" "314.2"    
 [9,] "3.142e+03" "3142"     
[10,] "3.142e+04" "3.142e+04"
> cbind(formatC(xx, width = 9, flag = "-"))
      [,1]       
 [1,] "3.142e-05"
 [2,] "0.0003142"
 [3,] "0.003142 "
 [4,] "0.03142  "
 [5,] "0.3142   "
 [6,] "3.142    "
 [7,] "31.42    "
 [8,] "314.2    "
 [9,] "3142     "
[10,] "3.142e+04"
> cbind(formatC(xx, digits = 5, width = 8, format = "f", flag = "0"))
      [,1]         
 [1,] "00.00003"   
 [2,] "00.00031"   
 [3,] "00.00314"   
 [4,] "00.03142"   
 [5,] "00.31416"   
 [6,] "03.14159"   
 [7,] "31.41593"   
 [8,] "314.15927"  
 [9,] "3141.59265" 
[10,] "31415.92654"
> cbind(format(xx, digits=4), formatC(xx, digits = 4, format = "fg"))
      [,1]        [,2]        
 [1,] "3.142e-05" "0.00003142"
 [2,] "3.142e-04" "0.0003142" 
 [3,] "3.142e-03" "0.003142"  
 [4,] "3.142e-02" "0.03142"   
 [5,] "3.142e-01" "0.3142"    
 [6,] "3.142e+00" "3.142"     
 [7,] "3.142e+01" "31.42"     
 [8,] "3.142e+02" "314.2"     
 [9,] "3.142e+03" " 3142"     
[10,] "3.142e+04" "31416"     
> 
> formatC(    c("a", "Abc", "no way"), width = -7)  # <=> flag = "-"
[1] "a      " "Abc    " "no way "
> formatC(c((-1:1)/0,c(1,100)*pi), width=8, digits=1)
[1] "    -Inf" "     NaN" "     Inf" "       3" "   3e+02"
> 
> xx <- c(1e-12,-3.98765e-10,1.45645e-69,1e-70,pi*1e37,3.44e4)
> ##       1        2             3        4      5       6
> formatC(xx)
[1] "1e-12"      "-3.988e-10" "1.456e-69"  "1e-70"      "3.142e+37" 
[6] "3.44e+04"  
> formatC(xx, format="fg")       # special "fixed" format.
[1] "0.000000000001"                                                            
[2] "-0.0000000003988"                                                          
[3] "0.000000000000000000000000000000000000000000000000000000000000000000001456"
[4] "0.0000000000000000000000000000000000000000000000000000000000000000000001"  
[5] "31415926535897927981986333033020522496"                                    
[6] "34400"                                                                     
> formatC(xx[1:4], format="f", digits=75) #>> even longer strings
[1] "0.000000000000999999999999999979886647629255615367252843506129522666014963761" 
[2] "-0.000000000398765000000000018320637518040800220675556886362755903974175453186"
[3] "0.000000000000000000000000000000000000000000000000000000000000000000001456450" 
[4] "0.000000000000000000000000000000000000000000000000000000000000000000000100000" 
> 
> formatC(c(3.24, 2.3e-6), format="f", digits=11, drop0trailing=TRUE)
[1] "3.24"      "0.0000023"
> 
> r <- c("76491283764.97430", "29.12345678901", "-7.1234", "-100.1","1123")
> ## American:
> prettyNum(r, big.mark = ",")
[1] "76,491,283,764.97430" "      29.12345678901" "             -7.1234"
[4] "              -100.1" "               1,123"
> ## Some Europeans:
> prettyNum(r, big.mark = "'", decimal.mark = ",")
[1] "76'491'283'764,97430" "      29,12345678901" "             -7,1234"
[4] "              -100,1" "               1'123"
> 
> (dd <- sapply(1:10, function(i)paste((9:0)[1:i],collapse="")))
 [1] "9"          "98"         "987"        "9876"       "98765"     
 [6] "987654"     "9876543"    "98765432"   "987654321"  "9876543210"
> prettyNum(dd, big.mark="'")
 [1] "            9" "           98" "          987" "        9'876"
 [5] "       98'765" "      987'654" "    9'876'543" "   98'765'432"
 [9] "  987'654'321" "9'876'543'210"
> 
> ## examples of 'small.mark'
> pN <- stats::pnorm(1:7, lower.tail = FALSE)
> cbind(format (pN, small.mark = " ", digits = 15))
     [,1]                    
[1,] "1.58655 25393 1457e-01"
[2,] "2.27501 31948 1792e-02"
[3,] "1.34989 80316 3009e-03"
[4,] "3.16712 41833 1199e-05"
[5,] "2.86651 57187 9194e-07"
[6,] "9.86587 64503 7698e-10"
[7,] "1.27981 25438 8584e-12"
> cbind(formatC(pN, small.mark = " ", digits = 17, format = "f"))
     [,1]                    
[1,] "0.15865 52539 31457 05"
[2,] "0.02275 01319 48179 21"
[3,] "0.00134 98980 31630 09"
[4,] "0.00003 16712 41833 12"
[5,] "0.00000 02866 51571 88"
[6,] "0.00000 00009 86587 65"
[7,] "0.00000 00000 01279 81"
> 
> cbind(ff <- format(1.2345 + 10^(0:5), width = 11, big.mark = "'"))
     [,1]          
[1,] "      2.2345"
[2,] "     11.2345"
[3,] "    101.2345"
[4,] "  1'001.2345"
[5,] " 10'001.2345"
[6,] "100'001.2345"
> ## all with same width (one more than the specified minimum)
> 
> ## individual formatting to common width:
> fc <- formatC(1.234 + 10^(0:8), format="fg", width=11, big.mark = "'")
> cbind(fc)
      fc           
 [1,] "      2.234"
 [2,] "      11.23"
 [3,] "      101.2"
 [4,] "      1'001"
 [5,] "     10'001"
 [6,] "    100'001"
 [7,] "  1'000'001"
 [8,] " 10'000'001"
 [9,] "100'000'001"
> 
> ## complex numbers:
> r <- 10.0000001; rv <- (r/10)^(1:10)
> (zv <- (rv + 1i*rv))
 [1] 1+1i 1+1i 1+1i 1+1i 1+1i 1+1i 1+1i 1+1i 1+1i 1+1i
> op <- options(digits=7) ## (system default)
> (pnv <- prettyNum(zv))
 [1] "1+1i" "1+1i" "1+1i" "1+1i" "1+1i" "1+1i" "1+1i" "1+1i" "1+1i" "1+1i"
> stopifnot(pnv == "1+1i", pnv == format(zv),
+           pnv == prettyNum(zv, drop0trailing=TRUE))
> ## more digits change the picture:
> options(digits=8)
> head(fv <- format(zv), 3)
[1] "1.0000000+1.0000000i" "1.0000000+1.0000000i" "1.0000000+1.0000000i"
> prettyNum(fv)
 [1] "1.0000000+1.0000000i" "1.0000000+1.0000000i" "1.0000000+1.0000000i"
 [4] "1.0000000+1.0000000i" "1.0000001+1.0000001i" "1.0000001+1.0000001i"
 [7] "1.0000001+1.0000001i" "1.0000001+1.0000001i" "1.0000001+1.0000001i"
[10] "1.0000001+1.0000001i"
> prettyNum(fv, drop0trailing=TRUE) # a bit nicer
 [1] "1+1i"                 "1+1i"                 "1+1i"                
 [4] "1+1i"                 "1.0000001+1.0000001i" "1.0000001+1.0000001i"
 [7] "1.0000001+1.0000001i" "1.0000001+1.0000001i" "1.0000001+1.0000001i"
[10] "1.0000001+1.0000001i"
> options(op)
> 
> 
> 
> cleanEx()
> nameEx("function")
> ### * function
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: function
> ### Title: Function Definition
> ### Aliases: function return closure
> ### Keywords: programming
> 
> ### ** Examples
> 
> norm <- function(x) sqrt(x%*%x)
> norm(1:4)
         [,1]
[1,] 5.477226
> 
> ## An anonymous function:
> (function(x,y){ z <- x^2 + y^2; x+y+z })(0:7, 1)
[1]  2  4  8 14 22 32 44 58
> 
> 
> 
> cleanEx()
> nameEx("funprog")
> ### * funprog
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: funprog
> ### Title: Common Higher-Order Functions in Functional Programming
> ###   Languages
> ### Aliases: Filter Find Map Negate Reduce Position
> ### Keywords: programming
> 
> ### ** Examples
> 
> ## A general-purpose adder:
> add <- function(x) Reduce("+", x)
> add(list(1, 2, 3))
[1] 6
> ## Like sum(), but can also used for adding matrices etc., as it will
> ## use the appropriate '+' method in each reduction step.
> ## More generally, many generics meant to work on arbitrarily many
> ## arguments can be defined via reduction:
> FOO <- function(...) Reduce(FOO2, list(...))
> FOO2 <- function(x, y) UseMethod("FOO2")
> ## FOO() methods can then be provided via FOO2() methods.
> 
> ## A general-purpose cumulative adder:
> cadd <- function(x) Reduce("+", x, accumulate = TRUE)
> cadd(seq_len(7))
[1]  1  3  6 10 15 21 28
> 
> ## A simple function to compute continued fractions:
> cfrac <- function(x) Reduce(function(u, v) u + 1 / v, x, right = TRUE)
> ## Continued fraction approximation for pi:
> cfrac(c(3, 7, 15, 1, 292))
[1] 3.141593
> ## Continued fraction approximation for Euler's number (e):
> cfrac(c(2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8))
[1] 2.718282
> 
> ## Iterative function application:
> Funcall <- function(f, ...) f(...)
> ## Compute log(exp(acos(cos(0))
> Reduce(Funcall, list(log, exp, acos, cos), 0, right = TRUE)
[1] 0
> ## n-fold iterate of a function, functional style:
> Iterate <- function(f, n = 1)
+     function(x) Reduce(Funcall, rep.int(list(f), n), x, right = TRUE)
> ## Continued fraction approximation to the golden ratio:
> Iterate(function(x) 1 + 1 / x, 30)(1)
[1] 1.618034
> ## which is the same as
> cfrac(rep.int(1, 31))
[1] 1.618034
> ## Computing square root approximations for x as fixed points of the
> ## function t |-> (t + x / t) / 2, as a function of the initial value:
> asqrt <- function(x, n) Iterate(function(t) (t + x / t) / 2, n)
> asqrt(2, 30)(10) # Starting from a positive value => +sqrt(2)
[1] 1.414214
> asqrt(2, 30)(-1) # Starting from a negative value => -sqrt(2)
[1] -1.414214
> 
> ## A list of all functions in the base environment:
> funs <- Filter(is.function, sapply(ls(baseenv()), get, baseenv()))
> ## Functions in base with more than 10 arguments:
> names(Filter(function(f) length(formals(args(f))) > 10, funs))
[1] "formatC"          "format.default"   "merge.data.frame" "prettyNum"       
[5] "scan"             "source"          
> ## Number of functions in base with a '...' argument:
> length(Filter(function(f)
+               any(names(formals(args(f))) %in% "..."),
+               funs))
[1] 419
> 
> 
> cleanEx()
> nameEx("gc")
> ### * gc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gc
> ### Title: Garbage Collection
> ### Aliases: gc gcinfo
> ### Keywords: environment
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("gc.time")
> ### * gc.time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gc.time
> ### Title: Report Time Spent in Garbage Collection
> ### Aliases: gc.time
> ### Keywords: utilities
> 
> ### ** Examples
> 
> gc.time()
[1] 0 0 0 0 0
> 
> 
> 
> cleanEx()
> nameEx("get")
> ### * get
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get
> ### Title: Return the Value of a Named Object
> ### Aliases: get mget
> ### Keywords: data
> 
> ### ** Examples
> 
> get("%o%")
function (X, Y) 
outer(X, Y)
<bytecode: 0x9e8b454>
<environment: namespace:base>
> 
> ##test mget
> e1 <- new.env()
> mget(letters, e1, ifnotfound = as.list(LETTERS))
$a
[1] "A"

$b
[1] "B"

$c
[1] "C"

$d
[1] "D"

$e
[1] "E"

$f
[1] "F"

$g
[1] "G"

$h
[1] "H"

$i
[1] "I"

$j
[1] "J"

$k
[1] "K"

$l
[1] "L"

$m
[1] "M"

$n
[1] "N"

$o
[1] "O"

$p
[1] "P"

$q
[1] "Q"

$r
[1] "R"

$s
[1] "S"

$t
[1] "T"

$u
[1] "U"

$v
[1] "V"

$w
[1] "W"

$x
[1] "X"

$y
[1] "Y"

$z
[1] "Z"

> 
> 
> 
> cleanEx()
> nameEx("getCallingDLL")
> ### * getCallingDLL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getCallingDLL
> ### Title: Compute DLL for Native Interface Call
> ### Aliases: getCallingDLL getCallingDLLe
> ### Keywords: internal
> 
> ### ** Examples
> 
> if(exists("ansari.test"))
+    getCallingDLL(ansari.test)
DLL name: stats
Filename: /usr/local/R-2.15.1/library/stats/libs/stats.so
Dynamic lookup: FALSE
> 
> 
> 
> cleanEx()
> nameEx("getDLLRegisteredRoutines")
> ### * getDLLRegisteredRoutines
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getDLLRegisteredRoutines
> ### Title: Reflectance Information for C/Fortran routines in a DLL
> ### Aliases: getDLLRegisteredRoutines getDLLRegisteredRoutines.character
> ###   getDLLRegisteredRoutines.DLLInfo print.NativeRoutineList
> ###   print.DLLRegisteredRoutines
> ### Keywords: interface
> 
> ### ** Examples
> 
> dlls <- getLoadedDLLs()
> getDLLRegisteredRoutines(dlls[["base"]])
                .C .C.numParameters                   .Call .Call.numParameters
1           bakslv                9                  La_svd                   7
2          bincode                8                   La_rs                   2
3         bincount                8                   La_rg                   2
4         R_cumsum                4               La_dlange                   2
5  find_interv_vec                7               La_dgecon                   2
6        R_max_col                5               La_dtrcon                   2
7         R_pretty                7               La_zgecon                   2
8         R_rowsum                4               La_ztrcon                   2
9         stemleaf                5                La_zgesv                   2
10      str_signif                8               La_zgeqp3                   1
11      R_tabulate                4           qr_coef_cmplx                   2
12    Rsockconnect                2             qr_qy_cmplx                   3
13       Rsockopen                1            La_svd_cmplx                   6
14     Rsocklisten                3             La_rs_cmplx                   2
15      Rsockclose                1             La_rg_cmplx                   2
16       Rsockread                3             La_chol2inv                   2
17      Rsockwrite                5                 La_chol                   1
18   signrank_free                0                La_dgesv                   3
19     wilcox_free                0               La_dgeqp3                   1
20                                             qr_coef_real                   2
21                                               qr_qy_real                   3
22                                              det_ge_real                   2
23                                           Rrowsum_matrix                   5
24                                               Rrowsum_df                   5
25                                   R_getTaskCallbackNames                   0
26                                     R_removeTaskCallback                   1
27                                        R_addTaskCallback                   4
28                                          R_getSymbolInfo                   3
29                                            R_getDllTable                   0
30                                  R_getRegisteredRoutines                   1
31                                                do_mapply                   4
32                                               R_r2dtable                   3
33                                          R_shortRowNames                   2
34                                             R_copyDFattr                   2
35                                    R_isMethodsDispatchOn                   1
36                                             R_traceOnOff                   1
37                                             R_isS4Object                   1
38                                            R_setS4Object                   3
39                                          R_do_new_object                   1
40                                           R_get_primname                   1
41                                              R_compress1                   1
42                                            R_decompress1                   1
43                                             R_serializeb                   5
44                                              R_serialize                   5
45                                            R_unserialize                   2
46                                            R_setFileTime                   2
47                                       R_getVarsFromFrame                   3
48                                  R_lazyLoadDBinsertValue                   5
49                                        R_lazyLoadDBflush                   1
50                                        R_getbcprofcounts                   0
51                                            R_startbcprof                   0
52                                             R_stopbcprof                   0
53                                            Rg_contourDef                   0
54                                               bitwiseNot                   1
55                                               bitwiseAnd                   2
56                                                bitwiseOr                   2
57                                               bitwiseXor                   2
58                                            crc64ToString                   1
   .Fortran .Fortran.numParameters  .External .External.numParameters
1    ch2inv                     -1 call_dqags                       7
2      chol                     -1 call_dqagi                       7
3        cg                     -1                                   
4        ch                     -1                                   
5        rg                     -1                                   
6        rs                     -1                                   
7     dchdc                     -1                                   
8     dpbfa                     -1                                   
9     dpbsl                     -1                                   
10    dpoco                     -1                                   
11    dpodi                     -1                                   
12    dpofa                     -1                                   
13    dposl                     -1                                   
14    dqrcf                     -1                                   
15    dqrdc                     -1                                   
16   dqrdc2                     -1                                   
17    dqrls                     -1                                   
18    dqrsl                     -1                                   
19   dqrqty                     -1                                   
20    dqrqy                     -1                                   
21   dqrrsd                     -1                                   
22    dqrsl                     -1                                   
23    dqrxb                     -1                                   
24    dsvdc                     -1                                   
25    dtrsl                     -1                                   
26    dtrco                     -1                                   
27                                                                   
28                                                                   
29                                                                   
30                                                                   
31                                                                   
32                                                                   
33                                                                   
34                                                                   
35                                                                   
36                                                                   
37                                                                   
38                                                                   
39                                                                   
40                                                                   
41                                                                   
42                                                                   
43                                                                   
44                                                                   
45                                                                   
46                                                                   
47                                                                   
48                                                                   
49                                                                   
50                                                                   
51                                                                   
52                                                                   
53                                                                   
54                                                                   
55                                                                   
56                                                                   
57                                                                   
58                                                                   
> 
> getDLLRegisteredRoutines("stats")
                .C .C.numParameters               .Call .Call.numParameters
1         chisqsim               11            R_cutree                   2
2       fisher_sim               10            R_isoreg                   1
3           d2x2xk                5          R_monoFC_m                   2
4          dansari                4       numeric_deriv                   4
5           fexact               11            nls_iter                   3
6          pansari                4        setup_starma                   8
7    pkolmogorov2x                2         free_starma                   1
8         pkendall                3           set_trans                   2
9           pkstwo                3             arma0fa                   2
10            prho                5              get_s2                   1
11      psmirnov2x                3           get_resid                   1
12         qansari                4             Dotrans                   2
13           swilk                9         arma0_kfore                   4
14      BDRksmooth                8       Starma_method                   2
15       loess_raw               24            Invtrans                   2
16      loess_dfit               13           Gradtrans                   2
17    loess_dfitse               16            ARMAtoMA                   3
18      loess_ifit                8          KalmanLike                  11
19       loess_ise               15          KalmanFore                   8
20         Srunmed                6        KalmanSmooth                   9
21         Trunmed                9      ARIMA_undoPars                   2
22        Rsm_3RSR                5     ARIMA_transPars                   3
23        Rsm_3RSS                5      ARIMA_Invtrans                   2
24       Rsm_3RS3R                5     ARIMA_Gradtrans                   2
25          Rsm_3R                5          ARIMA_Like                   9
26           Rsm_3                5           ARIMA_CSS                   6
27           Rsm_S                5              TSconv                   2
28       tukeyline                6               getQ0                   2
29          dblcen                2          port_ivset                   3
30      R_distance                7         port_nlminb                   9
31             acf                6           port_nlsb                   7
32        uni_pacf                3          logit_link                   1
33          artoma                4       logit_linkinv                   1
34            burg                6        logit_mu_eta                   1
35      multi_burg               11 binomial_dev_resids                   3
36        multi_yw               10          R_rWishart                   3
37    R_intgrt_vec                4              Cdqrls                   3
38         filter1                7               Cdist                   4
39         filter2                5                                        
40        R_pp_sum                4                                        
41     HoltWinters               17                                        
42    kmeans_Lloyd                9                                        
43 kmeans_MacQueen                9                                        
44        R_approx                9                                        
45     R_approxfun                9                                        
46    R_approxtest                5                                        
47    band_ucv_bin                6                                        
48    band_bcv_bin                6                                        
49   band_phi4_bin                6                                        
50   band_phi6_bin                6                                        
51    band_den_bin                5                                        
52          loglin               17                                        
53          lowess                9                                        
54        massdist                7                                        
55     spline_coef                8                                        
56     spline_eval               10                                        
   .Fortran .Fortran.numParameters .External .External.numParameters
1    lowesw                      4                                  
2    lowesp                      7                                  
3    setppr                      6                                  
4     smart                     16                                  
5    pppred                      5                                  
6    setsmu                      0                                  
7    qsbart                     21                                  
8    bvalus                      7                                  
9    supsmu                     10                                  
10   hclust                     11                                  
11   hcass2                      6                                  
12     kmns                     17                                  
13   eureka                      6                                  
14      stl                     18                                  
15   lminfl                     11                                  
16                                                                  
17                                                                  
18                                                                  
19                                                                  
20                                                                  
21                                                                  
22                                                                  
23                                                                  
24                                                                  
25                                                                  
26                                                                  
27                                                                  
28                                                                  
29                                                                  
30                                                                  
31                                                                  
32                                                                  
33                                                                  
34                                                                  
35                                                                  
36                                                                  
37                                                                  
38                                                                  
39                                                                  
40                                                                  
41                                                                  
42                                                                  
43                                                                  
44                                                                  
45                                                                  
46                                                                  
47                                                                  
48                                                                  
49                                                                  
50                                                                  
51                                                                  
52                                                                  
53                                                                  
54                                                                  
55                                                                  
56                                                                  
> 
> 
> 
> cleanEx()
> nameEx("getLoadedDLLs")
> ### * getLoadedDLLs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getLoadedDLLs
> ### Title: Get DLLs Loaded in Current Session
> ### Aliases: getLoadedDLLs print.DLLInfo print.DLLInfoList $.DLLInfo
> ###   DLLInfo DLLInfoList
> ### Keywords: interface
> 
> ### ** Examples
> 
> getLoadedDLLs()
                                                         Filename
base                                                         base
methods       /usr/local/R-2.15.1/library/methods/libs/methods.so
grDevices /usr/local/R-2.15.1/library/grDevices/libs/grDevices.so
stats             /usr/local/R-2.15.1/library/stats/libs/stats.so
splines       /usr/local/R-2.15.1/library/splines/libs/splines.so
lapack                     /usr/local/R-2.15.1/modules//lapack.so
R_X11                       /usr/local/R-2.15.1/modules//R_X11.so
          Dynamic.Lookup
base               FALSE
methods            FALSE
grDevices          FALSE
stats              FALSE
splines            FALSE
lapack              TRUE
R_X11               TRUE
> 
> 
> 
> cleanEx()
> nameEx("getNativeSymbolInfo")
> ### * getNativeSymbolInfo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getNativeSymbolInfo
> ### Title: Obtain a Description of one or more Native (C/Fortran) Symbols
> ### Aliases: getNativeSymbolInfo NativeSymbolInfo NativeSymbol
> ###   RegisteredNativeSymbol
> ### Keywords: interface
> 
> ### ** Examples
> 
> library(stats) # normally loaded
> getNativeSymbolInfo("dansari")
$name
[1] "dansari"

$address
<pointer: 0x40c19740>
attr(,"class")
[1] "NativeSymbol"

$package
DLL name: stats
Filename: /usr/local/R-2.15.1/library/stats/libs/stats.so
Dynamic lookup: FALSE

$numParameters
[1] 4

attr(,"class")
[1] "CRoutine"         "NativeSymbolInfo"
> 
> getNativeSymbolInfo("hcass2")  # a Fortran symbol
$name
[1] "hcass2"

$address
<pointer: 0x40c50be0>
attr(,"class")
[1] "NativeSymbol"

$package
DLL name: stats
Filename: /usr/local/R-2.15.1/library/stats/libs/stats.so
Dynamic lookup: FALSE

$numParameters
[1] 6

attr(,"class")
[1] "FortranRoutine"   "NativeSymbolInfo"
> 
> 
> 
> cleanEx()
> nameEx("gettext")
> ### * gettext
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gettext
> ### Title: Translate Text Messages
> ### Aliases: gettext ngettext bindtextdomain
> ### Keywords: utilities character
> 
> ### ** Examples
> 
> bindtextdomain("R")  # non-null if and only if NLS is enabled
[1] "/usr/local/R-2.15.1/share/locale"
> 
> for(n in 0:3)
+     print(sprintf(ngettext(n, "%d variable has missing values",
+                               "%d variables have missing values"),
+                   n))
[1] "0 variables have missing values"
[1] "1 variable has missing values"
[1] "2 variables have missing values"
[1] "3 variables have missing values"
> 
> ## Not run: 
> ##D ## for translation, those strings should appear in R-pkg.pot as
> ##D msgid        "%d variable has missing values"
> ##D msgid_plural "%d variables have missing values"
> ##D msgstr[0] ""
> ##D msgstr[1] ""
> ## End(Not run)
> 
> miss <- c("one", "or", "another")
> cat(ngettext(length(miss), "variable", "variables"),
+     paste(sQuote(miss), collapse=", "),
+     ngettext(length(miss), "contains", "contain"), "missing values\n")
variables ‘one’, ‘or’, ‘another’ contain missing values
> 
> ## better for translators would be to use
> cat(sprintf(ngettext(length(miss),
+                      "variable %s contains missing values\n",
+                      "variables %s contain missing values\n"),
+             paste(sQuote(miss), collapse=", ")))
variables ‘one’, ‘or’, ‘another’ contain missing values
> 
> 
> 
> cleanEx()
> nameEx("getwd")
> ### * getwd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getwd
> ### Title: Get or Set Working Directory
> ### Aliases: getwd setwd
> ### Keywords: utilities
> 
> ### ** Examples
> 
> (WD <- getwd())
[1] "/usr/local/R-2.15.1/tests/Examples"
> if (!is.null(WD)) setwd(WD)
> 
> 
> 
> cleanEx()
> nameEx("gl")
> ### * gl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gl
> ### Title: Generate Factor Levels
> ### Aliases: gl
> ### Keywords: category arith
> 
> ### ** Examples
> 
> ## First control, then treatment:
> gl(2, 8, labels = c("Control", "Treat"))
 [1] Control Control Control Control Control Control Control Control Treat  
[10] Treat   Treat   Treat   Treat   Treat   Treat   Treat  
Levels: Control Treat
> ## 20 alternating 1s and 2s
> gl(2, 1, 20)
 [1] 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2
Levels: 1 2
> ## alternating pairs of 1s and 2s
> gl(2, 2, 20)
 [1] 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2
Levels: 1 2
> 
> 
> 
> cleanEx()
> nameEx("grep")
> ### * grep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: grep
> ### Title: Pattern Matching and Replacement
> ### Aliases: grep grepl sub gsub regexpr gregexpr regexec
> ### Keywords: character utilities
> 
> ### ** Examples
> 
> grep("[a-z]", letters)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26
> 
> txt <- c("arm","foot","lefroo", "bafoobar")
> if(length(i <- grep("foo",txt)))
+    cat("'foo' appears at least once in\n\t",txt,"\n")
'foo' appears at least once in
	 arm foot lefroo bafoobar 
> i # 2 and 4
[1] 2 4
> txt[i]
[1] "foot"     "bafoobar"
> 
> ## Double all 'a' or 'b's;  "\" must be escaped, i.e., 'doubled'
> gsub("([ab])", "\\1_\\1_", "abc and ABC")
[1] "a_a_b_b_c a_a_nd ABC"
> 
> txt <- c("The", "licenses", "for", "most", "software", "are",
+   "designed", "to", "take", "away", "your", "freedom",
+   "to", "share", "and", "change", "it.",
+    "", "By", "contrast,", "the", "GNU", "General", "Public", "License",
+    "is", "intended", "to", "guarantee", "your", "freedom", "to",
+    "share", "and", "change", "free", "software", "--",
+    "to", "make", "sure", "the", "software", "is",
+    "free", "for", "all", "its", "users")
> ( i <- grep("[gu]", txt) ) # indices
[1]  7 11 16 24 29 30 35 41 49
> stopifnot( txt[i] == grep("[gu]", txt, value = TRUE) )
> 
> ## Note that in locales such as en_US this includes B as the
> ## collation order is aAbBcCdEe ...
> (ot <- sub("[b-e]",".", txt))
 [1] "Th."       "li.enses"  "for"       "most"      "softwar."  "ar."      
 [7] ".esigned"  "to"        "tak."      "away"      "your"      "fr.edom"  
[13] "to"        "shar."     "an."       ".hange"    "it."       ""         
[19] "By"        ".ontrast," "th."       "GNU"       "G.neral"   "Pu.lic"   
[25] "Li.ense"   "is"        "int.nded"  "to"        "guarant.e" "your"     
[31] "fr.edom"   "to"        "shar."     "an."       ".hange"    "fr.e"     
[37] "softwar."  "--"        "to"        "mak."      "sur."      "th."      
[43] "softwar."  "is"        "fr.e"      "for"       "all"       "its"      
[49] "us.rs"    
> txt[ot != gsub("[b-e]",".", txt)]#- gsub does "global" substitution
 [1] "licenses"  "designed"  "freedom"   "change"    "General"   "Public"   
 [7] "License"   "intended"  "guarantee" "freedom"   "change"    "free"     
[13] "free"     
> 
> txt[gsub("g","#", txt) !=
+     gsub("g","#", txt, ignore.case = TRUE)] # the "G" words
[1] "GNU"     "General"
> 
> regexpr("en", txt)
 [1] -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  2 -1  4
[26] -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
attr(,"match.length")
 [1] -1  2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  2 -1  2
[26] -1  2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
attr(,"useBytes")
[1] TRUE
> 
> gregexpr("e", txt)
[[1]]
[1] 3
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[2]]
[1] 4 7
attr(,"match.length")
[1] 1 1
attr(,"useBytes")
[1] TRUE

[[3]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[4]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[5]]
[1] 8
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[6]]
[1] 3
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[7]]
[1] 2 7
attr(,"match.length")
[1] 1 1
attr(,"useBytes")
[1] TRUE

[[8]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[9]]
[1] 4
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[10]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[11]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[12]]
[1] 3 4
attr(,"match.length")
[1] 1 1
attr(,"useBytes")
[1] TRUE

[[13]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[14]]
[1] 5
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[15]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[16]]
[1] 6
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[17]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[18]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[19]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[20]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[21]]
[1] 3
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[22]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[23]]
[1] 2 4
attr(,"match.length")
[1] 1 1
attr(,"useBytes")
[1] TRUE

[[24]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[25]]
[1] 4 7
attr(,"match.length")
[1] 1 1
attr(,"useBytes")
[1] TRUE

[[26]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[27]]
[1] 4 7
attr(,"match.length")
[1] 1 1
attr(,"useBytes")
[1] TRUE

[[28]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[29]]
[1] 8 9
attr(,"match.length")
[1] 1 1
attr(,"useBytes")
[1] TRUE

[[30]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[31]]
[1] 3 4
attr(,"match.length")
[1] 1 1
attr(,"useBytes")
[1] TRUE

[[32]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[33]]
[1] 5
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[34]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[35]]
[1] 6
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[36]]
[1] 3 4
attr(,"match.length")
[1] 1 1
attr(,"useBytes")
[1] TRUE

[[37]]
[1] 8
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[38]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[39]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[40]]
[1] 4
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[41]]
[1] 4
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[42]]
[1] 3
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[43]]
[1] 8
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

[[44]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[45]]
[1] 3 4
attr(,"match.length")
[1] 1 1
attr(,"useBytes")
[1] TRUE

[[46]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[47]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[48]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"useBytes")
[1] TRUE

[[49]]
[1] 3
attr(,"match.length")
[1] 1
attr(,"useBytes")
[1] TRUE

> 
> ## Using grepl() for filtering
> ## Find functions with argument names matching "warn":
> findArgs <- function(env, pattern) {
+   nms <- ls(envir = as.environment(env))
+   nms <- nms[is.na(match(nms, c("F","T")))] # <-- work around "checking hack"
+   aa <- sapply(nms, function(.) { o <- get(.)
+                if(is.function(o)) names(formals(o)) })
+   iw <- sapply(aa, function(a) any(grepl(pattern, a, ignore.case=TRUE)))
+   aa[iw]
+ }
> findArgs("package:base", "warn")
$attach
[1] "what"           "pos"            "name"           "warn.conflicts"

$dir.create
[1] "path"         "showWarnings" "recursive"    "mode"        

$file.create
[1] "..."          "showWarnings"

$library
 [1] "package"        "help"           "pos"            "lib.loc"       
 [5] "character.only" "logical.return" "warn.conflicts" "quietly"       
 [9] "keep.source"    "verbose"       

$readLines
[1] "con"      "n"        "ok"       "warn"     "encoding"

$require
[1] "package"        "lib.loc"        "quietly"        "warn.conflicts"
[5] "keep.source"    "character.only"

> 
> ## trim trailing white space
> str <- 'Now is the time      '
> sub(' +$', '', str)  ## spaces only
[1] "Now is the time"
> sub('[[:space:]]+$', '', str) ## white space, POSIX-style
[1] "Now is the time"
> sub('\\s+$', '', str, perl = TRUE) ## Perl-style white space
[1] "Now is the time"
> 
> ## capitalizing
> txt <- "a test of capitalizing"
> gsub("(\\w)(\\w*)", "\\U\\1\\L\\2", txt, perl=TRUE)
[1] "A Test Of Capitalizing"
> gsub("\\b(\\w)",    "\\U\\1",       txt, perl=TRUE)
[1] "A Test Of Capitalizing"
> 
> txt2 <- "useRs may fly into JFK or laGuardia"
> gsub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", txt2, perl=TRUE)
[1] "UseRS MaY FlY IntO JFK OR LaGuardiA"
>  sub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", txt2, perl=TRUE)
[1] "UseRS may fly into JFK or laGuardia"
> 
> ## named capture
> notables <- c("  Ben Franklin and Jefferson Davis",
+               "\tMillard Fillmore")
> # name groups 'first' and 'last'
> name.rex <- "(?<first>[[:upper:]][[:lower:]]+) (?<last>[[:upper:]][[:lower:]]+)"
> (parsed <- regexpr(name.rex, notables, perl = TRUE))
[1] 3 2
attr(,"match.length")
[1] 12 16
attr(,"useBytes")
[1] TRUE
attr(,"capture.start")
     first last
[1,]     3    7
[2,]     2   10
attr(,"capture.length")
     first last
[1,]     3    8
[2,]     7    8
attr(,"capture.names")
[1] "first" "last" 
> gregexpr(name.rex, notables, perl = TRUE)[[2]]
[1] 2
attr(,"match.length")
[1] 16
attr(,"useBytes")
[1] TRUE
attr(,"capture.start")
     first last
[1,]     2   10
attr(,"capture.length")
     first last
[1,]     7    8
attr(,"capture.names")
[1] "first" "last" 
> parse.one <- function(res, result) {
+   m <- do.call(rbind, lapply(seq_along(res), function(i) {
+     if(result[i] == -1) return("")
+     st <- attr(result, "capture.start")[i, ]
+     substring(res[i], st, st + attr(result, "capture.length")[i, ] - 1)
+   }))
+   colnames(m) <- attr(result, "capture.names")
+   m
+ }
> parse.one(notables, parsed)
     first     last      
[1,] "Ben"     "Franklin"
[2,] "Millard" "Fillmore"
> 
> ## Decompose a URL into its components.
> ## Example by LT (http://www.cs.uiowa.edu/~luke/R/regexp.html).
> x <- "http://stat.umn.edu:80/xyz"
> m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
> m
[[1]]
[1]  1  1  1  8 20 21 23
attr(,"match.length")
[1] 26  7  4 12  3  2  4

> regmatches(x, m)
[[1]]
[1] "http://stat.umn.edu:80/xyz" "http://"                   
[3] "http"                       "stat.umn.edu"              
[5] ":80"                        "80"                        
[7] "/xyz"                      

> ## Element 3 is the protocol, 4 is the host, 6 is the port, and 7
> ## is the path.  We can use this to make a function for extracting the
> ## parts of a URL:
> URL_parts <- function(x) {
+     m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
+     parts <- do.call(rbind,
+                      lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L)))
+     colnames(parts) <- c("protocol","host","port","path")
+     parts
+ }
> URL_parts(x)
     protocol host           port path  
[1,] "http"   "stat.umn.edu" "80" "/xyz"
> 
> 
> 
> cleanEx()
> nameEx("groupGeneric")
> ### * groupGeneric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: groupGeneric
> ### Title: S3 Group Generic Functions
> ### Aliases: S3groupGeneric groupGeneric .Group Math Math.data.frame Ops
> ###   Ops.data.frame Summary Summary.data.frame Complex 'group generic'
> ### Keywords: methods
> 
> ### ** Examples
> 
> require(utils)
> 
> d.fr <- data.frame(x=1:9, y=stats::rnorm(9))
> class(1 + d.fr) == "data.frame" ##-- add to d.f. ...
[1] TRUE
> 
> methods("Math")
[1] Math.data.frame Math.Date       Math.difftime   Math.factor    
[5] Math.POSIXt    
> methods("Ops")
[1] Ops.data.frame      Ops.Date            Ops.difftime       
[4] Ops.factor          Ops.numeric_version Ops.ordered        
[7] Ops.POSIXt          Ops.raster*         Ops.ts*            

   Non-visible functions are asterisked
> methods("Summary")
[1] Summary.data.frame      Summary.Date            Summary.difftime       
[4] Summary.factor          Summary.numeric_version Summary.ordered        
[7] Summary.POSIXct         Summary.POSIXlt        
> methods("Complex")  # none in base R
no methods were found
> 
> 
> 
> cleanEx()
> nameEx("gzcon")
> ### * gzcon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gzcon
> ### Title: (De)compress I/O Through Connections
> ### Aliases: gzcon
> ### Keywords: file connection
> 
> ### ** Examples
> 
> 
> ## gzfile and gzcon can inter-work.
> ## Of course here one would use gzfile, but file() can be replaced by
> ## any other connection generator.
> zz <- gzfile("ex.gz", "w")
> cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = zz, sep = "\n")
> close(zz)
> readLines(zz <- gzcon(file("ex.gz", "rb")))
[1] "TITLE extra line" "2 3 5 7"          ""                 "11 13 17"        
> close(zz)
> unlink("ex.gz")
> zz <- gzcon(file("ex2.gz", "wb"))
> cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = zz, sep = "\n")
> close(zz)
> readLines(zz <- gzfile("ex2.gz"))
[1] "TITLE extra line" "2 3 5 7"          ""                 "11 13 17"        
> close(zz)
> unlink("ex2.gz")
> 
> 
> 
> cleanEx()
> nameEx("iconv")
> ### * iconv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: iconv
> ### Title: Convert Character Vector between Encodings
> ### Aliases: iconv iconvlist
> ### Keywords: character utilities
> 
> ### ** Examples
> 
> ## In principle, not all systems have iconvlist
> try(utils::head(iconvlist(), n = 50))
 [1] "1026"             "1046"             "1047"             "10646-1:1993"    
 [5] "437"              "500"              "500V1"            "850"             
 [9] "851"              "852"              "855"              "856"             
[13] "857"              "860"              "861"              "862"             
[17] "863"              "864"              "865"              "866"             
[21] "866NAV"           "869"              "874"              "8859_1"          
[25] "8859_2"           "8859_3"           "8859_4"           "8859_5"          
[29] "8859_6"           "8859_7"           "8859_8"           "8859_9"          
[33] "904"              "ANSI_X3.110"      "ANSI_X3.110-1983" "ANSI_X3.4"       
[37] "ANSI_X3.4-1968"   "ANSI_X3.4-1986"   "ARABIC"           "ARABIC7"         
[41] "ARMSCII-8"        "ASCII"            "ASMO_449"         "ASMO-708"        
[45] "BALTIC"           "BIG5"             "BIG-5"            "BIG5HKSCS"       
[49] "BIG5-HKSCS"       "BIGFIVE"         
> 
> ## Not run: 
> ##D ## convert from Latin-2 to UTF-8: two of the glibc iconv variants.
> ##D iconv(x, "ISO_8859-2", "UTF-8")
> ##D iconv(x, "LATIN2", "UTF-8")
> ## End(Not run)
> 
> ## Both x below are in latin1 and will only display correctly in a
> ## locale that can represent and display latin1.
> x <- "fa\xE7ile"
> Encoding(x) <- "latin1"
> x
[1] "façile"   
> charToRaw(xx <- iconv(x, "latin1", "UTF-8"))
[1] 66 61 c3 a7 69 6c 65
> xx
[1] "façile"
> 
> iconv(x, "latin1", "ASCII")          #   NA
[1] NA
> iconv(x, "latin1", "ASCII", "?")     # "fa?ile"
[1] "fa?ile"
> iconv(x, "latin1", "ASCII", "")      # "faile"
[1] "faile"
> iconv(x, "latin1", "ASCII", "byte")  # "fa<e7>ile"
[1] "fa<e7>ile"
> 
> ## Extracts from old R help files (they are nowadays in UTF-8)
> x <- c("Ekstr\xf8m", "J\xf6reskog", "bi\xdfchen Z\xfcrcher")
> Encoding(x) <- "latin1"
> x
[1] "Ekstrøm"               "Jöreskog"              "bißchen Zürcher"      
> try(iconv(x, "latin1", "ASCII//TRANSLIT"))  # platform-dependent
[1] "Ekstr?m"          "Joreskog"         "bisschen Zurcher"
> iconv(x, "latin1", "ASCII", sub="byte")
[1] "Ekstr<f8>m"            "J<f6>reskog"           "bi<df>chen Z<fc>rcher"
> ## and for Windows' 'Unicode'
> str(xx <- iconv(x, "latin1", "UTF-16LE", toRaw = TRUE))
List of 3
 $ : raw [1:14] 45 00 6b 00 ...
 $ : raw [1:16] 4a 00 f6 00 ...
 $ : raw [1:30] 62 00 69 00 ...
> iconv(xx, "UTF-16LE", "UTF-8")
[1] "Ekstrøm"         "Jöreskog"        "bißchen Zürcher"
> 
> 
> 
> cleanEx()
> nameEx("icuSetCollate")
> ### * icuSetCollate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: icuSetCollate
> ### Title: Setup Collation by ICU
> ### Aliases: icuSetCollate
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("identical")
> ### * identical
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: identical
> ### Title: Test Objects for Exact Equality
> ### Aliases: identical
> ### Keywords: programming logic iteration
> 
> ### ** Examples
> 
> identical(1, NULL) ## FALSE -- don't try this with ==
[1] FALSE
> identical(1, 1.)   ## TRUE in R (both are stored as doubles)
[1] TRUE
> identical(1, as.integer(1)) ## FALSE, stored as different types
[1] FALSE
> 
> x <- 1.0; y <- 0.99999999999
> ## how to test for object equality allowing for numeric fuzz :
> (E <- all.equal(x,y))
[1] TRUE
> isTRUE(E) # which is simply defined to just use
[1] TRUE
> identical(TRUE, E)
[1] TRUE
> ## If all.equal thinks the objects are different, it returns a
> ## character string, and the above expression evaluates to FALSE
> 
> ## even for unusual R objects :
> identical(.GlobalEnv, environment())
[1] TRUE
> 
> ### ------- Pickyness Flags : -----------------------------
> 
> ## the infamous example:
> identical(0., -0.) # TRUE, i.e. not differentiated
[1] TRUE
> identical(0., -0., num.eq = FALSE)
[1] FALSE
> ## similar:
> identical(NaN, -NaN) # TRUE
[1] TRUE
> identical(NaN, -NaN, single.NA=FALSE) # differ on bit-level
[1] FALSE
> ## for functions:
> f <- function(x) x
> f
function (x) 
x
> g <- compiler::cmpfun(f)
> g
function (x) 
x
<bytecode: 0xa7e46bc>
> identical(f, g)
[1] TRUE
> identical(f, g, ignore.bytecode=FALSE)
[1] FALSE
> ## Don't show: 
> m0 <- m <- structure(cbind(I=1, a=1:3), foo = "bar", class = "matrix")
> attributes(m0) <- rev(attributes(m))
> names(attributes(m0)) # 'dim' remains first, interestingly...
[1] "dim"      "class"    "foo"      "dimnames"
> 
> stopifnot(identical(0, -0),     !identical(0, -0, num.eq=FALSE),
+           identical(NaN, -NaN), !identical(NaN, -NaN, single.NA=FALSE),
+           identical(m, m0),     !identical(m, m0, attrib.as.set=FALSE) )
> ## End Don't show
> 
> 
> 
> cleanEx()
> nameEx("ifelse")
> ### * ifelse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ifelse
> ### Title: Conditional Element Selection
> ### Aliases: ifelse
> ### Keywords: logic programming
> 
> ### ** Examples
> 
> x <- c(6:-4)
> sqrt(x)  #- gives warning
Warning in sqrt(x) : NaNs produced
 [1] 2.449490 2.236068 2.000000 1.732051 1.414214 1.000000 0.000000      NaN
 [9]      NaN      NaN      NaN
> sqrt(ifelse(x >= 0, x, NA))  # no warning
 [1] 2.449490 2.236068 2.000000 1.732051 1.414214 1.000000 0.000000       NA
 [9]       NA       NA       NA
> 
> ## Note: the following also gives the warning !
> ifelse(x >= 0, sqrt(x), NA)
Warning in sqrt(x) : NaNs produced
 [1] 2.449490 2.236068 2.000000 1.732051 1.414214 1.000000 0.000000       NA
 [9]       NA       NA       NA
> 
> ## example of different return modes:
> yes <- 1:3
> no <- pi^(0:3)
> typeof(ifelse(NA, yes, no))    # logical
[1] "logical"
> typeof(ifelse(TRUE, yes, no))  # integer
[1] "integer"
> typeof(ifelse(FALSE, yes, no)) # double
[1] "double"
> 
> 
> 
> cleanEx()
> nameEx("integer")
> ### * integer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: integer
> ### Title: Integer Vectors
> ### Aliases: integer as.integer is.integer
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## as.integer() truncates:
> x <- pi * c(-1:1,10)
> as.integer(x)
[1] -3  0  3 31
> 
> is.integer(1) # is FALSE !
[1] FALSE
> 
> is.wholenumber <-
+     function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol
> is.wholenumber(1) # is TRUE
[1] TRUE
> (x <- seq(1,5, by=0.5) )
[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0
> is.wholenumber( x ) #-->  TRUE FALSE TRUE ...
[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
> 
> 
> 
> cleanEx()
> nameEx("interaction")
> ### * interaction
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interaction
> ### Title: Compute Factor Interactions
> ### Aliases: interaction
> ### Keywords: category
> 
> ### ** Examples
> 
> a <- gl(2, 4, 8)
> b <- gl(2, 2, 8, labels = c("ctrl", "treat"))
> s <- gl(2, 1, 8, labels = c("M", "F"))
> interaction(a, b)
[1] 1.ctrl  1.ctrl  1.treat 1.treat 2.ctrl  2.ctrl  2.treat 2.treat
Levels: 1.ctrl 2.ctrl 1.treat 2.treat
> interaction(a, b, s, sep = ":")
[1] 1:ctrl:M  1:ctrl:F  1:treat:M 1:treat:F 2:ctrl:M  2:ctrl:F  2:treat:M
[8] 2:treat:F
8 Levels: 1:ctrl:M 2:ctrl:M 1:treat:M 2:treat:M 1:ctrl:F ... 2:treat:F
> stopifnot(identical(a:s,
+                     interaction(a, s, sep = ":", lex.order = TRUE)),
+           identical(a:s:b,
+                     interaction(a, s, b, sep = ":", lex.order = TRUE)))
> 
> 
> 
> cleanEx()
> nameEx("interactive")
> ### * interactive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interactive
> ### Title: Is R Running Interactively?
> ### Aliases: interactive
> ### Keywords: environment programming
> 
> ### ** Examples
> 
>  .First <- function() if(interactive()) x11()
> 
> 
> 
> cleanEx()
> nameEx("invisible")
> ### * invisible
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: invisible
> ### Title: Change the Print Mode to Invisible
> ### Aliases: invisible
> ### Keywords: programming
> 
> ### ** Examples
> 
> # These functions both return their argument
> f1 <- function(x) x
> f2 <- function(x) invisible(x)
> f1(1)# prints
[1] 1
> f2(1)# does not
> 
> 
> 
> cleanEx()
> nameEx("is.finite")
> ### * is.finite
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.finite
> ### Title: Finite, Infinite and NaN Numbers
> ### Aliases: is.finite is.infinite Inf NaN is.nan finite
> ### Keywords: programming math
> 
> ### ** Examples
> 
> pi / 0 ## = Inf a non-zero number divided by zero creates infinity
[1] Inf
> 0 / 0  ## =  NaN
[1] NaN
> 
> 1/0 + 1/0 # Inf
[1] Inf
> 1/0 - 1/0 # NaN
[1] NaN
> 
> stopifnot(
+     1/0 == Inf,
+     1/Inf == 0
+ )
> sin(Inf)
Warning in sin(Inf) : NaNs produced
[1] NaN
> cos(Inf)
Warning in cos(Inf) : NaNs produced
[1] NaN
> tan(Inf)
Warning in tan(Inf) : NaNs produced
[1] NaN
> 
> 
> 
> cleanEx()
> nameEx("is.function")
> ### * is.function
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.function
> ### Title: Is an Object of Type (Primitive) Function?
> ### Aliases: is.function is.primitive
> ### Keywords: programming
> 
> ### ** Examples
> 
> is.function(1) # FALSE
[1] FALSE
> is.function(is.primitive)  # TRUE: it is a function, but ..
[1] TRUE
> is.primitive(is.primitive) # FALSE:it's not a primitive one, whereas
[1] FALSE
> is.primitive(is.function)  # TRUE: that one *is*
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("is.language")
> ### * is.language
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.language
> ### Title: Is an Object a Language Object?
> ### Aliases: is.language
> ### Keywords: programming
> 
> ### ** Examples
> 
> ll <- list(a = expression(x^2 - 2*x + 1), b = as.name("Jim"),
+            c = as.expression(exp(1)), d = call("sin", pi))
> sapply(ll, typeof)
           a            b            c            d 
"expression"     "symbol" "expression"   "language" 
> sapply(ll, mode)
           a            b            c            d 
"expression"       "name" "expression"       "call" 
> stopifnot(sapply(ll, is.language))
> 
> 
> 
> cleanEx()
> nameEx("is.object")
> ### * is.object
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.object
> ### Title: Is an Object 'internally classed'?
> ### Aliases: is.object
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> is.object(1) # FALSE
[1] FALSE
> is.object(as.factor(1:3)) # TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("is.recursive")
> ### * is.recursive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.recursive
> ### Title: Is an Object Atomic or Recursive?
> ### Aliases: is.atomic is.recursive
> ### Keywords: programming classes
> 
> ### ** Examples
> 
> require(stats)
> 
> is.a.r <- function(x) c(is.atomic(x), is.recursive(x))
> 
> is.a.r(c(a=1,b=3))      # TRUE FALSE
[1]  TRUE FALSE
> is.a.r(list())          # FALSE TRUE - a list is a list
[1] FALSE  TRUE
> is.a.r(list(2))         # FALSE TRUE
[1] FALSE  TRUE
> is.a.r(lm)              # FALSE TRUE
[1] FALSE  TRUE
> is.a.r(y ~ x)           # FALSE TRUE
[1] FALSE  TRUE
> is.a.r(expression(x+1)) # FALSE TRUE (nowadays)
[1] FALSE  TRUE
> 
> 
> 
> cleanEx()
> nameEx("isR")
> ### * isR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.R
> ### Title: Are we using R, rather than S?
> ### Aliases: is.R
> ### Keywords: environment utilities
> 
> ### ** Examples
> 
> x <- stats::runif(20); small <- x < 0.4
> ## In the early years of R, 'which()' only existed in R:
> if(is.R()) which(small) else seq(along=small)[small]
[1]  1  2  5 10 11 12 14 19
> 
> 
> 
> cleanEx()
> nameEx("isS4")
> ### * isS4
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isS4
> ### Title: Test for an S4 object
> ### Aliases: isS4 asS4 S4 asS3
> ### Keywords: programming
> 
> ### ** Examples
> 
> ## Don't show: 
> require(methods)
> ## End Don't show
> isS4(pi) # FALSE
[1] FALSE
> isS4(getClass("MethodDefinition")) # TRUE
[1] TRUE
> ## Don't show: 
> stopifnot(isS4(asS4(Sys.time())))
> ## Following is a correction of previous behavior. See note in the
> ## value section above 
> stopifnot(isS4(asS4(getClass("MethodDefinition"), FALSE, 2)))
> stopifnot(!isS4(asS4(getClass("MethodDefinition"), FALSE, 0)))
> ## End Don't show
> 
> 
> 
> cleanEx()
> nameEx("isSymmetric")
> ### * isSymmetric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isSymmetric
> ### Title: Test if a Matrix or other Object is Symmetric
> ### Aliases: isSymmetric isSymmetric.matrix
> ### Keywords: array utilities
> 
> ### ** Examples
> 
> isSymmetric(D3 <- diag(3)) # -> TRUE
[1] TRUE
> 
> D3[2,1] <- 1e-100
> D3
       [,1] [,2] [,3]
[1,]  1e+00    0    0
[2,] 1e-100    1    0
[3,]  0e+00    0    1
> isSymmetric(D3) # TRUE
[1] TRUE
> isSymmetric(D3, tol = 0) # FALSE for zero-tolerance
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("jitter")
> ### * jitter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jitter
> ### Title: 'Jitter' (Add Noise) to Numbers
> ### Aliases: jitter
> ### Keywords: dplot utilities
> 
> ### ** Examples
> 
> round(jitter(c(rep(1,3),  rep(1.2, 4), rep(3,3))), 3)
 [1] 0.981 0.990 1.006 1.233 1.176 1.232 1.236 3.013 3.010 2.965
> ## These two 'fail' with S-plus 3.x:
> jitter(rep(0, 7))
[1] -1.176102e-02 -1.293773e-02  7.480914e-03 -4.635851e-03  1.079366e-02
[6] -9.203032e-05  8.704740e-03
> jitter(rep(10000,5))
[1] 10196.762  9952.014 10110.978 10173.882  9884.857
> 
> 
> 
> cleanEx()
> nameEx("kappa")
> ### * kappa
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kappa
> ### Title: Compute or Estimate the Condition Number of a Matrix
> ### Aliases: rcond kappa kappa.default kappa.lm kappa.qr kappa.tri
> ### Keywords: math
> 
> ### ** Examples
> 
> kappa(x1 <- cbind(1,1:10))# 15.71
[1] 15.7059
> kappa(x1, exact = TRUE)        # 13.68
[1] 13.67903
> kappa(x2 <- cbind(x1,2:11))# high! [x2 is singular!]
[1] 8.351867e+16
> 
> hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
> sv9 <- svd(h9 <- hilbert(9))$ d
> kappa(h9)# pretty high!
[1] 728289390019
> kappa(h9, exact = TRUE) == max(sv9) / min(sv9)
[1] TRUE
> kappa(h9, exact = TRUE) / kappa(h9) # .677 (i.e., rel.error = 32%)
[1] 0.6771402
> 
> 
> 
> cleanEx()
> nameEx("kronecker")
> ### * kronecker
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kronecker
> ### Title: Kronecker Products on Arrays
> ### Aliases: kronecker .kronecker %x%
> ### Keywords: array
> 
> ### ** Examples
> 
> # simple scalar multiplication
> ( M <- matrix(1:6, ncol=2) )
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
> kronecker(4, M)
     [,1] [,2]
[1,]    4   16
[2,]    8   20
[3,]   12   24
> # Block diagonal matrix:
> kronecker(diag(1, 3), M)
      [,1] [,2] [,3] [,4] [,5] [,6]
 [1,]    1    4    0    0    0    0
 [2,]    2    5    0    0    0    0
 [3,]    3    6    0    0    0    0
 [4,]    0    0    1    4    0    0
 [5,]    0    0    2    5    0    0
 [6,]    0    0    3    6    0    0
 [7,]    0    0    0    0    1    4
 [8,]    0    0    0    0    2    5
 [9,]    0    0    0    0    3    6
> 
> # ask for dimnames
> 
> fred <- matrix(1:12, 3, 4, dimnames=list(LETTERS[1:3], LETTERS[4:7]))
> bill <- c("happy" = 100, "sad" = 1000)
> kronecker(fred, bill, make.dimnames = TRUE)
          D:   E:   F:    G:
A:happy  100  400  700  1000
A:sad   1000 4000 7000 10000
B:happy  200  500  800  1100
B:sad   2000 5000 8000 11000
C:happy  300  600  900  1200
C:sad   3000 6000 9000 12000
> 
> bill <- outer(bill, c("cat"=3, "dog"=4))
> kronecker(fred, bill, make.dimnames = TRUE)
        D:cat D:dog E:cat E:dog F:cat F:dog G:cat G:dog
A:happy   300   400  1200  1600  2100  2800  3000  4000
A:sad    3000  4000 12000 16000 21000 28000 30000 40000
B:happy   600   800  1500  2000  2400  3200  3300  4400
B:sad    6000  8000 15000 20000 24000 32000 33000 44000
C:happy   900  1200  1800  2400  2700  3600  3600  4800
C:sad    9000 12000 18000 24000 27000 36000 36000 48000
> 
> 
> 
> cleanEx()
> nameEx("l10n_info")
> ### * l10n_info
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: l10n_info
> ### Title: Localization Information
> ### Aliases: l10n_info
> ### Keywords: utilities
> 
> ### ** Examples
> 
> l10n_info()
$MBCS
[1] TRUE

$`UTF-8`
[1] TRUE

$`Latin-1`
[1] FALSE

> 
> 
> 
> cleanEx()
> nameEx("lapply")
> ### * lapply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lapply
> ### Title: Apply a Function over a List or Vector
> ### Aliases: lapply sapply vapply replicate simplify2array
> ### Keywords: iteration list
> 
> ### ** Examples
> 
> require(stats); require(graphics)
> 
> x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
> # compute the list mean for each list element
> lapply(x,mean)
$a
[1] 5.5

$beta
[1] 4.535125

$logic
[1] 0.5

> # median and quartiles for each list element
> lapply(x, quantile, probs = 1:3/4)
$a
 25%  50%  75% 
3.25 5.50 7.75 

$beta
      25%       50%       75% 
0.2516074 1.0000000 5.0536690 

$logic
25% 50% 75% 
0.0 0.5 1.0 

> sapply(x, quantile)
         a        beta logic
0%    1.00  0.04978707   0.0
25%   3.25  0.25160736   0.0
50%   5.50  1.00000000   0.5
75%   7.75  5.05366896   1.0
100% 10.00 20.08553692   1.0
> i39 <- sapply(3:9, seq) # list of vectors
> sapply(i39, fivenum)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7]
[1,]  1.0  1.0    1  1.0  1.0  1.0    1
[2,]  1.5  1.5    2  2.0  2.5  2.5    3
[3,]  2.0  2.5    3  3.5  4.0  4.5    5
[4,]  2.5  3.5    4  5.0  5.5  6.5    7
[5,]  3.0  4.0    5  6.0  7.0  8.0    9
> vapply(i39, fivenum,
+        c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
        [,1] [,2] [,3] [,4] [,5] [,6] [,7]
Min.     1.0  1.0    1  1.0  1.0  1.0    1
1st Qu.  1.5  1.5    2  2.0  2.5  2.5    3
Median   2.0  2.5    3  3.5  4.0  4.5    5
3rd Qu.  2.5  3.5    4  5.0  5.5  6.5    7
Max.     3.0  4.0    5  6.0  7.0  8.0    9
> 
> ## sapply(*, "array") -- artificial example
> (v <- structure(10*(5:8), names=LETTERS[1:4]))
 A  B  C  D 
50 60 70 80 
> f2 <- function(x,y) outer(rep(x, length.out=3), y)
> (a2 <- sapply(v, f2, y = 2*(1:5), simplify="array"))
, , A

     [,1] [,2] [,3] [,4] [,5]
[1,]  100  200  300  400  500
[2,]  100  200  300  400  500
[3,]  100  200  300  400  500

, , B

     [,1] [,2] [,3] [,4] [,5]
[1,]  120  240  360  480  600
[2,]  120  240  360  480  600
[3,]  120  240  360  480  600

, , C

     [,1] [,2] [,3] [,4] [,5]
[1,]  140  280  420  560  700
[2,]  140  280  420  560  700
[3,]  140  280  420  560  700

, , D

     [,1] [,2] [,3] [,4] [,5]
[1,]  160  320  480  640  800
[2,]  160  320  480  640  800
[3,]  160  320  480  640  800

> a.2 <- vapply(v, f2, outer(1:3, 1:5), y = 2*(1:5))
> stopifnot(dim(a2) == c(3,5,4), all.equal(a2, a.2),
+           identical(dimnames(a2), list(NULL,NULL,LETTERS[1:4])))
> 
> hist(replicate(100, mean(rexp(10))))
> 
> ## use of replicate() with parameters:
> foo <- function(x=1, y=2) c(x,y)
> # does not work: bar <- function(n, ...) replicate(n, foo(...))
> bar <- function(n, x) replicate(n, foo(x=x))
> bar(5, x=3)
     [,1] [,2] [,3] [,4] [,5]
[1,]    3    3    3    3    3
[2,]    2    2    2    2    2
> 
> 
> 
> cleanEx()
> nameEx("length")
> ### * length
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: length
> ### Title: Length of an Object
> ### Aliases: length length<- length<-.factor
> ### Keywords: attribute
> 
> ### ** Examples
> 
> length(diag(4))# = 16 (4 x 4)
[1] 16
> length(options())# 12 or more
[1] 57
> length(y ~ x1 + x2 + x3)# 3
[1] 3
> length(expression(x, {y <- x^2; y+2}, x^y)) # 3
[1] 3
> 
> ## from example(warpbreaks)
> require(stats)
> 
> fm1 <- lm(breaks ~ wool * tension, data = warpbreaks)
> length(fm1$call) # 3, lm() and two arguments.
[1] 3
> length(formula(fm1)) # 3, ~ lhs rhs
[1] 3
> 
> 
> 
> cleanEx()
> nameEx("levels")
> ### * levels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: levels
> ### Title: Levels Attributes
> ### Aliases: levels levels.default levels<- levels<-.factor
> ### Keywords: category
> 
> ### ** Examples
> 
> ## assign individual levels
> x <- gl(2, 4, 8)
> levels(x)[1] <- "low"
> levels(x)[2] <- "high"
> x
[1] low  low  low  low  high high high high
Levels: low high
> 
> ## or as a group
> y <- gl(2, 4, 8)
> levels(y) <- c("low", "high")
> y
[1] low  low  low  low  high high high high
Levels: low high
> 
> ## combine some levels
> z <- gl(3, 2, 12)
> levels(z) <- c("A", "B", "A")
> z
 [1] A A B B A A A A B B A A
Levels: A B
> 
> ## same, using a named list
> z <- gl(3, 2, 12)
> levels(z) <- list(A=c(1,3), B=2)
> z
 [1] A A B B A A A A B B A A
Levels: A B
> 
> ## we can add levels this way:
> f <- factor(c("a","b"))
> levels(f) <- c("c", "a", "b")
> f
[1] c a
Levels: c a b
> 
> f <- factor(c("a","b"))
> levels(f) <- list(C="C", A="a", B="b")
> f
[1] A B
Levels: C A B
> 
> 
> 
> cleanEx()
> nameEx("libPaths")
> ### * libPaths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: libPaths
> ### Title: Search Paths for Packages
> ### Aliases: .Library .Library.site .libPaths R_LIBS R_LIBS_SITE
> ###   R_LIBS_USER .expand_R_libs_env_var
> ### Keywords: data
> 
> ### ** Examples
> 
> .libPaths()                 # all library trees R knows about
[1] "/usr/local/R-2.15.1/library"
> 
> 
> 
> cleanEx()
> nameEx("library")
> ### * library
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: library
> ### Title: Loading and Listing of Packages
> ### Aliases: library require .noGenerics format.libraryIQR print.libraryIQR
> ###   format.packageInfo print.packageInfo
> ### Keywords: data
> 
> ### ** Examples
> 
> library()                   # list all available packages
Packages in library ‘/usr/local/R-2.15.1/library’:

base                    The R Base Package
boot                    Bootstrap Functions (originally by Angelo Canty
                        for S)
class                   Functions for Classification
cluster                 Cluster Analysis Extended Rousseeuw et al.
codetools               Code Analysis Tools for R
compiler                The R Compiler Package
datasets                The R Datasets Package
foreign                 Read Data Stored by Minitab, S, SAS, SPSS,
                        Stata, Systat, dBase, ...
graphics                The R Graphics Package
grDevices               The R Graphics Devices and Support for Colours
                        and Fonts
grid                    The Grid Graphics Package
KernSmooth              Functions for kernel smoothing for Wand & Jones
                        (1995)
lattice                 Lattice Graphics
MASS                    Support Functions and Datasets for Venables and
                        Ripley's MASS
Matrix                  Sparse and Dense Matrix Classes and Methods
methods                 Formal Methods and Classes
mgcv                    Mixed GAM Computation Vehicle with GCV/AIC/REML
                        smoothness estimation
nlme                    Linear and Nonlinear Mixed Effects Models
nnet                    Feed-forward Neural Networks and Multinomial
                        Log-Linear Models
parallel                Support for Parallel computation in R
rpart                   Recursive Partitioning
spatial                 Functions for Kriging and Point Pattern
                        Analysis
splines                 Regression Spline Functions and Classes
stats                   The R Stats Package
stats4                  Statistical Functions using S4 Classes
survival                Survival analysis, including penalised
                        likelihood.
tcltk                   Tcl/Tk Interface
tools                   Tools for Package Development
utils                   The R Utils Package

> library(lib.loc = .Library) # list all packages in the default library
Packages in library ‘/usr/local/R-2.15.1/library’:

base                    The R Base Package
boot                    Bootstrap Functions (originally by Angelo Canty
                        for S)
class                   Functions for Classification
cluster                 Cluster Analysis Extended Rousseeuw et al.
codetools               Code Analysis Tools for R
compiler                The R Compiler Package
datasets                The R Datasets Package
foreign                 Read Data Stored by Minitab, S, SAS, SPSS,
                        Stata, Systat, dBase, ...
graphics                The R Graphics Package
grDevices               The R Graphics Devices and Support for Colours
                        and Fonts
grid                    The Grid Graphics Package
KernSmooth              Functions for kernel smoothing for Wand & Jones
                        (1995)
lattice                 Lattice Graphics
MASS                    Support Functions and Datasets for Venables and
                        Ripley's MASS
Matrix                  Sparse and Dense Matrix Classes and Methods
methods                 Formal Methods and Classes
mgcv                    Mixed GAM Computation Vehicle with GCV/AIC/REML
                        smoothness estimation
nlme                    Linear and Nonlinear Mixed Effects Models
nnet                    Feed-forward Neural Networks and Multinomial
                        Log-Linear Models
parallel                Support for Parallel computation in R
rpart                   Recursive Partitioning
spatial                 Functions for Kriging and Point Pattern
                        Analysis
splines                 Regression Spline Functions and Classes
stats                   The R Stats Package
stats4                  Statistical Functions using S4 Classes
survival                Survival analysis, including penalised
                        likelihood.
tcltk                   Tcl/Tk Interface
tools                   Tools for Package Development
utils                   The R Utils Package

> library(splines)            # load package 'splines'
> require(splines)            # the same
> search()                    # "splines", too
 [1] ".GlobalEnv"        "package:splines"   "CheckExEnv"       
 [4] "package:stats"     "package:graphics"  "package:grDevices"
 [7] "package:utils"     "package:datasets"  "package:methods"  
[10] "Autoloads"         "package:base"     
> detach("package:splines")
> 
> # if the package name is in a character vector, use
> pkg <- "splines"
> library(pkg, character.only = TRUE)
> detach(pos = match(paste("package", pkg, sep=":"), search()))
> 
> require(pkg, character.only = TRUE)
Loading required package: splines
> detach(pos = match(paste("package", pkg, sep=":"), search()))
> 
> require(nonexistent)        # FALSE
Loading required package: nonexistent
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘nonexistent’
> ## Not run: 
> ##D ## if you want to mask as little as possible, use
> ##D library(mypkg, pos = "package:base")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("library.dynam")
> ### * library.dynam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: library.dynam
> ### Title: Loading DLLs from Packages
> ### Aliases: library.dynam library.dynam.unload .dynLibs
> ### Keywords: data
> 
> ### ** Examples
> 
> ## Which DLLs were dynamically loaded by packages?
> library.dynam() 
                                                 Filename Dynamic.Lookup
1     /usr/local/R-2.15.1/library/methods/libs/methods.so          FALSE
2 /usr/local/R-2.15.1/library/grDevices/libs/grDevices.so          FALSE
3         /usr/local/R-2.15.1/library/stats/libs/stats.so          FALSE
4     /usr/local/R-2.15.1/library/splines/libs/splines.so          FALSE
5         /usr/local/R-2.15.1/library/tools/libs/tools.so          FALSE
> 
> 
> 
> cleanEx()
> nameEx("list")
> ### * list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: list
> ### Title: Lists - Generic and Dotted Pairs
> ### Aliases: list pairlist alist as.list as.list.default as.list.data.frame
> ###   as.list.environment as.list.factor as.list.function as.pairlist
> ###   is.list is.pairlist
> ### Keywords: list manip
> 
> ### ** Examples
> 
> require(graphics)
> 
> # create a plotting structure
> pts <- list(x=cars[,1], y=cars[,2])
> plot(pts)
> 
> is.pairlist(.Options)  # a user-level pairlist
[1] TRUE
> 
> ## "pre-allocate" an empty list of length 5
> vector("list", 5)
[[1]]
NULL

[[2]]
NULL

[[3]]
NULL

[[4]]
NULL

[[5]]
NULL

> 
> # Argument lists
> f <- function() x
> # Note the specification of a "..." argument:
> formals(f) <- al <- alist(x=, y=2+3, ...=)
> f
function (x, y = 2 + 3, ...) 
x
> al
$x


$y
2 + 3

$...


> 
> ## environment->list coercion
> 
> e1 <- new.env()
> e1$a <- 10
> e1$b <- 20
> as.list(e1)
$a
[1] 10

$b
[1] 20

> 
> 
> 
> cleanEx()
> nameEx("list.files")
> ### * list.files
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: list.files
> ### Title: List the Files in a Directory/Folder
> ### Aliases: list.files dir list.dirs
> ### Keywords: file
> 
> ### ** Examples
> 
> list.files(R.home())
 [1] "bin"            "ChangeLog"      "config.log"     "config.site"   
 [5] "config.status"  "configure"      "configure.ac"   "COPYING"       
 [9] "doc"            "etc"            "include"        "INSTALL"       
[13] "lib"            "library"        "libtool"        "m4"            
[17] "Makeconf"       "Makeconf.in"    "Makefile"       "Makefile.fw"   
[21] "Makefile.in"    "Makefrag.cc"    "Makefrag.cc_lo" "Makefrag.cxx"  
[25] "Makefrag.m"     "modules"        "NEWS"           "NEWS.pdf"      
[29] "ONEWS"          "OONEWS"         "po"             "README"        
[33] "share"          "src"            "SVN-REVISION"   "tests"         
[37] "tools"          "VERSION"        "VERSION-NICK"  
> ## Only files starting with a-l or r
> ## Note that a-l is locale-dependent, but using case-insensitive
> ## matching makes it unambiguous in English locales
> dir("../..", pattern = "^[a-lr]", full.names=TRUE, ignore.case = TRUE)
 [1] "../../bin"           "../../ChangeLog"     "../../config.log"   
 [4] "../../config.site"   "../../config.status" "../../configure"    
 [7] "../../configure.ac"  "../../COPYING"       "../../doc"          
[10] "../../etc"           "../../include"       "../../INSTALL"      
[13] "../../lib"           "../../library"       "../../libtool"      
[16] "../../README"       
> 
> list.dirs(R.home("doc"))
[1] "/usr/local/R-2.15.1/doc"              
[2] "/usr/local/R-2.15.1/doc/html"         
[3] "/usr/local/R-2.15.1/doc/manual"       
[4] "/usr/local/R-2.15.1/doc/manual/images"
> 
> 
> 
> cleanEx()
> nameEx("list2env")
> ### * list2env
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: list2env
> ### Title: From A List, Build or Add To an Environment
> ### Aliases: list2env
> ### Keywords: data
> 
> ### ** Examples
> 
> L <- list(a=1, b=2:4, p = pi, ff = gl(3,4,labels=LETTERS[1:3]))
> e <- list2env(L)
> ls(e)
[1] "a"  "b"  "ff" "p" 
> stopifnot(ls(e) == sort(names(L)),
+           identical(L$b, e$b)) # "$" working for environments as for lists
> 
> ## consistency, when we do the inverse:
> ll <- as.list(e)  # -> dispatching to the as.list.environment() method
> rbind(names(L), names(ll)) # not in the same order, typically,
     [,1] [,2] [,3] [,4]
[1,] "a"  "b"  "p"  "ff"
[2,] "ff" "p"  "b"  "a" 
>                            # but the same content:
> stopifnot(identical(L [sort.list(names(L ))],
+                     ll[sort.list(names(ll))]))
> 
> ## now add to e -- can be seen as a fast "multi-assign":
> list2env(list(abc = LETTERS, note = "just an example",
+               df = data.frame(x=rnorm(20), y = rbinom(20,1, pr=0.2))),
+          envir = e)
<environment: 0x9e79138>
> utils::ls.str(e)
a :  num 1
abc :  chr [1:26] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" ...
b :  int [1:3] 2 3 4
df : 'data.frame':	20 obs. of  2 variables:
 $ x: num  -0.626 0.184 -0.836 1.595 0.33 ...
 $ y: num  1 0 0 0 0 0 0 0 0 0 ...
ff :  Factor w/ 3 levels "A","B","C": 1 1 1 1 2 2 2 2 3 3 ...
note :  chr "just an example"
p :  num 3.14
> 
> 
> 
> cleanEx()
> nameEx("load")
> ### * load
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: load
> ### Title: Reload Saved Datasets
> ### Aliases: load
> ### Keywords: file
> 
> ### ** Examples
> 
> ## save all data
> xx <- pi # to ensure there is some data
> save(list = ls(all=TRUE), file= "all.RData")
> rm(xx)
> 
> ## restore the saved values to the current environment
> local({
+    load("all.RData")
+    ls()
+ })
[1] "xx"
> ## restore the saved values to the user's workspace
> load("all.RData", .GlobalEnv)
> 
> unlink("all.RData")
> 
> ## Not run: 
> ##D con <- url("http://some.where.net/R/data/example.rda")
> ##D ## print the value to see what objects were created.
> ##D print(load(con))
> ##D close(con) # url() always opens the connection
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("locales")
> ### * locales
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: locales
> ### Title: Query or Set Aspects of the Locale
> ### Aliases: locales Sys.getlocale Sys.setlocale LC_ALL LC_COLLATE LC_CTYPE
> ###   LC_MONETARY LC_NUMERIC LC_TIME LC_MESSAGES LC_PAPER LC_MEASUREMENT
> ### Keywords: utilities
> 
> ### ** Examples
> 
> Sys.getlocale()
[1] "LC_CTYPE=en_IN;LC_NUMERIC=C;LC_TIME=C;LC_COLLATE=en_IN;LC_MONETARY=en_IN;LC_MESSAGES=en_IN;LC_PAPER=C;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=en_IN;LC_IDENTIFICATION=C"
> Sys.getlocale("LC_TIME")
[1] "C"
> ## Not run: 
> ##D Sys.setlocale("LC_TIME", "de")     # Solaris: details are OS-dependent
> ##D Sys.setlocale("LC_TIME", "de_DE.utf8")   # Modern Linux etc.
> ##D Sys.setlocale("LC_TIME", "de_DE.UTF-8")  # ditto
> ##D Sys.setlocale("LC_TIME", "de_DE")  # Mac OS X, in UTF-8
> ##D Sys.setlocale("LC_TIME", "German") # Windows
> ## End(Not run)
> Sys.getlocale("LC_PAPER")          # may or may not be set
[1] "C"
> 
> Sys.setlocale("LC_COLLATE", "C")   # turn off locale-specific sorting,
[1] "C"
>                                    #  usually
> 
> 
> 
> cleanEx()
> nameEx("lower.tri")
> ### * lower.tri
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lower.tri
> ### Title: Lower and Upper Triangular Part of a Matrix
> ### Aliases: lower.tri upper.tri
> ### Keywords: array
> 
> ### ** Examples
> 
> (m2 <- matrix(1:20, 4, 5))
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
> lower.tri(m2)
      [,1]  [,2]  [,3]  [,4]  [,5]
[1,] FALSE FALSE FALSE FALSE FALSE
[2,]  TRUE FALSE FALSE FALSE FALSE
[3,]  TRUE  TRUE FALSE FALSE FALSE
[4,]  TRUE  TRUE  TRUE FALSE FALSE
> m2[lower.tri(m2)] <- NA
> m2
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]   NA    6   10   14   18
[3,]   NA   NA   11   15   19
[4,]   NA   NA   NA   16   20
> 
> 
> 
> cleanEx()
> nameEx("ls")
> ### * ls
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ls
> ### Title: List Objects
> ### Aliases: ls objects
> ### Keywords: environment
> 
> ### ** Examples
> 
> .Ob <- 1
> ls(pattern = "O")
character(0)
> ls(pattern= "O", all.names = TRUE)    # also shows ".[foo]"
[1] ".Ob"
> 
> # shows an empty list because inside myfunc no variables are defined
> myfunc <- function() {ls()}
> myfunc()
character(0)
> 
> # define a local variable inside myfunc
> myfunc <- function() {y <- 1; ls()}
> myfunc()                # shows "y"
[1] "y"
> 
> 
> 
> cleanEx()
> nameEx("make.names")
> ### * make.names
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make.names
> ### Title: Make Syntactically Valid Names
> ### Aliases: make.names
> ### Keywords: character
> 
> ### ** Examples
> 
> make.names(c("a and b", "a-and-b"), unique=TRUE)
[1] "a.and.b"   "a.and.b.1"
> # "a.and.b"  "a.and.b.1"
> make.names(c("a and b", "a_and_b"), unique=TRUE)
[1] "a.and.b" "a_and_b"
> # "a.and.b"  "a_and_b"
> make.names(c("a and b", "a_and_b"), unique=TRUE, allow_=FALSE)
[1] "a.and.b"   "a.and.b.1"
> # "a.and.b"  "a.and.b.1"
> 
> state.name[make.names(state.name) != state.name] # those 10 with a space
 [1] "New Hampshire"  "New Jersey"     "New Mexico"     "New York"      
 [5] "North Carolina" "North Dakota"   "Rhode Island"   "South Carolina"
 [9] "South Dakota"   "West Virginia" 
> 
> 
> 
> cleanEx()
> nameEx("make.unique")
> ### * make.unique
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make.unique
> ### Title: Make Character Strings Unique
> ### Aliases: make.unique
> ### Keywords: character
> 
> ### ** Examples
> 
> make.unique(c("a", "a", "a"))
[1] "a"   "a.1" "a.2"
> make.unique(c(make.unique(c("a", "a")), "a"))
[1] "a"   "a.1" "a.2"
> 
> make.unique(c("a", "a", "a.2", "a"))
[1] "a"   "a.1" "a.2" "a.3"
> make.unique(c(make.unique(c("a", "a")), "a.2", "a"))
[1] "a"   "a.1" "a.2" "a.3"
> 
> rbind(data.frame(x=1), data.frame(x=2), data.frame(x=3))
  x
1 1
2 2
3 3
> rbind(rbind(data.frame(x=1), data.frame(x=2)), data.frame(x=3))
  x
1 1
2 2
3 3
> 
> 
> 
> cleanEx()
> nameEx("mapply")
> ### * mapply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mapply
> ### Title: Apply a Function to Multiple List or Vector Arguments
> ### Aliases: mapply
> ### Keywords: manip utilities
> 
> ### ** Examples
> 
> mapply(rep, 1:4, 4:1)
[[1]]
[1] 1 1 1 1

[[2]]
[1] 2 2 2

[[3]]
[1] 3 3

[[4]]
[1] 4

> 
> mapply(rep, times = 1:4, x = 4:1)
[[1]]
[1] 4

[[2]]
[1] 3 3

[[3]]
[1] 2 2 2

[[4]]
[1] 1 1 1 1

> 
> mapply(rep, times = 1:4, MoreArgs = list(x = 42))
[[1]]
[1] 42

[[2]]
[1] 42 42

[[3]]
[1] 42 42 42

[[4]]
[1] 42 42 42 42

> 
> mapply(function(x,y) seq_len(x) + y,
+        c(a =  1, b = 2, c = 3),  # names from first
+        c(A = 10, B = 0, C = -10))
$a
[1] 11

$b
[1] 1 2

$c
[1] -9 -8 -7

> 
> word <- function(C,k) paste(rep.int(C,k), collapse = '')
> utils::str(mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE))
List of 6
 $ A: chr "AAAAAA"
 $ B: chr "BBBBB"
 $ C: chr "CCCC"
 $ D: chr "DDD"
 $ E: chr "EE"
 $ F: chr "F"
> 
> 
> 
> cleanEx()
> nameEx("margin.table")
> ### * margin.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: margin.table
> ### Title: Compute table margin
> ### Aliases: margin.table
> ### Keywords: array
> 
> ### ** Examples
> 
> m <- matrix(1:4,2)
> margin.table(m,1)
[1] 4 6
> margin.table(m,2)
[1] 3 7
> 
> 
> 
> cleanEx()
> nameEx("mat.or.vec")
> ### * mat.or.vec
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mat.or.vec
> ### Title: Create a Matrix or a Vector
> ### Aliases: mat.or.vec
> ### Keywords: array
> 
> ### ** Examples
> 
> mat.or.vec(3, 1)
[1] 0 0 0
> mat.or.vec(3, 2)
     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0
> 
> 
> 
> cleanEx()
> nameEx("match")
> ### * match
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: match
> ### Title: Value Matching
> ### Aliases: match %in%
> ### Keywords: manip logic
> 
> ### ** Examples
> 
> ## The intersection of two sets can be defined via match():
> ## Simple version:
> ## intersect <- function(x, y) y[match(x, y, nomatch = 0)]
> intersect # the R function in base, slightly more careful
function (x, y) 
{
    y <- as.vector(y)
    unique(y[match(as.vector(x), y, 0L)])
}
<bytecode: 0xa1b3038>
<environment: namespace:base>
> intersect(1:10, 7:20)
[1]  7  8  9 10
> 
> 1:10 %in% c(1,3,5,9)
 [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE
> sstr <- c("c","ab","B","bba","c",NA,"@","bla","a","Ba","%")
> sstr[sstr %in% c(letters, LETTERS)]
[1] "c" "B" "c" "a"
> 
> "%w/o%" <- function(x, y) x[!x %in% y] #--  x without y
> (1:10) %w/o% c(3,7,12)
[1]  1  2  4  5  6  8  9 10
> 
> 
> 
> cleanEx()
> nameEx("match.arg")
> ### * match.arg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: match.arg
> ### Title: Argument Verification Using Partial Matching
> ### Aliases: match.arg
> ### Keywords: programming
> 
> ### ** Examples
> 
> require(stats)
> ## Extends the example for 'switch'
> center <- function(x, type = c("mean", "median", "trimmed")) {
+   type <- match.arg(type)
+   switch(type,
+          mean = mean(x),
+          median = median(x),
+          trimmed = mean(x, trim = .1))
+ }
> x <- rcauchy(10)
> center(x, "t")       # Works
[1] -0.3632328
> center(x, "med")     # Works
[1] -0.236111
> try(center(x, "m"))  # Error
Error in match.arg(type) : 
  'arg' should be one of “mean”, “median”, “trimmed”
> stopifnot(identical(center(x),       center(x, "mean")),
+           identical(center(x, NULL), center(x, "mean")) )
> 
> ## Allowing more than one match:
> match.arg(c("gauss", "rect", "ep"),
+           c("gaussian", "epanechnikov", "rectangular", "triangular"),
+           several.ok = TRUE)
[1] "gaussian"     "rectangular"  "epanechnikov"
> 
> 
> 
> cleanEx()
> nameEx("match.call")
> ### * match.call
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: match.call
> ### Title: Argument Matching
> ### Aliases: match.call
> ### Keywords: programming
> 
> ### ** Examples
> 
> match.call(get, call("get", "abc", i = FALSE, p = 3))
get(x = "abc", pos = 3, inherits = FALSE)
> ## -> get(x = "abc", pos = 3, inherits = FALSE)
> fun <- function(x, lower = 0, upper = 1) {
+   structure((x - lower) / (upper - lower), CALL = match.call())
+ }
> fun(4 * atan(1), u = pi)
[1] 1
attr(,"CALL")
fun(x = 4 * atan(1), upper = pi)
> 
> 
> 
> cleanEx()
> nameEx("match.fun")
> ### * match.fun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: match.fun
> ### Title: Extract a Function Specified by Name
> ### Aliases: match.fun
> ### Keywords: programming
> 
> ### ** Examples
> 
> # Same as get("*"):
> match.fun("*")
function (e1, e2)  .Primitive("*")
> # Overwrite outer with a vector
> outer <- 1:5
> ## Not run: 
> ##D match.fun(outer, descend = FALSE) #-> Error:  not a function
> ## End(Not run)
> match.fun(outer) # finds it anyway
function (X, Y, FUN = "*", ...) 
{
    if (is.array(X)) {
        dX <- dim(X)
        nx <- dimnames(X)
        no.nx <- is.null(nx)
    }
    else {
        dX <- length(X)
        no.nx <- is.null(names(X))
        if (!no.nx) 
            nx <- list(names(X))
    }
    if (is.array(Y)) {
        dY <- dim(Y)
        ny <- dimnames(Y)
        no.ny <- is.null(ny)
    }
    else {
        dY <- length(Y)
        no.ny <- is.null(names(Y))
        if (!no.ny) 
            ny <- list(names(Y))
    }
    if (is.character(FUN) && FUN == "*") {
        robj <- as.vector(X) %*% t(as.vector(Y))
        dim(robj) <- c(dX, dY)
    }
    else {
        FUN <- match.fun(FUN)
        Y <- rep(Y, rep.int(length(X), length(Y)))
        if (length(X)) 
            X <- rep(X, times = ceiling(length(Y)/length(X)))
        robj <- FUN(X, Y, ...)
        dim(robj) <- c(dX, dY)
    }
    if (no.nx) 
        nx <- vector("list", length(dX))
    else if (no.ny) 
        ny <- vector("list", length(dY))
    if (!(no.nx && no.ny)) 
        dimnames(robj) <- c(nx, ny)
    robj
}
<bytecode: 0xa5a6f84>
<environment: namespace:base>
> is.function(match.fun("outer")) # as well
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("matmult")
> ### * matmult
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matmult
> ### Title: Matrix Multiplication
> ### Aliases: %*% matmult
> ### Keywords: array arith
> 
> ### ** Examples
> 
> x <- 1:4
> (z <- x %*% x)    # scalar ("inner") product (1 x 1 matrix)
     [,1]
[1,]   30
> drop(z)             # as scalar
[1] 30
> 
> y <- diag(x)
> z <- matrix(1:12, ncol = 3, nrow = 4)
> y %*% z
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    4   12   20
[3,]    9   21   33
[4,]   16   32   48
> y %*% x
     [,1]
[1,]    1
[2,]    4
[3,]    9
[4,]   16
> x %*% z
     [,1] [,2] [,3]
[1,]   30   70  110
> 
> 
> 
> cleanEx()
> nameEx("matrix")
> ### * matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matrix
> ### Title: Matrices
> ### Aliases: matrix as.matrix as.matrix.default as.matrix.data.frame
> ###   is.matrix
> ### Keywords: array algebra
> 
> ### ** Examples
> 
> is.matrix(as.matrix(1:10))
[1] TRUE
> !is.matrix(warpbreaks)# data.frame, NOT matrix!
[1] TRUE
> warpbreaks[1:10,]
   breaks wool tension
1      26    A       L
2      30    A       L
3      54    A       L
4      25    A       L
5      70    A       L
6      52    A       L
7      51    A       L
8      26    A       L
9      67    A       L
10     18    A       M
> as.matrix(warpbreaks[1:10,]) #using as.matrix.data.frame(.) method
   breaks wool tension
1  "26"   "A"  "L"    
2  "30"   "A"  "L"    
3  "54"   "A"  "L"    
4  "25"   "A"  "L"    
5  "70"   "A"  "L"    
6  "52"   "A"  "L"    
7  "51"   "A"  "L"    
8  "26"   "A"  "L"    
9  "67"   "A"  "L"    
10 "18"   "A"  "M"    
> 
> # Example of setting row and column names
> mdat <- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol=3, byrow=TRUE,
+                dimnames = list(c("row1", "row2"),
+                                c("C.1", "C.2", "C.3")))
> mdat
     C.1 C.2 C.3
row1   1   2   3
row2  11  12  13
> 
> 
> 
> cleanEx()
> nameEx("maxCol")
> ### * maxCol
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: maxCol
> ### Title: Find Maximum Position in Matrix
> ### Aliases: max.col
> ### Keywords: utilities array
> 
> ### ** Examples
> 
> table(mc <- max.col(swiss))# mostly "1" and "5", 5 x "2" and once "4"

 1  2  4  5 
23  5  1 18 
> swiss[unique(print(mr <- max.col(t(swiss)))) , ] # 3 33 45 45 33 6
[1]  3 33 45 45 33  6
             Fertility Agriculture Examination Education Catholic
Franches-Mnt      92.5        39.7           5         5    93.40
Herens            77.3        89.7           5         2   100.00
V. De Geneve      35.0         1.2          37        53    42.34
Porrentruy        76.1        35.3           9         7    90.57
             Infant.Mortality
Franches-Mnt             20.2
Herens                   18.3
V. De Geneve             18.0
Porrentruy               26.6
> 
> set.seed(1)# reproducible example:
> (mm <- rbind(x = round(2*stats::runif(12)),
+              y = round(5*stats::runif(12)),
+              z = round(8*stats::runif(12))))
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
x    1    1    1    2    0    2    2    1    1     0     0     0
y    3    2    4    2    4    5    2    4    5     1     3     1
z    2    3    0    3    7    3    4    5    4     1     7     5
> ## Not run: 
> ##D   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
> ##D x    1    1    1    2    0    2    2    1    1     0     0     0
> ##D y    3    2    4    2    4    5    2    4    5     1     3     1
> ##D z    2    3    0    3    7    3    4    5    4     1     7     5
> ## End(Not run)
> ## column indices of all row maxima :
> utils::str(lapply(1:3, function(i) which(mm[i,] == max(mm[i,]))))
List of 3
 $ : int [1:3] 4 6 7
 $ : int [1:2] 6 9
 $ : int [1:2] 5 11
> max.col(mm) ; max.col(mm) # "random"
[1] 4 6 5
[1] 6 6 5
> max.col(mm, "first")# -> 4 6 5
[1] 4 6 5
> max.col(mm, "last") # -> 7 9 11
[1]  7  9 11
> ## Don't show: 
> stopifnot(max.col(mm, "first") == c(4, 6, 5),
+           max.col(mm, "last")  == c(7, 9,11))
> ## End Don't show
> 
> 
> 
> cleanEx()
> nameEx("mean")
> ### * mean
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mean
> ### Title: Arithmetic Mean
> ### Aliases: mean mean.default mean.data.frame
> ### Keywords: univar
> 
> ### ** Examples
> 
> x <- c(0:10, 50)
> xm <- mean(x)
> c(xm, mean(x, trim = 0.10))
[1] 8.75 5.50
> 
> 
> 
> cleanEx()
> nameEx("memCompress")
> ### * memCompress
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: memCompress
> ### Title: In-memory Compression and Decompression
> ### Aliases: memCompress memDecompress
> ### Keywords: file connection
> 
> ### ** Examples
> 
> txt <- readLines(file.path(R.home("doc"), "COPYING"))
> sum(nchar(txt))
[1] 17671
> txt.gz <- memCompress(txt, "g")
> length(txt.gz)
[1] 6837
> txt2 <- strsplit(memDecompress(txt.gz, "g", asChar = TRUE), "\n")[[1]]
> stopifnot(identical(txt, txt2))
> txt.bz2 <- memCompress(txt, "b")
> length(txt.bz2)
[1] 6168
> ## can auto-detect bzip2:
> txt3 <- strsplit(memDecompress(txt.bz2, asChar = TRUE), "\n")[[1]]
> stopifnot(identical(txt, txt3))
> 
> ## xz compression is only worthwhile for large objects
> txt.xz <- memCompress(txt, "x")
> length(txt.xz)
[1] 6564
> txt3 <- strsplit(memDecompress(txt.xz, asChar = TRUE), "\n")[[1]]
> stopifnot(identical(txt, txt3))
> 
> 
> 
> cleanEx()
> nameEx("memory.profile")
> ### * memory.profile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: memory.profile
> ### Title: Profile the Usage of Cons Cells
> ### Aliases: memory.profile
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("merge")
> ### * merge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: merge
> ### Title: Merge Two Data Frames
> ### Aliases: merge merge.default merge.data.frame
> ### Keywords: array manip
> 
> ### ** Examples
> 
> ## use character columns of names to get sensible sort order
> authors <- data.frame(
+     surname = I(c("Tukey", "Venables", "Tierney", "Ripley", "McNeil")),
+     nationality = c("US", "Australia", "US", "UK", "Australia"),
+     deceased = c("yes", rep("no", 4)))
> books <- data.frame(
+     name = I(c("Tukey", "Venables", "Tierney",
+              "Ripley", "Ripley", "McNeil", "R Core")),
+     title = c("Exploratory Data Analysis",
+               "Modern Applied Statistics ...",
+               "LISP-STAT",
+               "Spatial Statistics", "Stochastic Simulation",
+               "Interactive Data Analysis",
+               "An Introduction to R"),
+     other.author = c(NA, "Ripley", NA, NA, NA, NA,
+                      "Venables & Smith"))
> 
> (m1 <- merge(authors, books, by.x = "surname", by.y = "name"))
   surname nationality deceased                         title other.author
1   McNeil   Australia       no     Interactive Data Analysis         <NA>
2   Ripley          UK       no            Spatial Statistics         <NA>
3   Ripley          UK       no         Stochastic Simulation         <NA>
4  Tierney          US       no                     LISP-STAT         <NA>
5    Tukey          US      yes     Exploratory Data Analysis         <NA>
6 Venables   Australia       no Modern Applied Statistics ...       Ripley
> (m2 <- merge(books, authors, by.x = "name", by.y = "surname"))
      name                         title other.author nationality deceased
1   McNeil     Interactive Data Analysis         <NA>   Australia       no
2   Ripley            Spatial Statistics         <NA>          UK       no
3   Ripley         Stochastic Simulation         <NA>          UK       no
4  Tierney                     LISP-STAT         <NA>          US       no
5    Tukey     Exploratory Data Analysis         <NA>          US      yes
6 Venables Modern Applied Statistics ...       Ripley   Australia       no
> stopifnot(as.character(m1[,1]) == as.character(m2[,1]),
+           all.equal(m1[, -1], m2[, -1][ names(m1)[-1] ]),
+           dim(merge(m1, m2, by = integer(0))) == c(36, 10))
> 
> ## "R core" is missing from authors and appears only here :
> merge(authors, books, by.x = "surname", by.y = "name", all = TRUE)
   surname nationality deceased                         title     other.author
1   McNeil   Australia       no     Interactive Data Analysis             <NA>
2   R Core        <NA>     <NA>          An Introduction to R Venables & Smith
3   Ripley          UK       no            Spatial Statistics             <NA>
4   Ripley          UK       no         Stochastic Simulation             <NA>
5  Tierney          US       no                     LISP-STAT             <NA>
6    Tukey          US      yes     Exploratory Data Analysis             <NA>
7 Venables   Australia       no Modern Applied Statistics ...           Ripley
> 
> ## example of using 'incomparables'
> x <- data.frame(k1=c(NA,NA,3,4,5), k2=c(1,NA,NA,4,5), data=1:5)
> y <- data.frame(k1=c(NA,2,NA,4,5), k2=c(NA,NA,3,4,5), data=1:5)
> merge(x, y, by=c("k1","k2")) # NA's match
  k1 k2 data.x data.y
1  4  4      4      4
2  5  5      5      5
3 NA NA      2      1
> merge(x, y, by=c("k1","k2"), incomparables=NA)
  k1 k2 data.x data.y
1  4  4      4      4
2  5  5      5      5
3 NA NA      2      1
> merge(x, y, by="k1") # NA's match, so 6 rows
  k1 k2.x data.x k2.y data.y
1  4    4      4    4      4
2  5    5      5    5      5
3 NA    1      1   NA      1
4 NA    1      1    3      3
5 NA   NA      2   NA      1
6 NA   NA      2    3      3
> merge(x, y, by="k2", incomparables=NA) # 2 rows
  k2 k1.x data.x k1.y data.y
1  4    4      4    4      4
2  5    5      5    5      5
> 
> 
> 
> cleanEx()
> nameEx("message")
> ### * message
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: message
> ### Title: Diagnostic Messages
> ### Aliases: message suppressMessages packageStartupMessage
> ###   .packageStartupMessage suppressPackageStartupMessages .makeMessage
> ### Keywords: programming
> 
> ### ** Examples
> 
> message("ABC", "DEF")
ABCDEF
> suppressMessages(message("ABC"))
> 
> testit <- function() {
+   message("testing package startup messages")
+   packageStartupMessage("initializing ...", appendLF = FALSE)
+   Sys.sleep(1)
+   packageStartupMessage(" done")
+ }
> 
> testit()
testing package startup messages
initializing ... done
> suppressPackageStartupMessages(testit())
testing package startup messages

Execution halted
