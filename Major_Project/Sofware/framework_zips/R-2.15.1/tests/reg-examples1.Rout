
R version 2.15.1 (2012-06-22) -- "Roasted Marshmallows"
Copyright (C) 2012 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: i686-pc-linux-gnu (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ## For examples skipped in testing because they are 'random'
> 
> set.seed(1)
> if(.Platform$OS.type == "windows") options(pager = "console")
> 
> pdf("reg-examples-1.pdf", encoding = "ISOLatin1.enc")
> 
> 
> ## base
> example(Cstack_info)

Cstck_> ## No test: 
Cstck_> Cstack_info()
      size    current  direction eval_depth 
        NA         NA         -1          9 

Cstck_> ## End(No test)
Cstck_> 
Cstck_> 
> example(DateTimeClasses)

DtTmCl> ## No test: 
DtTmCl> (z <- Sys.time())             # the current date, as class "POSIXct"
[1] "2012-09-21 15:05:10 IST"

DtTmCl> Sys.time() - 3600             # an hour ago
[1] "2012-09-21 14:05:10 IST"

DtTmCl> as.POSIXlt(Sys.time(), "GMT") # the current time in GMT
[1] "2012-09-21 09:35:10 GMT"

DtTmCl> format(.leap.seconds)         # all 24 leap seconds in your timezone
 [1] "1972-07-01 05:30:00" "1973-01-01 05:30:00" "1974-01-01 05:30:00"
 [4] "1975-01-01 05:30:00" "1976-01-01 05:30:00" "1977-01-01 05:30:00"
 [7] "1978-01-01 05:30:00" "1979-01-01 05:30:00" "1980-01-01 05:30:00"
[10] "1981-07-01 05:30:00" "1982-07-01 05:30:00" "1983-07-01 05:30:00"
[13] "1985-07-01 05:30:00" "1988-01-01 05:30:00" "1990-01-01 05:30:00"
[16] "1991-01-01 05:30:00" "1992-07-01 05:30:00" "1993-07-01 05:30:00"
[19] "1994-07-01 05:30:00" "1996-01-01 05:30:00" "1997-07-01 05:30:00"
[22] "1999-01-01 05:30:00" "2006-01-01 05:30:00" "2009-01-01 05:30:00"

DtTmCl> print(.leap.seconds, tz="PST8PDT")  # and in Seattle's
 [1] "1972-07-01 05:30:00 IST" "1973-01-01 05:30:00 IST"
 [3] "1974-01-01 05:30:00 IST" "1975-01-01 05:30:00 IST"
 [5] "1976-01-01 05:30:00 IST" "1977-01-01 05:30:00 IST"
 [7] "1978-01-01 05:30:00 IST" "1979-01-01 05:30:00 IST"
 [9] "1980-01-01 05:30:00 IST" "1981-07-01 05:30:00 IST"
[11] "1982-07-01 05:30:00 IST" "1983-07-01 05:30:00 IST"
[13] "1985-07-01 05:30:00 IST" "1988-01-01 05:30:00 IST"
[15] "1990-01-01 05:30:00 IST" "1991-01-01 05:30:00 IST"
[17] "1992-07-01 05:30:00 IST" "1993-07-01 05:30:00 IST"
[19] "1994-07-01 05:30:00 IST" "1996-01-01 05:30:00 IST"
[21] "1997-07-01 05:30:00 IST" "1999-01-01 05:30:00 IST"
[23] "2006-01-01 05:30:00 IST" "2009-01-01 05:30:00 IST"

DtTmCl> ## look at *internal* representation of "POSIXlt" :
DtTmCl> leapS <- as.POSIXlt(.leap.seconds)

DtTmCl> names(leapS) ; is.list(leapS)
NULL
[1] TRUE

DtTmCl> utils::str(unclass(leapS), vec.len = 7)
List of 9
 $ sec  : num [1:24] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 $ min  : int [1:24] 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 ...
 $ hour : int [1:24] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 ...
 $ mday : int [1:24] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
 $ mon  : int [1:24] 6 0 0 0 0 0 0 0 0 6 6 6 6 0 0 0 6 6 ...
 $ year : int [1:24] 72 73 74 75 76 77 78 79 80 81 82 83 85 88 90 91 92 93 ...
 $ wday : int [1:24] 6 1 2 3 4 6 0 1 2 3 4 5 1 5 1 2 3 4 ...
 $ yday : int [1:24] 182 0 0 0 0 0 0 0 0 181 181 181 181 0 0 0 182 181 ...
 $ isdst: int [1:24] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 - attr(*, "tzone")= chr [1:3] "" "IST" "IST"

DtTmCl> ## End(No test)
DtTmCl> 
DtTmCl> 
> example(Dates)

Dates> ## Not run: 
Dates> ##D (today <- Sys.Date())
Dates> ##D format(today, "%d %b %Y")  # with month as a word
Dates> ##D (tenweeks <- seq(today, length.out=10, by="1 week")) # next ten weeks
Dates> ##D weekdays(today)
Dates> ##D months(tenweeks)
Dates> ##D as.Date(.leap.seconds)
Dates> ## End(Not run)
Dates> 
Dates> 
> example(Ops.Date)

Ops.Dt> ## No test: 
Ops.Dt> (z <- Sys.Date())
[1] "2012-09-21"

Ops.Dt> z + 10
[1] "2012-10-01"

Ops.Dt> z < c("2009-06-01", "2010-01-01", "2015-01-01")
[1] FALSE FALSE  TRUE

Ops.Dt> ## End(No test)
Ops.Dt> 
Ops.Dt> 
> example(Random)

Random> ## No test: 
Random> require(stats)

Random> ## the default random seed is 626 integers, so only print a few
Random> runif(1); .Random.seed[1:6]; runif(1); .Random.seed[1:6]
[1] 0.2655087
[1]         403           1  1654269195 -1877109783  -961256264  1403523942
[1] 0.3721239
[1]         403           2  1654269195 -1877109783  -961256264  1403523942

Random> ## If there is no seed, a "random" new one is created:
Random> rm(.Random.seed); runif(1); .Random.seed[1:6]
[1] 0.2611188
[1]         403           1   285012841  1406807352  1596301286 -1246636159

Random> ok <- RNGkind()

Random> RNGkind("Wich")# (partial string matching on 'kind')

Random> ## This shows how 'runif(.)' works for Wichmann-Hill,
Random> ## using only R functions:
Random> 
Random> p.WH <- c(30269, 30307, 30323)

Random> a.WH <- c(  171,   172,   170)

Random> next.WHseed <- function(i.seed = .Random.seed[-1])
Random+   { (a.WH * i.seed) %% p.WH }

Random> my.runif1 <- function(i.seed = .Random.seed)
Random+   { ns <- next.WHseed(i.seed[-1]); sum(ns / p.WH) %% 1 }

Random> rs <- .Random.seed

Random> (WHs <- next.WHseed(rs[-1]))
[1] 28036 17541  5024

Random> u <- runif(1)

Random> stopifnot(
Random+  next.WHseed(rs[-1]) == .Random.seed[-1],
Random+  all.equal(u, my.runif1(rs))
Random+ )

Random> ## ----
Random> .Random.seed
[1]   400 28036 17541  5024

Random> RNGkind("Super")#matches  "Super-Duper"

Random> RNGkind()
[1] "Super-Duper" "Inversion"  

Random> .Random.seed # new, corresponding to  Super-Duper
[1]        402  971022418 1633061803

Random> ## Reset:
Random> RNGkind(ok[1])

Random> ## ----
Random> sum(duplicated(runif(1e6))) # around 110 for default generator
[1] 106

Random> ## and we would expect about almost sure duplicates beyond about
Random> qbirthday(1-1e-6, classes=2e9) # 235,000
[1] 235075

Random> ## End(No test)
Random> 
Random> 
> example(Sys.getpid)

Sys.gt> ## No test: 
Sys.gt> Sys.getpid()
[1] 3346

Sys.gt> ## End(No test)
Sys.gt> 
Sys.gt> 
> example(Sys.sleep)

Sys.sl> ## No test: 
Sys.sl> testit <- function(x)
Sys.sl+ {
Sys.sl+     p1 <- proc.time()
Sys.sl+     Sys.sleep(x)
Sys.sl+     proc.time() - p1 # The cpu usage should be negligible
Sys.sl+ }

Sys.sl> testit(3.7)
   user  system elapsed 
  0.000   0.000   3.703 

Sys.sl> ## End(No test)
Sys.sl> 
Sys.sl> 
> example(Sys.time)

Sys.tm> ## No test: 
Sys.tm> Sys.time()
[1] "2012-09-21 15:05:14 IST"

Sys.tm> ## print with possibly greater accuracy:
Sys.tm> op <- options(digits.secs=6)

Sys.tm> Sys.time()
[1] "2012-09-21 15:05:14.77543 IST"

Sys.tm> options(op)

Sys.tm> ## locale-specific version of date()
Sys.tm> format(Sys.time(), "%a %b %d %X %Y")
[1] "Fri Sep 21 15:05:14 2012"

Sys.tm> Sys.Date()
[1] "2012-09-21"

Sys.tm> ## End(No test)
Sys.tm> 
Sys.tm> 
> example(as.POSIXlt)

a.POSI> ## No test: 
a.POSI> (z <- Sys.time())             # the current datetime, as class "POSIXct"
[1] "2012-09-21 15:05:14 IST"

a.POSI> unclass(z)                    # a large integer
[1] 1348220115

a.POSI> floor(unclass(z)/86400)       # the number of days since 1970-01-01 (UTC)
[1] 15604

a.POSI> (z <- as.POSIXlt(Sys.time())) # the current datetime, as class "POSIXlt"
[1] "2012-09-21 15:05:14 IST"

a.POSI> unlist(unclass(z))            # a list shown as a named vector
      sec       min      hour      mday       mon      year      wday      yday 
 14.78907   5.00000  15.00000  21.00000   8.00000 112.00000   5.00000 264.00000 
    isdst 
  0.00000 

a.POSI> ## suppose we have a time in seconds since 1960-01-01 00:00:00 GMT
a.POSI> ## (the origin used by SAS)
a.POSI> z <- 1472562988

a.POSI> # ways to convert this
a.POSI> as.POSIXct(z, origin="1960-01-01")                # local
[1] "2006-08-30 13:16:28 IST"

a.POSI> as.POSIXct(z, origin="1960-01-01", tz="GMT")      # in UTC
[1] "2006-08-30 13:16:28 GMT"

a.POSI> as.POSIXct(z, origin=ISOdatetime(1960,1,1,0,0,0)) # local
[1] "2006-08-30 13:16:28 IST"

a.POSI> ISOdatetime(1960,1,1,0,0,0) + z                   # local
[1] "2006-08-30 13:16:28 IST"

a.POSI> ## SPSS dates (R-help 2006-02-16)
a.POSI> z <- c(10485849600, 10477641600, 10561104000, 10562745600)

a.POSI> as.Date(as.POSIXct(z, origin="1582-10-14", tz="GMT"))
[1] "1915-01-26" "1914-10-23" "1917-06-15" "1917-07-04"

a.POSI> as.POSIXlt(Sys.time(), "GMT") # the current time in UTC
[1] "2012-09-21 09:35:14 GMT"

a.POSI> ## End(No test)
a.POSI> ## Not run: 
a.POSI> ##D ## These may not be correct names on your system
a.POSI> ##D as.POSIXlt(Sys.time(), "America/New_York")  # in New York
a.POSI> ##D as.POSIXlt(Sys.time(), "EST5EDT")           # alternative.
a.POSI> ##D as.POSIXlt(Sys.time(), "EST" )   # somewhere in Eastern Canada
a.POSI> ##D as.POSIXlt(Sys.time(), "HST")    # in Hawaii
a.POSI> ##D as.POSIXlt(Sys.time(), "Australia/Darwin")
a.POSI> ## End(Not run)
a.POSI> 
a.POSI> 
> example(difftime)

difftm> ## No test: 
difftm> (z <- Sys.time() - 3600)
[1] "2012-09-21 14:05:14 IST"

difftm> Sys.time() - z                # just over 3600 seconds.
Time difference of 1 hours

difftm> ## time interval between releases of R 1.2.2 and 1.2.3.
difftm> ISOdate(2001, 4, 26) - ISOdate(2001, 2, 26)
Time difference of 59 days

difftm> as.difftime(c("0:3:20", "11:23:15"))
Time differences in mins
[1]   3.333333 683.250000
attr(,"tzone")
[1] ""

difftm> as.difftime(c("3:20", "23:15", "2:"), format= "%H:%M")# 3rd gives NA
Time differences in hours
[1]  3.333333 23.250000        NA
attr(,"tzone")
[1] ""

difftm> (z <- as.difftime(c(0,30,60), units="mins"))
Time differences in mins
[1]  0 30 60

difftm> as.numeric(z, units="secs")
[1]    0 1800 3600

difftm> as.numeric(z, units="hours")
[1] 0.0 0.5 1.0

difftm> format(z)
[1] " 0 mins" "30 mins" "60 mins"

difftm> ## End(No test)
difftm> 
difftm> 
> example(format.Date)

frmt.D> ## No test: 
frmt.D> ## locale-specific version of the date
frmt.D> format(Sys.Date(), "%a %b %d")
[1] "Fri Sep 21"

frmt.D> ## End(No test)
frmt.D> 
frmt.D> ## read in date info in format 'ddmmmyyyy'
frmt.D> ## This will give NA(s) in some locales; setting the C locale
frmt.D> ## as in the commented lines will overcome this on most systems.
frmt.D> ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
frmt.D> x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")

frmt.D> z <- as.Date(x, "%d%b%Y")

frmt.D> ## Sys.setlocale("LC_TIME", lct)
frmt.D> z
[1] "1960-01-01" "1960-01-02" "1960-03-31" "1960-07-30"

frmt.D> ## read in date/time info in format 'm/d/y'
frmt.D> dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")

frmt.D> as.Date(dates, "%m/%d/%y")
[1] "1992-02-27" "1992-02-27" "1992-01-14" "1992-02-28" "1992-02-01"

frmt.D> ## date given as number of days since 1900-01-01 (a date in 1989)
frmt.D> as.Date(32768, origin="1900-01-01")
[1] "1989-09-19"

frmt.D> ## Excel is said to use 1900-01-01 as day 1 (Windows default) or
frmt.D> ## 1904-01-01 as day 0 (Mac default), but this is complicated by Excel
frmt.D> ## treating 1900 as a leap year.
frmt.D> ## So for dates (post-1901) from Windows Excel
frmt.D> as.Date(35981, origin="1899-12-30") # 1998-07-05
[1] "1998-07-05"

frmt.D> ## and Mac Excel
frmt.D> as.Date(34519, origin="1904-01-01") # 1998-07-05
[1] "1998-07-05"

frmt.D> ## (these values come from http://support.microsoft.com/kb/214330)
frmt.D> 
frmt.D> ## Experiment shows that Matlab's origin is 719529 days before ours,
frmt.D> ## so Matlab day 734373 can be imported as
frmt.D> as.Date(734373, origin = "1970-01-01") - 719529
[1] "2010-08-23"

frmt.D> ## (value from http://www.mathworks.com/help/techdoc/matlab_prog/bspgcx2-1.html)
frmt.D> 
frmt.D> ## Timezone effect
frmt.D> z <- ISOdate(2010, 04, 13, c(0,12)) # midnight and midday UTC

frmt.D> as.Date(z) # in UTC
[1] "2010-04-13" "2010-04-13"

frmt.D> ## No test: 
frmt.D> ## these timezone names are common
frmt.D> as.Date(z, tz ="NZ")
[1] "2010-04-13" "2010-04-14"

frmt.D> as.Date(z, tz ="HST") # Hawaii
[1] "2010-04-12" "2010-04-13"

frmt.D> ## End(No test)
frmt.D> 
frmt.D> 
frmt.D> 
> example(Reduce) # funprog.Rd

Reduce> ## A general-purpose adder:
Reduce> add <- function(x) Reduce("+", x)

Reduce> add(list(1, 2, 3))
[1] 6

Reduce> ## Like sum(), but can also used for adding matrices etc., as it will
Reduce> ## use the appropriate '+' method in each reduction step.
Reduce> ## More generally, many generics meant to work on arbitrarily many
Reduce> ## arguments can be defined via reduction:
Reduce> FOO <- function(...) Reduce(FOO2, list(...))

Reduce> FOO2 <- function(x, y) UseMethod("FOO2")

Reduce> ## FOO() methods can then be provided via FOO2() methods.
Reduce> 
Reduce> ## A general-purpose cumulative adder:
Reduce> cadd <- function(x) Reduce("+", x, accumulate = TRUE)

Reduce> cadd(seq_len(7))
[1]  1  3  6 10 15 21 28

Reduce> ## A simple function to compute continued fractions:
Reduce> cfrac <- function(x) Reduce(function(u, v) u + 1 / v, x, right = TRUE)

Reduce> ## Continued fraction approximation for pi:
Reduce> cfrac(c(3, 7, 15, 1, 292))
[1] 3.141593

Reduce> ## Continued fraction approximation for Euler's number (e):
Reduce> cfrac(c(2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8))
[1] 2.718282

Reduce> ## Iterative function application:
Reduce> Funcall <- function(f, ...) f(...)

Reduce> ## Compute log(exp(acos(cos(0))
Reduce> Reduce(Funcall, list(log, exp, acos, cos), 0, right = TRUE)
[1] 0

Reduce> ## n-fold iterate of a function, functional style:
Reduce> Iterate <- function(f, n = 1)
Reduce+     function(x) Reduce(Funcall, rep.int(list(f), n), x, right = TRUE)

Reduce> ## Continued fraction approximation to the golden ratio:
Reduce> Iterate(function(x) 1 + 1 / x, 30)(1)
[1] 1.618034

Reduce> ## which is the same as
Reduce> cfrac(rep.int(1, 31))
[1] 1.618034

Reduce> ## Computing square root approximations for x as fixed points of the
Reduce> ## function t |-> (t + x / t) / 2, as a function of the initial value:
Reduce> asqrt <- function(x, n) Iterate(function(t) (t + x / t) / 2, n)

Reduce> asqrt(2, 30)(10) # Starting from a positive value => +sqrt(2)
[1] 1.414214

Reduce> asqrt(2, 30)(-1) # Starting from a negative value => -sqrt(2)
[1] -1.414214

Reduce> ## A list of all functions in the base environment:
Reduce> funs <- Filter(is.function, sapply(ls(baseenv()), get, baseenv()))

Reduce> ## Functions in base with more than 10 arguments:
Reduce> names(Filter(function(f) length(formals(args(f))) > 10, funs))
[1] "format.default"   "formatC"          "merge.data.frame" "prettyNum"       
[5] "scan"             "source"          

Reduce> ## Number of functions in base with a '...' argument:
Reduce> length(Filter(function(f)
Reduce+               any(names(formals(args(f))) %in% "..."),
Reduce+               funs))
[1] 419

Reduce> ## No test: 
Reduce> ## Find all objects in the base environment which are *not* functions:
Reduce> Filter(Negate(is.function),  sapply(ls(baseenv()), get, baseenv()))
$F
[1] FALSE

$LETTERS
 [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S"
[20] "T" "U" "V" "W" "X" "Y" "Z"

$R.version
               _                            
platform       i686-pc-linux-gnu            
arch           i686                         
os             linux-gnu                    
system         i686, linux-gnu              
status                                      
major          2                            
minor          15.1                         
year           2012                         
month          06                           
day            22                           
svn rev        59600                        
language       R                            
version.string R version 2.15.1 (2012-06-22)
nickname       Roasted Marshmallows         

$R.version.string
[1] "R version 2.15.1 (2012-06-22)"

$T
[1] TRUE

$letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"

$month.abb
 [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"

$month.name
 [1] "January"   "February"  "March"     "April"     "May"       "June"     
 [7] "July"      "August"    "September" "October"   "November"  "December" 

$pi
[1] 3.141593

$version
               _                            
platform       i686-pc-linux-gnu            
arch           i686                         
os             linux-gnu                    
system         i686, linux-gnu              
status                                      
major          2                            
minor          15.1                         
year           2012                         
month          06                           
day            22                           
svn rev        59600                        
language       R                            
version.string R version 2.15.1 (2012-06-22)
nickname       Roasted Marshmallows         


Reduce> ## End(No test)
Reduce> 
Reduce> 
> example(gc)

gc> ## No test: 
gc> gc() #- do it now
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 314517  8.4     531268 14.2   467875 12.5
Vcells 298800  2.3    2509842 19.2  3137303 24.0

gc> gcinfo(TRUE) #-- in the future, show when R does it
[1] FALSE

gc> x <- integer(100000); for(i in 1:18) x <- c(x,i)

gc> gcinfo(verbose = FALSE)#-- don't show it anymore
[1] TRUE

gc> gc(TRUE)
Garbage collection 21 = 14+1+6 (level 2) ... 
8.4 Mbytes of cons cells used (53%)
2.7 Mbytes of vectors used (17%)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 314503  8.4     597831 16.0   467875 12.5
Vcells 348776  2.7    2007873 15.4  3137303 24.0

gc> gc(reset=TRUE)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 314510  8.4     597831 16.0   314510  8.4
Vcells 348801  2.7    1606298 12.3   348801  2.7

gc> ## End(No test)
gc> 
gc> 
> example(memory.profile)

mmry.p> ## No test: 
mmry.p> memory.profile()
       NULL      symbol    pairlist     closure environment     promise 
          1        7196      150933        4177         420        5016 
   language     special     builtin        char     logical     integer 
      51896          45         689        9595        5876       20793 
     double     complex   character         ...         any        list 
       1836          30       27161           0           0       14312 
 expression    bytecode externalptr     weakref         raw          S4 
          3       12791         578         145         147         787 

mmry.p> ## End(No test)
mmry.p> 
mmry.p> 
> paste("Today is", date()) # from paste.Rd
[1] "Today is Fri Sep 21 15:05:15 2012"
> trunc(Sys.time(), "day") # from round.POSIXt.Rd
[1] "2012-09-21"
> example(srcref)

srcref> ## No test: 
srcref>  # has timestamp
srcref> src <- srcfile(system.file("DESCRIPTION", package = "base"))

srcref> summary(src)
/usr/local/R-2.15.1/library/base/DESCRIPTION 
Timestamp: 2012-09-21 13:23:49 IST
Encoding: "native.enc"

srcref> getSrcLines(src, 1, 4)
[1] "Package: base"             "Version: 2.15.1"          
[3] "Priority: base"            "Title: The R Base Package"

srcref> ref <- srcref(src, c(1, 1, 2, 1000))

srcref> ref
Package: base
Version: 2.15.1

srcref> print(ref, useSource = FALSE)
<srcref: file "/usr/local/R-2.15.1/library/base/DESCRIPTION" chars 1:1 to 2:1000>

srcref> ## End(No test)
srcref> 
srcref> 
> example(strptime)

strptm> ## No test: 
strptm> ## locale-specific version of date()
strptm> format(Sys.time(), "%a %b %d %X %Y %Z")
[1] "Fri Sep 21 15:05:15 2012 IST"

strptm> ## time to sub-second accuracy (if supported by the OS)
strptm> format(Sys.time(), "%H:%M:%OS3")
[1] "15:05:15.050"

strptm> ## read in date info in format 'ddmmmyyyy'
strptm> ## This will give NA(s) in some locales; setting the C locale
strptm> ## as in the commented lines will overcome this on most systems.
strptm> ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
strptm> x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")

strptm> z <- strptime(x, "%d%b%Y")

strptm> ## Sys.setlocale("LC_TIME", lct)
strptm> z
[1] "1960-01-01" "1960-01-02" "1960-03-31" "1960-07-30"

strptm> ## read in date/time info in format 'm/d/y h:m:s'
strptm> dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")

strptm> times <- c("23:03:20", "22:29:56", "01:03:30", "18:21:03", "16:56:26")

strptm> x <- paste(dates, times)

strptm> strptime(x, "%m/%d/%y %H:%M:%S")
[1] "1992-02-27 23:03:20" "1992-02-27 22:29:56" "1992-01-14 01:03:30"
[4] "1992-02-28 18:21:03" "1992-02-01 16:56:26"

strptm> ## time with fractional seconds
strptm> z <- strptime("20/2/06 11:16:16.683", "%d/%m/%y %H:%M:%OS")

strptm> z # prints without fractional seconds
[1] "2006-02-20 11:16:16"

strptm> op <- options(digits.secs=3)

strptm> z
[1] "2006-02-20 11:16:16.682"

strptm> options(op)

strptm> ## timezones are not portable, but 'EST5EDT' comes pretty close.
strptm> (x <- strptime(c("2006-01-08 10:07:52", "2006-08-07 19:33:02"),
strptm+                "%Y-%m-%d %H:%M:%S", tz="EST5EDT"))
[1] "2006-01-08 10:07:52 EST" "2006-08-07 19:33:02 EDT"

strptm> attr(x, "tzone")
[1] "EST5EDT" "EST"     "EDT"    

strptm> ## An RFC 822 header (Eastern Canada, during DST)
strptm> strptime("Tue, 23 Mar 2010 14:36:38 -0400",  "%a, %d %b %Y %H:%M:%S %z")
[1] "2010-03-24 00:06:38"

strptm> ## End(No test)
strptm> 
strptm> 
> example(sys.parent)

sys.pr> ## No test: 
sys.pr> require(utils)

sys.pr> ## Note: the first two examples will give different results
sys.pr> ## if run by example().
sys.pr> ff <- function(x) gg(x)

sys.pr> gg <- function(y) sys.status()

sys.pr> str(ff(1))
List of 3
 $ sys.calls  :Dotted pair list of 9
  ..$ : language example(sys.parent)
  ..$ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = paste0(prompt.prefix, getOption("continue")), verbose = verbose,  ...
  ..$ : language withVisible(eval(ei, envir))
  ..$ : language eval(ei, envir)
  ..$ : language eval(expr, envir, enclos)
  ..$ :length 2 str(ff(1))
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 15 1 15 10 1 10 15 15
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0xaac0680> 
  ..$ : language ff(1)
  ..$ :length 2 gg(x)
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 13 7 13 23 7 23 13 13
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0xaac0680> 
  ..$ :length 1 sys.status()
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 14 7 14 30 7 30 14 14
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0xaac0680> 
 $ sys.parents: int [1:9] 0 1 2 2 4 0 0 7 8
 $ sys.frames :Dotted pair list of 9
  ..$ :<environment: 0xa7ab460> 
  ..$ :<environment: 0xaabf46c> 
  ..$ :<environment: 0xaaea5ec> 
  ..$ :<environment: 0xaaea50c> 
  ..$ :<environment: R_GlobalEnv> 
  ..$ :<environment: 0xaaea3a0> 
  ..$ :<environment: 0xaaea170> 
  ..$ :<environment: 0xaaea0c8> 
  ..$ :<environment: 0xaaea074> 

sys.pr> gg <- function(y) {
sys.pr+     ggg <- function() {
sys.pr+         cat("current frame is", sys.nframe(), "\n")
sys.pr+         cat("parents are", sys.parents(), "\n")
sys.pr+         print(sys.function(0)) # ggg
sys.pr+         print(sys.function(2)) # gg
sys.pr+     }
sys.pr+     if(y > 0) gg(y-1) else ggg()
sys.pr+ }

sys.pr> gg(3)
current frame is 10 
parents are 0 1 2 2 4 0 6 7 8 9 
function() {
        cat("current frame is", sys.nframe(), "\n")
        cat("parents are", sys.parents(), "\n")
        print(sys.function(0)) # ggg
        print(sys.function(2)) # gg
    }
<environment: 0xa09b7e4>
function (file, local = FALSE, echo = verbose, print.eval = echo, 
    verbose = getOption("verbose"), prompt.echo = getOption("prompt"), 
    max.deparse.length = 150, chdir = FALSE, encoding = getOption("encoding"), 
    continue.echo = getOption("continue"), skip.echo = 0, keep.source = getOption("keep.source")) 
{
    envir <- if (isTRUE(local)) {
        parent.frame()
    }
    else if (identical(local, FALSE)) {
        .GlobalEnv
    }
    else if (is.environment(local)) {
        local
    }
    else stop("'local' must be TRUE, FALSE or an environment")
    have_encoding <- !missing(encoding) && encoding != "unknown"
    if (!missing(echo)) {
        if (!is.logical(echo)) 
            stop("'echo' must be logical")
        if (!echo && verbose) {
            warning("'verbose' is TRUE, 'echo' not; ... coercing 'echo <- TRUE'")
            echo <- TRUE
        }
    }
    if (verbose) {
        cat("'envir' chosen:")
        print(envir)
    }
    ofile <- file
    from_file <- FALSE
    srcfile <- NULL
    if (is.character(file)) {
        if (identical(encoding, "unknown")) {
            enc <- utils::localeToCharset()
            encoding <- enc[length(enc)]
        }
        else enc <- encoding
        if (length(enc) > 1L) {
            encoding <- NA
            owarn <- options("warn")
            options(warn = 2)
            for (e in enc) {
                if (is.na(e)) 
                  next
                zz <- file(file, encoding = e)
                res <- tryCatch(readLines(zz, warn = FALSE), 
                  error = identity)
                close(zz)
                if (!inherits(res, "error")) {
                  encoding <- e
                  break
                }
            }
            options(owarn)
        }
        if (is.na(encoding)) 
            stop("unable to find a plausible encoding")
        if (verbose) 
            cat(gettextf("encoding = \"%s\" chosen", encoding), 
                "\n", sep = "")
        if (file == "") 
            file <- stdin()
        else {
            filename <- file
            file <- file(filename, "r", encoding = encoding)
            on.exit(close(file))
            if (isTRUE(keep.source)) {
                lines <- readLines(file, warn = FALSE)
                on.exit()
                close(file)
                srcfile <- srcfilecopy(filename, lines, file.info(filename)[1, 
                  "mtime"], isFile = TRUE)
            }
            else from_file <- TRUE
            loc <- utils::localeToCharset()[1L]
            encoding <- if (have_encoding) 
                switch(loc, `UTF-8` = "UTF-8", `ISO8859-1` = "latin1", 
                  "unknown")
            else "unknown"
        }
    }
    else {
        lines <- readLines(file, warn = FALSE)
        if (isTRUE(keep.source)) 
            srcfile <- srcfilecopy(deparse(substitute(file)), 
                lines)
    }
    if (!isTRUE(keep.source)) {
        op <- options(keep.source = FALSE)
        on.exit(options(op), add = TRUE)
    }
    else op <- NULL
    exprs <- if (!from_file) {
        if (length(lines)) 
            .Internal(parse(stdin(), n = -1, lines, "?", srcfile, 
                encoding))
        else expression()
    }
    else .Internal(parse(file, n = -1, NULL, "?", srcfile, encoding))
    on.exit()
    if (from_file) 
        close(file)
    if (!is.null(op)) 
        options(op)
    Ne <- length(exprs)
    if (verbose) 
        cat("--> parsed", Ne, "expressions; now eval(.)ing them:\n")
    if (chdir) {
        if (is.character(ofile)) {
            isURL <- length(grep("^(ftp|http|file)://", ofile)) > 
                0L
            if (isURL) 
                warning("'chdir = TRUE' makes no sense for a URL")
            if (!isURL && (path <- dirname(ofile)) != ".") {
                owd <- getwd()
                if (is.null(owd)) 
                  stop("cannot 'chdir' as current directory is unknown")
                on.exit(setwd(owd), add = TRUE)
                setwd(path)
            }
        }
        else {
            warning("'chdir = TRUE' makes no sense for a connection")
        }
    }
    if (echo) {
        sd <- "\""
        nos <- "[^\"]*"
        oddsd <- paste("^", nos, sd, "(", nos, sd, nos, sd, ")*", 
            nos, "$", sep = "")
        trySrcLines <- function(srcfile, showfrom, showto) {
            lines <- try(suppressWarnings(getSrcLines(srcfile, 
                showfrom, showto)), silent = TRUE)
            if (inherits(lines, "try-error")) 
                lines <- character()
            lines
        }
    }
    yy <- NULL
    lastshown <- 0
    srcrefs <- attr(exprs, "srcref")
    for (i in seq_len(Ne + echo)) {
        tail <- i > Ne
        if (!tail) {
            if (verbose) 
                cat("\n>>>> eval(expression_nr.", i, ")\n\t\t =================\n")
            ei <- exprs[i]
        }
        if (echo) {
            srcref <- NULL
            nd <- 0
            if (tail) 
                srcref <- attr(exprs, "wholeSrcref")
            else if (i <= length(srcrefs)) 
                srcref <- srcrefs[[i]]
            if (!is.null(srcref)) {
                if (i == 1) 
                  lastshown <- min(skip.echo, srcref[3L] - 1)
                if (lastshown < srcref[3L]) {
                  srcfile <- attr(srcref, "srcfile")
                  dep <- trySrcLines(srcfile, lastshown + 1, 
                    srcref[3L])
                  if (length(dep)) {
                    if (tail) 
                      leading <- length(dep)
                    else leading <- srcref[1L] - lastshown
                    lastshown <- srcref[3L]
                    while (length(dep) && length(grep("^[[:blank:]]*$", 
                      dep[1L]))) {
                      dep <- dep[-1L]
                      leading <- leading - 1L
                    }
                    dep <- paste(rep.int(c(prompt.echo, continue.echo), 
                      c(leading, length(dep) - leading)), dep, 
                      sep = "", collapse = "\n")
                    nd <- nchar(dep, "c")
                  }
                  else srcref <- NULL
                }
            }
            if (is.null(srcref)) {
                if (!tail) {
                  dep <- substr(paste(deparse(ei, control = "showAttributes"), 
                    collapse = "\n"), 12L, 1000000L)
                  dep <- paste0(prompt.echo, gsub("\n", paste0("\n", 
                    continue.echo), dep))
                  nd <- nchar(dep, "c") - 1L
                }
            }
            if (nd) {
                do.trunc <- nd > max.deparse.length
                dep <- substr(dep, 1L, if (do.trunc) 
                  max.deparse.length
                else nd)
                cat("\n", dep, if (do.trunc) 
                  paste(if (length(grep(sd, dep)) && length(grep(oddsd, 
                    dep))) 
                    " ...\" ..."
                  else " ....", "[TRUNCATED] "), "\n", sep = "")
            }
        }
        if (!tail) {
            yy <- withVisible(eval(ei, envir))
            i.symbol <- mode(ei[[1L]]) == "name"
            if (!i.symbol) {
                curr.fun <- ei[[1L]][[1L]]
                if (verbose) {
                  cat("curr.fun:")
                  utils::str(curr.fun)
                }
            }
            if (verbose >= 2) {
                cat(".... mode(ei[[1L]])=", mode(ei[[1L]]), "; paste(curr.fun)=")
                utils::str(paste(curr.fun))
            }
            if (print.eval && yy$visible) {
                if (isS4(yy$value)) 
                  methods::show(yy$value)
                else print(yy$value)
            }
            if (verbose) 
                cat(" .. after ", sQuote(deparse(ei, control = c("showAttributes", 
                  "useSource"))), "\n", sep = "")
        }
    }
    invisible(yy)
}
<bytecode: 0x9e38b78>
<environment: namespace:base>

sys.pr> t1 <- function() {
sys.pr+   aa <- "here"
sys.pr+   t2 <- function() {
sys.pr+     ## in frame 2 here
sys.pr+     cat("current frame is", sys.nframe(), "\n")
sys.pr+     str(sys.calls()) ## list with two components t1() and t2()
sys.pr+     cat("parents are frame numbers", sys.parents(), "\n") ## 0 1
sys.pr+     print(ls(envir=sys.frame(-1))) ## [1] "aa" "t2"
sys.pr+     invisible()
sys.pr+   }
sys.pr+   t2()
sys.pr+ }

sys.pr> t1()
current frame is 7 
Dotted pair list of 7
 $ : language example(sys.parent)
 $ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = paste0(prompt.prefix, getOption("continue")), verbose = verbose,  ...
 $ : language withVisible(eval(ei, envir))
 $ : language eval(ei, envir)
 $ : language eval(expr, envir, enclos)
 $ :length 1 t1()
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 40 1 40 4 1 4 40 40
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0xaac0680> 
 $ :length 1 t2()
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 38 3 38 6 3 6 38 38
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0xaac0680> 
parents are frame numbers 0 1 2 2 4 0 6 
[1] "aa" "t2"

sys.pr> test.sys.on.exit <- function() {
sys.pr+   on.exit(print(1))
sys.pr+   ex <- sys.on.exit()
sys.pr+   str(ex)
sys.pr+   cat("exiting...\n")
sys.pr+ }

sys.pr> test.sys.on.exit()
 language print(1)
exiting...
[1] 1

sys.pr> ## gives 'language print(1)', prints 1 on exit
sys.pr> 
sys.pr> ## An example where the parent is not the next frame up the stack
sys.pr> ## since method dispatch uses a frame.
sys.pr> as.double.foo <- function(x)
sys.pr+ {
sys.pr+     str(sys.calls())
sys.pr+     print(sys.frames())
sys.pr+     print(sys.parents())
sys.pr+     print(sys.frame(-1)); print(parent.frame())
sys.pr+     x
sys.pr+ }

sys.pr> t2 <- function(x) as.double(x)

sys.pr> a <- structure(pi, class = "foo")

sys.pr> t2(a)
Dotted pair list of 8
 $ : language example(sys.parent)
 $ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = paste0(prompt.prefix, getOption("continue")), verbose = verbose,  ...
 $ : language withVisible(eval(ei, envir))
 $ : language eval(ei, envir)
 $ : language eval(expr, envir, enclos)
 $ :length 2 t2(a)
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 63 1 63 5 1 5 63 63
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0xaac0680> 
 $ :length 2 as.double(x)
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 61 7 61 30 7 30 61 61
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0xaac0680> 
 $ :length 2 as.double.foo(x)
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 61 7 61 30 7 30 61 61
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0xaac0680> 
[[1]]
<environment: 0xa7ab460>

[[2]]
<environment: 0xaabf46c>

[[3]]
<environment: 0x9f821c8>

[[4]]
<environment: 0x9f822c4>

[[5]]
<environment: R_GlobalEnv>

[[6]]
<environment: 0x9f82414>

[[7]]
<environment: 0x9d4b6dc>

[[8]]
<environment: 0x9d4b810>

[1] 0 1 2 2 4 0 6 6
<environment: 0x9d4b6dc>
<environment: 0x9f82414>
[1] 3.141593
attr(,"class")
[1] "foo"

sys.pr> ## End(No test)
sys.pr> 
sys.pr> 
> example(system.time)

systm.> require(stats)

systm.> ## No test: 
systm.> system.time(for(i in 1:100) mad(runif(1000)))
   user  system elapsed 
  0.020   0.004   0.025 

systm.> ## End(No test)
systm.> ## Not run: 
systm.> ##D exT <- function(n = 10000) {
systm.> ##D   # Purpose: Test if system.time works ok;   n: loop size
systm.> ##D   system.time(for(i in 1:n) x <- mean(rt(1000, df=4)))
systm.> ##D }
systm.> ##D #-- Try to interrupt one of the following (using Ctrl-C / Escape):
systm.> ##D exT()                 #- about 4 secs on a 2.5GHz Xeon
systm.> ##D system.time(exT())    #~ +/- same
systm.> ## End(Not run)
systm.> 
systm.> 
> example(tempfile)

tempfl> ## No test: 
tempfl> tempfile(c("ab", "a b c"))   # give file name with spaces in!
[1] "/tmp/Rtmp4Abhof/abd121971f060"    "/tmp/Rtmp4Abhof/a b cd121078781c"

tempfl> tempfile("plot", fileext=c(".ps", ".pdf"))
[1] "/tmp/Rtmp4Abhof/plotd124166b2ce.ps"  "/tmp/Rtmp4Abhof/plotd127abf2fb2.pdf"

tempfl> tempdir() # works on all platforms with a platform-dependent result
[1] "/tmp/Rtmp4Abhof"

tempfl> ## End(No test)
tempfl> 
tempfl> 
> example(weekdays)

wekdys> ## No test: 
wekdys> weekdays(.leap.seconds)
 [1] "Saturday"  "Monday"    "Tuesday"   "Wednesday" "Thursday"  "Saturday" 
 [7] "Sunday"    "Monday"    "Tuesday"   "Wednesday" "Thursday"  "Friday"   
[13] "Monday"    "Friday"    "Monday"    "Tuesday"   "Wednesday" "Thursday" 
[19] "Friday"    "Monday"    "Tuesday"   "Friday"    "Sunday"    "Thursday" 

wekdys> months(.leap.seconds)
 [1] "July"    "January" "January" "January" "January" "January" "January"
 [8] "January" "January" "July"    "July"    "July"    "July"    "January"
[15] "January" "January" "July"    "July"    "July"    "January" "July"   
[22] "January" "January" "January"

wekdys> quarters(.leap.seconds)
 [1] "Q3" "Q1" "Q1" "Q1" "Q1" "Q1" "Q1" "Q1" "Q1" "Q3" "Q3" "Q3" "Q3" "Q1" "Q1"
[16] "Q1" "Q3" "Q3" "Q3" "Q1" "Q3" "Q1" "Q1" "Q1"

wekdys> ## Julian Day Number (JDN, http://en.wikipedia.org/wiki/Julian_day)
wekdys> ## is the number of days since noon UTC on the first day of 4317 BC.
wekdys> ## in the proleptic Julian calendar.  To more recently, in
wekdys> ## 'Terrestrial Time' which differs from UTC by a few seconds
wekdys> ## See http://en.wikipedia.org/wiki/Terrestrial_Time
wekdys> julian(Sys.Date(), -2440588) # from a day
[1] 2456192
attr(,"origin")
[1] -2440588

wekdys> floor(as.numeric(julian(Sys.time())) + 2440587.5) # from a date-time
[1] 2456191

wekdys> ## End(No test)
wekdys> 
wekdys> 
> library(help="splines")

		Information on package 'splines'

Description:

Package:       splines
Version:       2.15.1
Priority:      base
Imports:       graphics, stats
Title:         Regression Spline Functions and Classes
Author:        Douglas M. Bates <bates@stat.wisc.edu> and William N.
               Venables <Bill.Venables@csiro.au>
Maintainer:    R Core Team <R-core@r-project.org>
Description:   Regression spline functions and classes
License:       Part of R 2.15.1
Built:         R 2.15.1; i686-pc-linux-gnu; 2012-09-21 07:53:46 UTC;
               unix

Index:

asVector                Coerce an Object to a Vector
backSpline              Monotone Inverse Spline
bs                      B-Spline Basis for Polynomial Splines
interpSpline            Create an Interpolation Spline
ns                      Generate a Basis Matrix for Natural Cubic
                        Splines
periodicSpline          Create a Periodic Interpolation Spline
polySpline              Piecewise Polynomial Spline Representation
predict.bSpline         Evaluate a Spline at New Values of x
predict.bs              Evaluate a Spline Basis
splineDesign            Design Matrix for B-splines
splineKnots             Knot Vector from a Spline
splineOrder             Determine the Order of a Spline
splines-package         Regression Spline Functions and Classes
xyVector                Construct an 'xyVector' Object

> 
> ## utils
> example(news)

news> ## No test: 
news> ## Build a db of all R news entries.
news> db <- news()

news> ## Bug fixes with PR number in 2.11.0.
news> news(Version == "2.11.0" & grepl("^BUG", Category) & grepl("PR#", Text),
news+      db = db)
Changes in version 2.11.0:

BUG FIXES

    o   Using with(), eval() etc with a list with some unnamed elements now
	 works.  (PR#14035)

    o   cor(A, B) where A is n x 1 and B a 1-dimensional array segfaulted or
	 gave an internal error.  (The case cor(B, A) was PR#7116.)

    o   cut.POSIXt() applied to a start value after the DST transition on a
	 DST-change day could give the wrong time for argument breaks in
	 units of days or longer.  (PR#14208)

    o   do_par() UNPROTECTed too early (PR#14214)

    o   Subassignment x[[....]] <- y didn't check for a zero-length right
	 hand side, and inserted a rubbish value.  (PR#14217)

    o   Extreme tail behavior of, pbeta() {and hence pf()}, e.g., pbeta(x,
	 3, 2200, lower.tail=FALSE, log.p=TRUE) now returns finite values
	 instead of jumping to -Inf too early.  (PR#14230).

    o   read.fwf() misread multi-line records when n was specified.
	 (PR#14241)

    o   gzcon( <textConnection> ), an error, no longer damages the
	 connection (in a way to have it segfault).  (PR#14237)

    o   If xy[z].coords (used internally by many graphics functions) are
	 given a list as x, they now check that the list has suitable names
	 and give a more informative error message.  (PR#13936)

news> ## Which categories have been in use? % R-core maybe should standardize a bit more
news> sort(table(db[,"Category"]), decreasing=TRUE)

                    NEW FEATURES                        BUG FIXES 
                             531                              483 
                    INSTALLATION             DEPRECATED & DEFUNCT 
                              51                               44 
            PACKAGE INSTALLATION                        UTILITIES 
                              37                               37 
          DEPRECATED AND DEFUNCT SIGNIFICANT USER-VISIBLE CHANGES 
                              27                               18 
                GRAPHICS DEVICES           HELP & Rd FILE CHANGES 
                              17                               16 
              SWEAVE & VIGNETTES               C-LEVEL FACILITIES 
                              16                               12 
                     COMPRESSION              REGULAR EXPRESSIONS 
                              11                               10 
        PERFORMANCE IMPROVEMENTS                 PACKAGE parallel 
                               6                                5 
                  SWEAVE CHANGES         WINDOWS-SPECIFIC CHANGES 
                               5                                2 
            INTERNATIONALIZATION                          LICENCE 
                               1                                1 

news> ## Entries with version >= 2.10.1 (including "2.10.1 patched"):
news> table(news(Version >= "2.10.1", db = db)$Version)

        2.10.1 2.10.1 patched         2.11.0         2.11.1 2.11.1 patched 
            43             35            132             29             26 
        2.12.0         2.12.1         2.12.2 2.12.2 patched         2.13.0 
           153             42             47              9            154 
        2.13.1         2.13.2         2.14.0         2.14.1         2.14.2 
            49             33            196             34             33 
        2.15.0         2.15.1 
            95             67 

news> ## End(No test)
news> 
news> 
> example(packageDescription)

pckgDs> ## No test: 
pckgDs> packageDescription("stats")
Package: stats
Version: 2.15.1
Priority: base
Title: The R Stats Package
Author: R Core Team and contributors worldwide
Maintainer: R Core Team <R-core@r-project.org>
Description: R statistical functions
License: Part of R 2.15.1
Built: R 2.15.1; i686-pc-linux-gnu; 2012-09-21 07:52:48 UTC; unix

-- File: /usr/local/R-2.15.1/library/stats/Meta/package.rds 

pckgDs> packageDescription("stats", fields = c("Package", "Version"))
Package: stats
Version: 2.15.1

-- File: /usr/local/R-2.15.1/library/stats/Meta/package.rds 
-- Fields read: Package, Version

pckgDs> packageDescription("stats", fields = "Version")
[1] "2.15.1"

pckgDs> packageDescription("stats", fields = "Version", drop = FALSE)
Version: 2.15.1

-- File: /usr/local/R-2.15.1/library/stats/Meta/package.rds 
-- Fields read: Version

pckgDs> if(packageVersion("MASS") < "7.3")
pckgDs+   message("you need to update 'MASS'")

pckgDs> ## End(No test)
pckgDs> 
pckgDs> 
> example(sessionInfo)

sssnIn> ## No test: 
sssnIn> sessionInfo()
R version 2.15.1 (2012-06-22)
Platform: i686-pc-linux-gnu (32-bit)

locale:
[1] C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

loaded via a namespace (and not attached):
[1] tools_2.15.1

sssnIn> toLatex(sessionInfo(), locale=FALSE)
\begin{itemize}\raggedright
  \item R version 2.15.1 (2012-06-22), \verb|i686-pc-linux-gnu|
  \item Base packages: base, datasets, grDevices, graphics, methods,
    stats, utils
  \item Loaded via a namespace (and not attached): tools~2.15.1
\end{itemize}

sssnIn> ## End(No test)
sssnIn> 
sssnIn> 
> 
> ## datasets
> example(JohnsonJohnson)

JhnsnJ> ## No test: 
JhnsnJ> require(stats); require(graphics)

JhnsnJ> JJ <- log10(JohnsonJohnson)

JhnsnJ> plot(JJ)

JhnsnJ> ## This example gives a possible-non-convergence warning on some
JhnsnJ> ## platforms, but does seem to converge on x86 Linux and Windows.
JhnsnJ> (fit <- StructTS(JJ, type="BSM"))

Call:
StructTS(x = JJ, type = "BSM")

Variances:
    level      slope       seas    epsilon  
1.948e-04  6.547e-06  4.138e-04  2.648e-04  

JhnsnJ> tsdiag(fit)

JhnsnJ> sm <- tsSmooth(fit)

JhnsnJ> plot(cbind(JJ, sm[, 1], sm[, 3]-0.5), plot.type = "single",
JhnsnJ+      col = c("black", "green", "blue"))

JhnsnJ> abline(h = -0.5, col = "grey60")

JhnsnJ> monthplot(fit)

JhnsnJ> ## End(No test)
JhnsnJ> 
JhnsnJ> 
> example(ability.cov)

ablty.> ## No test: 
ablty.> require(stats)

ablty.> (ability.FA <- factanal(factors = 1, covmat=ability.cov))

Call:
factanal(factors = 1, covmat = ability.cov)

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.535   0.853   0.748   0.910   0.232   0.280 

Loadings:
        Factor1
general 0.682  
picture 0.384  
blocks  0.502  
maze    0.300  
reading 0.877  
vocab   0.849  

               Factor1
SS loadings      2.443
Proportion Var   0.407

Test of the hypothesis that 1 factor is sufficient.
The chi square statistic is 75.18 on 9 degrees of freedom.
The p-value is 1.46e-12 

ablty.> update(ability.FA, factors = 2)

Call:
factanal(factors = 2, covmat = ability.cov)

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.455   0.589   0.218   0.769   0.052   0.334 

Loadings:
        Factor1 Factor2
general 0.499   0.543  
picture 0.156   0.622  
blocks  0.206   0.860  
maze    0.109   0.468  
reading 0.956   0.182  
vocab   0.785   0.225  

               Factor1 Factor2
SS loadings      1.858   1.724
Proportion Var   0.310   0.287
Cumulative Var   0.310   0.597

Test of the hypothesis that 2 factors are sufficient.
The chi square statistic is 6.11 on 4 degrees of freedom.
The p-value is 0.191 

ablty.> ## The signs of factors and hence the signs of correlations are
ablty.> ## arbitrary with promax rotation.
ablty.> update(ability.FA, factors = 2, rotation = "promax")

Call:
factanal(factors = 2, covmat = ability.cov, rotation = "promax")

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.455   0.589   0.218   0.769   0.052   0.334 

Loadings:
        Factor1 Factor2
general  0.364   0.470 
picture          0.671 
blocks           0.932 
maze             0.508 
reading  1.023         
vocab    0.811         

               Factor1 Factor2
SS loadings      1.853   1.807
Proportion Var   0.309   0.301
Cumulative Var   0.309   0.610

Factor Correlations:
        Factor1 Factor2
Factor1   1.000   0.557
Factor2   0.557   1.000

Test of the hypothesis that 2 factors are sufficient.
The chi square statistic is 6.11 on 4 degrees of freedom.
The p-value is 0.191 

ablty.> ## End(No test)
ablty.> 
ablty.> 
> 
> ## grDevices
> if(.Platform$OS.type == "windows") {
+     example(windowsFonts)
+ } else {
+     example(X11Fonts)
+     example(quartzFonts)
+ }

X11Fnt> X11Fonts()
$serif
[1] "-*-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$sans
[1] "-*-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$mono
[1] "-*-courier-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Times
[1] "-adobe-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Helvetica
[1] "-adobe-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$CyrTimes
[1] "-cronyx-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$CyrHelvetica
[1] "-cronyx-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Arial
[1] "-monotype-arial-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Mincho
[1] "-*-mincho-%s-%s-*-*-%d-*-*-*-*-*-*-*"


X11Fnt> X11Fonts("mono")
$mono
[1] "-*-courier-%s-%s-*-*-%d-*-*-*-*-*-*-*"


X11Fnt> utopia <- X11Font("-*-utopia-*-*-*-*-*-*-*-*-*-*-*-*")

X11Fnt> X11Fonts(utopia = utopia)

qrtzFn> quartzFonts()
$serif
[1] "Times-Roman"      "Times-Bold"       "Times-Italic"     "Times-BoldItalic"

$sans
[1] "Helvetica"             "Helvetica-Bold"        "Helvetica-Oblique"    
[4] "Helvetica-BoldOblique"

$mono
[1] "Courier"             "Courier-Bold"        "Courier-Oblique"    
[4] "Courier-BoldOblique"


qrtzFn> quartzFonts("mono")
$mono
[1] "Courier"             "Courier-Bold"        "Courier-Oblique"    
[4] "Courier-BoldOblique"


qrtzFn> ## Not run: 
qrtzFn> ##D ## for CJK locales you can use something like
qrtzFn> ##D quartzFonts(sans = quartzFont(rep("AppleGothic", 4)),
qrtzFn> ##D             serif = quartzFont(rep("AppleMyungjp", 4)))
qrtzFn> ##D ## since the default fonts may well not have the glyphs needed
qrtzFn> ## End(Not run)
qrtzFn> 
qrtzFn> 
> 
> library(tools)
> example(Rdutils)
Warning message:
In example(Rdutils) : no help found for 'Rdutils'
> example(fileutils)
Warning message:
In example(fileutils) : no help found for 'fileutils'
> ## results are location- and OS-specific
> example(parseLatex) # charset-specific

prsLtx> ## No test: 
prsLtx> latex <- parseLatex("fa\\c{c}ile")

prsLtx> deparseLatex(latexToUtf8(latex))
[1] "fa<U+00E7>ile"

prsLtx> ## End(No test)
prsLtx> 
prsLtx> 
> 
> proc.time()
   user  system elapsed 
  2.636   0.060   6.434 
> 
